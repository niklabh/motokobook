<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Mastering Motoko!</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Mastering Motoko!</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#mastering-motoko" id="toc-mastering-motoko">Mastering
Motoko</a>
<ul>
<li><a href="#table-of-contents" id="toc-table-of-contents">Table of
Contents</a></li>
</ul></li>
<li><a href="#preface" id="toc-preface">Preface</a></li>
<li><a href="#foreword" id="toc-foreword">Foreword</a></li>
<li><a href="#chapter-1-introduction-to-the-internet-computer-protocol"
id="toc-chapter-1-introduction-to-the-internet-computer-protocol">Chapter
1: Introduction to the Internet Computer Protocol</a>
<ul>
<li><a href="#introduction-to-the-internet-computer-protocol-icp"
id="toc-introduction-to-the-internet-computer-protocol-icp">1.0
Introduction to the Internet Computer Protocol (ICP)</a></li>
<li><a href="#the-necessity-of-the-actor-model"
id="toc-the-necessity-of-the-actor-model">1.1 The Necessity of the Actor
Model</a></li>
<li><a href="#the-canister-environment"
id="toc-the-canister-environment">1.2 The Canister Environment</a></li>
<li><a href="#the-development-lifecycle"
id="toc-the-development-lifecycle">1.3 The Development
Lifecycle</a></li>
<li><a href="#setting-up-your-local-development-environment"
id="toc-setting-up-your-local-development-environment">1.4 Setting Up
Your Local Development Environment</a></li>
</ul></li>
<li><a href="#chapter-2-motoko-fundamentals"
id="toc-chapter-2-motoko-fundamentals">Chapter 2: Motoko
Fundamentals</a>
<ul>
<li><a href="#hello-world" id="toc-hello-world">2.1 Hello,
World!</a></li>
<li><a href="#basic-syntax" id="toc-basic-syntax">2.2 Basic Syntax</a>
<ul>
<li><a href="#comments" id="toc-comments">2.2.1 Comments</a></li>
<li><a href="#expressions-and-blocks"
id="toc-expressions-and-blocks">2.2.2 Expressions and Blocks</a></li>
<li><a href="#identifiers-and-naming"
id="toc-identifiers-and-naming">2.2.3 Identifiers and Naming</a></li>
</ul></li>
<li><a href="#types" id="toc-types">2.3 Types</a>
<ul>
<li><a href="#primitive-types" id="toc-primitive-types">2.3.1 Primitive
Types</a></li>
<li><a href="#composite-types" id="toc-composite-types">2.3.2 Composite
Types</a></li>
<li><a href="#function-types" id="toc-function-types">2.3.3 Function
Types</a></li>
<li><a href="#async-types" id="toc-async-types">2.3.4 Async
Types</a></li>
<li><a href="#generic-types" id="toc-generic-types">2.3.5 Generic
Types</a></li>
</ul></li>
<li><a href="#declarations" id="toc-declarations">2.4 Declarations</a>
<ul>
<li><a href="#immutable-declarations-let"
id="toc-immutable-declarations-let">2.4.1 Immutable Declarations
(<code>let</code>)</a></li>
<li><a href="#mutable-declarations-var"
id="toc-mutable-declarations-var">2.4.2 Mutable Declarations
(<code>var</code>)</a></li>
<li><a href="#function-declarations"
id="toc-function-declarations">2.4.3 Function Declarations</a></li>
<li><a href="#type-declarations" id="toc-type-declarations">2.4.4 Type
Declarations</a></li>
</ul></li>
<li><a href="#control-flow" id="toc-control-flow">2.5 Control Flow</a>
<ul>
<li><a href="#conditionals" id="toc-conditionals">2.5.1
Conditionals</a></li>
<li><a href="#loops" id="toc-loops">2.5.2 Loops</a></li>
<li><a href="#switch-and-pattern-matching"
id="toc-switch-and-pattern-matching">2.5.3 Switch and Pattern
Matching</a></li>
</ul></li>
<li><a href="#actors-and-async-data" id="toc-actors-and-async-data">2.6
Actors and Async Data</a>
<ul>
<li><a href="#understanding-actors" id="toc-understanding-actors">2.6.1
Understanding Actors</a></li>
<li><a href="#public-and-private-functions"
id="toc-public-and-private-functions">2.6.2 Public and Private
Functions</a></li>
<li><a href="#async-and-await" id="toc-async-and-await">2.6.3 Async and
Await</a></li>
<li><a href="#actor-classes" id="toc-actor-classes">2.6.4 Actor
Classes</a></li>
<li><a href="#caller-identity" id="toc-caller-identity">2.6.5 Caller
Identity</a></li>
</ul></li>
<li><a href="#mutable-state" id="toc-mutable-state">2.7 Mutable
State</a>
<ul>
<li><a href="#mutable-variables" id="toc-mutable-variables">2.7.1
Mutable Variables</a></li>
<li><a href="#mutable-collections" id="toc-mutable-collections">2.7.2
Mutable Collections</a></li>
<li><a href="#state-transitions" id="toc-state-transitions">2.7.3 State
Transitions</a></li>
</ul></li>
<li><a href="#messaging" id="toc-messaging">2.8 Messaging</a>
<ul>
<li><a href="#update-vs-query-messages"
id="toc-update-vs-query-messages">2.8.1 Update vs Query
Messages</a></li>
<li><a href="#one-way-messages" id="toc-one-way-messages">2.8.2 One-way
Messages</a></li>
<li><a href="#inter-canister-calls" id="toc-inter-canister-calls">2.8.3
Inter-Canister Calls</a></li>
<li><a href="#error-handling-in-messages"
id="toc-error-handling-in-messages">2.8.4 Error Handling in
Messages</a></li>
</ul></li>
<li><a href="#modules-and-imports" id="toc-modules-and-imports">2.9
Modules and Imports</a>
<ul>
<li><a href="#defining-modules" id="toc-defining-modules">2.9.1 Defining
Modules</a></li>
<li><a href="#importing-local-modules"
id="toc-importing-local-modules">2.9.2 Importing Local Modules</a></li>
<li><a href="#importing-from-base-library"
id="toc-importing-from-base-library">2.9.3 Importing from Base
Library</a></li>
<li><a href="#module-patterns" id="toc-module-patterns">2.9.4 Module
Patterns</a></li>
</ul></li>
<li><a href="#pattern-matching" id="toc-pattern-matching">2.10 Pattern
Matching</a>
<ul>
<li><a href="#basic-patterns" id="toc-basic-patterns">2.10.1 Basic
Patterns</a></li>
<li><a href="#tuple-patterns" id="toc-tuple-patterns">2.10.2 Tuple
Patterns</a></li>
<li><a href="#record-patterns" id="toc-record-patterns">2.10.3 Record
Patterns</a></li>
<li><a href="#variant-patterns" id="toc-variant-patterns">2.10.4 Variant
Patterns</a></li>
<li><a href="#array-patterns" id="toc-array-patterns">2.10.5 Array
Patterns</a></li>
<li><a href="#guards" id="toc-guards">2.10.6 Guards</a></li>
</ul></li>
<li><a href="#error-handling" id="toc-error-handling">2.11 Error
Handling</a>
<ul>
<li><a href="#try-catch" id="toc-try-catch">2.11.1 Try-Catch</a></li>
<li><a href="#result-type" id="toc-result-type">2.11.2 Result
Type</a></li>
<li><a href="#option-type" id="toc-option-type">2.11.3 Option
Type</a></li>
<li><a href="#assert-and-debug" id="toc-assert-and-debug">2.11.4 Assert
and Debug</a></li>
<li><a href="#error-propagation" id="toc-error-propagation">2.11.5 Error
Propagation</a></li>
</ul></li>
<li><a href="#data-persistence" id="toc-data-persistence">2.12 Data
Persistence</a>
<ul>
<li><a href="#stable-variables" id="toc-stable-variables">2.12.1 Stable
Variables</a></li>
<li><a href="#stable-types" id="toc-stable-types">2.12.2 Stable
Types</a></li>
<li><a href="#upgrade-hooks" id="toc-upgrade-hooks">2.12.3 Upgrade
Hooks</a></li>
<li><a href="#migration-patterns" id="toc-migration-patterns">2.12.4
Migration Patterns</a></li>
</ul></li>
<li><a href="#garbage-collection" id="toc-garbage-collection">2.13
Garbage Collection</a>
<ul>
<li><a href="#memory-management" id="toc-memory-management">2.13.1
Memory Management</a></li>
<li><a href="#memory-optimization" id="toc-memory-optimization">2.13.2
Memory Optimization</a></li>
<li><a href="#monitoring-memory-usage"
id="toc-monitoring-memory-usage">2.13.3 Monitoring Memory Usage</a></li>
</ul></li>
<li><a href="#orthogonal-persistence"
id="toc-orthogonal-persistence">2.14 Orthogonal Persistence</a>
<ul>
<li><a href="#understanding-orthogonal-persistence"
id="toc-understanding-orthogonal-persistence">2.14.1 Understanding
Orthogonal Persistence</a></li>
<li><a href="#stable-vs-regular-variables"
id="toc-stable-vs-regular-variables">2.14.2 Stable vs Regular
Variables</a></li>
<li><a href="#persistence-lifecycle"
id="toc-persistence-lifecycle">2.14.3 Persistence Lifecycle</a></li>
<li><a href="#best-practices" id="toc-best-practices">2.14.4 Best
Practices</a></li>
</ul></li>
<li><a href="#summary" id="toc-summary">Summary</a></li>
</ul></li>
<li><a href="#chapter-3-type-system-and-safety"
id="toc-chapter-3-type-system-and-safety">Chapter 3: Type System and
Safety</a>
<ul>
<li><a href="#nominal-vs.-structural-typing"
id="toc-nominal-vs.-structural-typing">3.1 Nominal vs. Structural
Typing</a></li>
<li><a href="#the-billion-dollar-mistake-option-types"
id="toc-the-billion-dollar-mistake-option-types">3.2 The Billion Dollar
Mistake: Option Types</a></li>
<li><a href="#more-primitive-types" id="toc-more-primitive-types">3.3
More Primitive Types</a></li>
<li><a href="#composite-types-1" id="toc-composite-types-1">3.4
Composite Types</a></li>
<li><a href="#type-aliases" id="toc-type-aliases">3.5 Type
Aliases</a></li>
<li><a href="#generics" id="toc-generics">3.6 Generics</a></li>
<li><a href="#type-inference" id="toc-type-inference">3.7 Type
Inference</a></li>
</ul></li>
<li><a href="#chapter-4-motoko-memory-architecture"
id="toc-chapter-4-motoko-memory-architecture">Chapter 4: Motoko Memory
Architecture</a>
<ul>
<li><a href="#the-stable-heap" id="toc-the-stable-heap">4.1 The Stable
Heap</a></li>
<li><a href="#the-legacy-solution-stable-variables"
id="toc-the-legacy-solution-stable-variables">4.2 The Legacy Solution:
Stable Variables</a></li>
<li><a href="#the-modern-standard-enhanced-orthogonal-persistence-eop"
id="toc-the-modern-standard-enhanced-orthogonal-persistence-eop">4.3 The
Modern Standard: Enhanced Orthogonal Persistence (EOP)</a></li>
<li><a href="#implementing-persistence-in-openpatron"
id="toc-implementing-persistence-in-openpatron">4.4 Implementing
Persistence in OpenPatron</a></li>
</ul></li>
<li><a href="#chapter-5-identity-and-access-control"
id="toc-chapter-5-identity-and-access-control">Chapter 5: Identity and
Access Control</a>
<ul>
<li><a href="#internet-identity-and-principals"
id="toc-internet-identity-and-principals">5.1 Internet Identity and
Principals</a></li>
<li><a href="#the-frontend-backend-handshake"
id="toc-the-frontend-backend-handshake">5.2 The Frontend-Backend
Handshake</a></li>
<li><a href="#storing-user-profiles" id="toc-storing-user-profiles">5.3
Storing User Profiles</a></li>
<li><a href="#implementing-user-profiles"
id="toc-implementing-user-profiles">5.4 Implementing User
Profiles</a></li>
<li><a href="#access-control-patterns"
id="toc-access-control-patterns">5.5 Access Control Patterns</a></li>
<li><a href="#roles-and-permissions" id="toc-roles-and-permissions">5.6
Roles and Permissions</a></li>
<li><a href="#security-considerations"
id="toc-security-considerations">5.7 Security Considerations</a></li>
<li><a href="#frontend-integration" id="toc-frontend-integration">5.8
Frontend Integration</a></li>
<li><a href="#complete-openpatron-identity-implementation"
id="toc-complete-openpatron-identity-implementation">5.9 Complete
OpenPatron Identity Implementation</a></li>
<li><a href="#testing-and-deployment"
id="toc-testing-and-deployment">5.10 Testing and Deployment</a></li>
</ul></li>
<li><a href="#chapter-6-tokenomics-and-ledger-integration"
id="toc-chapter-6-tokenomics-and-ledger-integration">Chapter 6:
Tokenomics and Ledger Integration</a>
<ul>
<li><a href="#inter-canister-ledger-interactions"
id="toc-inter-canister-ledger-interactions">6.1 Inter-Canister Ledger
Interactions</a></li>
<li><a href="#the-deposit-pattern-vs.-approvetransferfrom"
id="toc-the-deposit-pattern-vs.-approvetransferfrom">6.2 The Deposit
Pattern vs. Approve/TransferFrom</a></li>
<li><a href="#deterministic-subaccount-derivation"
id="toc-deterministic-subaccount-derivation">6.3 Deterministic
Subaccount Derivation</a></li>
<li><a href="#verifying-deposits-against-the-ledger"
id="toc-verifying-deposits-against-the-ledger">6.4 Verifying Deposits
Against the Ledger</a></li>
<li><a href="#withdrawals-refunds-and-creator-payouts"
id="toc-withdrawals-refunds-and-creator-payouts">6.5 Withdrawals,
Refunds, and Creator Payouts</a></li>
<li><a href="#supporting-multiple-tokens-icrc-1-vs.-icrc-2"
id="toc-supporting-multiple-tokens-icrc-1-vs.-icrc-2">6.6 Supporting
Multiple Tokens (ICRC-1 vs. ICRC-2)</a></li>
<li><a href="#local-testing-with-the-ledger-canister"
id="toc-local-testing-with-the-ledger-canister">6.7 Local Testing with
the Ledger Canister</a></li>
<li><a href="#operational-safeguards"
id="toc-operational-safeguards">6.8 Operational Safeguards</a></li>
</ul></li>
<li><a href="#chapter-7-autonomous-subscriptions-via-timers"
id="toc-chapter-7-autonomous-subscriptions-via-timers">Chapter 7:
Autonomous Subscriptions via Timers</a>
<ul>
<li><a href="#the-timer-api" id="toc-the-timer-api">7.1 The Timer
API</a></li>
<li><a href="#efficiency-and-virtual-transactions"
id="toc-efficiency-and-virtual-transactions">7.2 Efficiency and
“Virtual” Transactions</a></li>
<li><a href="#scheduling-windows-and-drift"
id="toc-scheduling-windows-and-drift">7.3 Scheduling Windows and
Drift</a></li>
<li><a href="#modeling-the-subscription-queue"
id="toc-modeling-the-subscription-queue">7.4 Modeling the Subscription
Queue</a></li>
<li><a href="#failure-modes-and-recovery"
id="toc-failure-modes-and-recovery">7.5 Failure Modes and
Recovery</a></li>
<li><a href="#manual-overrides-and-observability"
id="toc-manual-overrides-and-observability">7.6 Manual Overrides and
Observability</a></li>
<li><a href="#testing-timer-logic-without-waiting"
id="toc-testing-timer-logic-without-waiting">7.7 Testing Timer Logic
Without Waiting</a></li>
</ul></li>
<li><a href="#chapter-8-asynchronous-safety-and-reentrancy"
id="toc-chapter-8-asynchronous-safety-and-reentrancy">Chapter 8:
Asynchronous Safety and Reentrancy</a>
<ul>
<li><a href="#the-await-gap" id="toc-the-await-gap">8.1 The Await
Gap</a></li>
<li><a href="#the-solution-optimistic-accounting-vs.-locks"
id="toc-the-solution-optimistic-accounting-vs.-locks">8.2 The Solution:
Optimistic Accounting vs. Locks</a></li>
<li><a href="#visualizing-the-await-gap"
id="toc-visualizing-the-await-gap">8.3 Visualizing the Await
Gap</a></li>
<li><a href="#guarding-with-pending-operations"
id="toc-guarding-with-pending-operations">8.4 Guarding with Pending
Operations</a></li>
<li><a href="#idempotent-external-calls"
id="toc-idempotent-external-calls">8.5 Idempotent External
Calls</a></li>
<li><a href="#testing-for-reentrancy-bugs"
id="toc-testing-for-reentrancy-bugs">8.6 Testing for Reentrancy
Bugs</a></li>
<li><a href="#chapter-9-external-integrations"
id="toc-chapter-9-external-integrations">Chapter 9: External
Integrations</a>
<ul>
<li><a href="#http-outcalls" id="toc-http-outcalls">9.1 HTTP
Outcalls</a></li>
<li><a href="#native-bitcoin-integration"
id="toc-native-bitcoin-integration">9.2 Native Bitcoin
Integration</a></li>
<li><a href="#ckbtc-the-practical-solution"
id="toc-ckbtc-the-practical-solution">9.3 ckBTC: The Practical
Solution</a></li>
<li><a href="#summary-1" id="toc-summary-1">9.4 Summary</a></li>
</ul></li>
<li><a href="#chapter-10-frontend-integration-asset-storage"
id="toc-chapter-10-frontend-integration-asset-storage">Chapter 10:
Frontend Integration &amp; Asset Storage</a>
<ul>
<li><a href="#the-asset-canister" id="toc-the-asset-canister">10.1 The
Asset Canister</a></li>
<li><a href="#connecting-frontend-to-backend"
id="toc-connecting-frontend-to-backend">10.2 Connecting Frontend to
Backend</a></li>
<li><a href="#certified-variables-and-security"
id="toc-certified-variables-and-security">10.3 Certified Variables and
Security</a></li>
<li><a href="#custom-domains" id="toc-custom-domains">10.4 Custom
Domains</a></li>
<li><a href="#summary-2" id="toc-summary-2">10.5 Summary</a></li>
</ul></li>
</ul></li>
<li><a href="#chapter-11-ecosystem-tools-and-testing"
id="toc-chapter-11-ecosystem-tools-and-testing">Chapter 11: Ecosystem
Tools and Testing</a>
<ul>
<li><a href="#dependency-management-with-mops"
id="toc-dependency-management-with-mops">9.1 Dependency Management with
Mops</a></li>
<li><a href="#testing-strategies" id="toc-testing-strategies">9.2
Testing Strategies</a></li>
<li><a href="#integration-testing-with-pocketic"
id="toc-integration-testing-with-pocketic">9.3 Integration Testing with
PocketIC</a></li>
<li><a href="#property-based-testing"
id="toc-property-based-testing">9.4 Property-Based Testing</a></li>
<li><a href="#debugging-techniques" id="toc-debugging-techniques">9.5
Debugging Techniques</a></li>
<li><a href="#continuous-integration"
id="toc-continuous-integration">9.6 Continuous Integration</a></li>
<li><a href="#best-practices-1" id="toc-best-practices-1">9.7 Best
Practices</a></li>
<li><a href="#performance-testing" id="toc-performance-testing">9.8
Performance Testing</a></li>
</ul></li>
<li><a href="#chapter-12-the-economics-of-deployment"
id="toc-chapter-12-the-economics-of-deployment">Chapter 12: The
Economics of Deployment</a>
<ul>
<li><a href="#understanding-cycles-the-fuel-of-the-internet-computer"
id="toc-understanding-cycles-the-fuel-of-the-internet-computer">10.1
Understanding Cycles: The Fuel of the Internet Computer</a></li>
<li><a href="#building-a-sustainable-economic-model"
id="toc-building-a-sustainable-economic-model">10.2 Building a
Sustainable Economic Model</a></li>
<li><a href="#deployment-process-and-best-practices"
id="toc-deployment-process-and-best-practices">10.3 Deployment Process
and Best Practices</a></li>
<li><a href="#the-black-hole-and-immutability"
id="toc-the-black-hole-and-immutability">10.4 The Black Hole and
Immutability</a></li>
<li><a href="#monitoring-and-maintenance"
id="toc-monitoring-and-maintenance">10.5 Monitoring and
Maintenance</a></li>
<li><a href="#cost-optimization-strategies"
id="toc-cost-optimization-strategies">10.6 Cost Optimization
Strategies</a></li>
<li><a href="#upgrade-strategies" id="toc-upgrade-strategies">10.7
Upgrade Strategies</a></li>
<li><a href="#case-study-openpatron-deployment-costs"
id="toc-case-study-openpatron-deployment-costs">10.8 Case Study:
OpenPatron Deployment Costs</a></li>
<li><a href="#summary-3" id="toc-summary-3">10.9 Summary</a></li>
</ul></li>
<li><a href="#chapter-13-the-service-nervous-system-sns"
id="toc-chapter-13-the-service-nervous-system-sns">Chapter 13: The
Service Nervous System (SNS)</a>
<ul>
<li><a href="#the-architecture-of-sns"
id="toc-the-architecture-of-sns">11.1 The Architecture of SNS</a></li>
<li><a href="#neurons-the-foundation-of-governance"
id="toc-neurons-the-foundation-of-governance">11.2 Neurons: The
Foundation of Governance</a></li>
<li><a href="#proposal-types-and-governance"
id="toc-proposal-types-and-governance">11.3 Proposal Types and
Governance</a></li>
<li><a href="#voting-mechanisms" id="toc-voting-mechanisms">11.4 Voting
Mechanisms</a></li>
<li><a href="#token-economics-and-distribution"
id="toc-token-economics-and-distribution">11.5 Token Economics and
Distribution</a></li>
<li><a href="#practical-implementation-sns-enabling-openpatron"
id="toc-practical-implementation-sns-enabling-openpatron">11.6 Practical
Implementation: SNS-Enabling OpenPatron</a></li>
<li><a href="#integrating-sns-governance-into-your-dapp"
id="toc-integrating-sns-governance-into-your-dapp">11.7 Integrating SNS
Governance into Your Dapp</a></li>
<li><a href="#benefits-and-trade-offs"
id="toc-benefits-and-trade-offs">11.8 Benefits and Trade-offs</a></li>
<li><a href="#best-practices-for-sns-launch"
id="toc-best-practices-for-sns-launch">11.9 Best Practices for SNS
Launch</a></li>
<li><a href="#case-study-openpatron-sns-journey"
id="toc-case-study-openpatron-sns-journey">11.10 Case Study: OpenPatron
SNS Journey</a></li>
<li><a href="#the-future-of-sns" id="toc-the-future-of-sns">11.11 The
Future of SNS</a></li>
<li><a href="#summary-4" id="toc-summary-4">11.12 Summary</a></li>
</ul></li>
<li><a href="#chapter-14-troubleshooting-and-best-practices"
id="toc-chapter-14-troubleshooting-and-best-practices">Chapter 14:
Troubleshooting and Best Practices</a>
<ul>
<li><a href="#common-compiler-errors"
id="toc-common-compiler-errors">12.1 Common Compiler Errors</a></li>
<li><a href="#debugging-techniques-1"
id="toc-debugging-techniques-1">12.2 Debugging Techniques</a></li>
<li><a href="#best-practices-2" id="toc-best-practices-2">12.3 Best
Practices</a></li>
<li><a href="#performance-optimization"
id="toc-performance-optimization">12.4 Performance Optimization</a></li>
<li><a href="#testing-strategies-1" id="toc-testing-strategies-1">12.5
Testing Strategies</a></li>
<li><a href="#common-pitfalls-and-solutions"
id="toc-common-pitfalls-and-solutions">12.6 Common Pitfalls and
Solutions</a></li>
<li><a href="#monitoring-and-maintenance-1"
id="toc-monitoring-and-maintenance-1">12.7 Monitoring and
Maintenance</a></li>
<li><a href="#summary-5" id="toc-summary-5">12.8 Summary</a></li>
</ul></li>
<li><a href="#resources" id="toc-resources">Resources</a>
<ul>
<li><a href="#official-documentation"
id="toc-official-documentation">Official Documentation</a>
<ul>
<li><a href="#motoko-language" id="toc-motoko-language">Motoko
Language</a></li>
<li><a href="#internet-computer-protocol"
id="toc-internet-computer-protocol">Internet Computer Protocol</a></li>
</ul></li>
<li><a href="#service-nervous-system-sns"
id="toc-service-nervous-system-sns">Service Nervous System
(SNS)</a></li>
<li><a href="#community-and-learning-resources"
id="toc-community-and-learning-resources">Community and Learning
Resources</a>
<ul>
<li><a href="#official-community-channels"
id="toc-official-community-channels">Official Community
Channels</a></li>
<li><a href="#learning-platforms" id="toc-learning-platforms">Learning
Platforms</a></li>
<li><a href="#example-projects" id="toc-example-projects">Example
Projects</a></li>
</ul></li>
<li><a href="#development-tools" id="toc-development-tools">Development
Tools</a>
<ul>
<li><a href="#ides-and-extensions" id="toc-ides-and-extensions">IDEs and
Extensions</a></li>
</ul></li>
<li><a href="#staying-updated" id="toc-staying-updated">Staying
Updated</a></li>
<li><a href="#contributing-to-this-resource-list"
id="toc-contributing-to-this-resource-list">Contributing to This
Resource List</a></li>
<li><a href="#about-this-book" id="toc-about-this-book">About This
Book</a>
<ul>
<li><a href="#technical-specifications"
id="toc-technical-specifications">Technical Specifications</a></li>
<li><a href="#contributing" id="toc-contributing">Contributing</a></li>
<li><a href="#license" id="toc-license">License</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="mastering-motoko">Mastering Motoko</h1>
<p><strong>The Definitive Guide to Decentralized Application Engineering
on the Internet Computer</strong></p>
<hr />
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><strong>Preface</strong></li>
<li><strong>Foreword</strong></li>
<li><strong>Chapter 1</strong>: Introduction to the Internet Computer
Protocol</li>
<li><strong>Chapter 2</strong>: Motoko Fundamentals</li>
<li><strong>Chapter 3</strong>: Type System and Safety</li>
<li><strong>Chapter 4</strong>: Motoko Memory Architecture</li>
<li><strong>Chapter 5</strong>: Identity and Access Control</li>
<li><strong>Chapter 6</strong>: Tokenomics and Ledger Integration</li>
<li><strong>Chapter 7</strong>: Autonomous Subscriptions via Timers</li>
<li><strong>Chapter 8</strong>: Asynchronous Safety and Reentrancy</li>
<li><strong>Chapter 9</strong>: External Integrations</li>
<li><strong>Chapter 11</strong>: Frontend Integration &amp; Asset
Storage</li>
<li><strong>Chapter 12</strong>: The Economics of Deployment</li>
<li><strong>Chapter 13</strong>: The Service Nervous System (SNS)</li>
<li><strong>Chapter 14</strong>: Troubleshooting and Best Practices</li>
<li><strong>Resources</strong>: Official Documentation and Links</li>
</ul>
<hr />
<hr />
<h1 id="preface">Preface</h1>
<p>The evolution of blockchain technology has progressed from simple
value transfer (Bitcoin) to programmable smart contracts (Ethereum), and
now to the third generation: the Internet Computer Protocol (ICP). This
platform represents a paradigm shift from fragmented architectures—where
smart contracts, storage, and frontend interfaces are decoupled—to a
unified “World Computer” model. In this environment, software exists as
autonomous “canisters,” computational units that bundle WebAssembly
(Wasm) bytecode with memory pages, capable of serving web assets
directly to users while performing complex backend logic.</p>
<p>This comprehensive report serves as the authoritative manual for
<strong>Motoko</strong>, the domain-specific language designed by
DFINITY to exploit the unique capabilities of the Internet Computer.
While the platform supports other languages such as Rust, Motoko is
purpose-built to abstract the complexities of the underlying actor-based
model and orthogonal persistence.</p>
<p>Structured as an exhaustive technical resource, this document guides
the reader from the theoretical underpinnings of the Actor Model to the
practical implementation of “OpenPatron,” a fully decentralized,
censorship-resistant membership platform. Through this case study, we
analyze advanced patterns in identity management, recurring payment
systems (tokenomics), asynchronous messaging safety, and the emerging
standard of Enhanced Orthogonal Persistence (EOP).</p>
<p>The Internet Computer is not just a blockchain; it is a cloud
replacement. And Motoko is its native language. The tools and patterns
detailed in this report provide the necessary foundation to build the
next generation of sovereign, unstoppable web applications.</p>
<hr />
<h1 id="foreword">Foreword</h1>
<p>For over a decade, blockchain developers have been constrained by an
uncomfortable truth: we weren’t really building “decentralized”
applications. We were building fragmented systems where the smart
contract lived on-chain, the frontend was hosted on AWS, and the data
sat in Firebase. We called this “Web3,” but in practice, we were simply
adding expensive append-only databases to Web2 architectures.</p>
<p>The promise was autonomy. The reality was dependency.</p>
<p>I’ve spent years navigating this landscape—writing Solidity contracts
that could barely store a kilobyte without triggering outrageous gas
fees, architecting systems where a single Amazon outage would render a
“decentralized” application completely inaccessible, and explaining to
users why their transaction failed because they didn’t pay enough for
computation. Each compromise felt necessary. Each workaround felt
clever. But collectively, they represented a fundamental betrayal of the
blockchain vision.</p>
<p>When I first encountered the Internet Computer Protocol, my initial
reaction was skepticism. Another “Ethereum killer”? Another promise of
infinite scalability? The industry had become saturated with ambitious
whitepapers that dissolved upon contact with reality.</p>
<p>Then I wrote my first Motoko program.</p>
<p>What you’re about to read is not a gentle introduction to “blockchain
development.” This book assumes you understand why decentralization
matters and are frustrated that current tools make it nearly impossible
to achieve. The author doesn’t waste time relitigating the merits of
smart contracts or explaining what a blockchain is. Instead, this text
operates at a higher level of discourse: <em>How do we build software
that is truly autonomous, truly persistent, and truly
sovereign?</em></p>
<p>The answer, it turns out, requires unlearning nearly everything we
know about backend development.</p>
<p>Motoko is deceptively familiar. Its syntax borrows from TypeScript,
Swift, and Rust. A JavaScript developer can read a basic Motoko function
and understand its intent within minutes. But beneath this familiar
surface lies a radically different computational model. There are no
databases because state <em>is</em> memory, and memory <em>is</em>
persistent. There are no cron jobs because canisters can schedule their
own execution. There are no load balancers because the protocol handles
replication and consensus automatically.</p>
<p>This is the paradigm shift that most developers miss. They approach
Motoko as “JavaScript for blockchain” and immediately encounter
friction. Why can’t I just read another actor’s variables? Why does
every function return a Promise? Why am I thinking about “cycles”
instead of dollars per month?</p>
<p>The answer to all these questions is the same: <em>You’re not writing
an application. You’re writing an autonomous agent that will execute in
a hostile, asynchronous, distributed environment where every assumption
about traditional computing is inverted.</em></p>
<p>This book teaches you to think like that agent.</p>
<p>The structure is deliberate. Part I establishes the theoretical
foundations—not as academic exercise, but as essential mental models.
You cannot write safe asynchronous code without understanding the Actor
Model. You cannot architect scalable systems without understanding
orthogonal persistence. These aren’t “nice to know” topics; they’re
load-bearing concepts that will determine whether your canister survives
in production or traps during its first upgrade.</p>
<p>Parts II and III form the technical core, systematically dissecting
Motoko’s type system, memory model, and persistence mechanisms. This
section alone is worth the price of admission. The author doesn’t just
explain <em>how</em> stable variables work; they explain <em>why</em>
the traditional approach fails at scale and how Enhanced Orthogonal
Persistence (EOP) resolves the upgrade problem that has bricked
countless canisters.</p>
<p>But theory without application is sterile. This is why Parts IV
through VI build “OpenPatron,” a production-grade decentralized
subscription platform. This case study is brilliant in its specificity.
Rather than building yet another token swap or NFT marketplace, the
author tackles one of the hardest problems in crypto: recurring
payments. This requires solving identity (Internet Identity
integration), tokenomics (ICRC-1 ledger interactions), asynchronous
safety (reentrancy protection), and autonomous execution (timer-based
subscription processing).</p>
<p>By the time you finish implementing OpenPatron, you won’t just
understand Motoko—you’ll understand distributed systems engineering.</p>
<p>I want to be clear about who this book is <em>not</em> for. If you’re
looking for a weekend tutorial that holds your hand through deploying a
“Hello World” dapp, this isn’t it. There are gentler introductions
available, and they serve an important purpose. This book assumes you’re
serious. It assumes you’re willing to read a paragraph three times to
fully grasp the implications of an await statement. It assumes you care
about the difference between a TrieMap and a StableBTreeMap because
you’re building something that needs to scale to millions of users.</p>
<p>This is a manual for professionals.</p>
<p>The Internet Computer is the first blockchain that actually delivers
on the original promise: software that runs forever, costs almost
nothing, and cannot be shut down. Motoko is the language designed from
first principles to exploit this environment. And this book is the
definitive guide to mastering both.</p>
<p>If you’re ready to build the infrastructure for a truly decentralized
future—not as a slogan, but as an engineering discipline—turn the
page.</p>
<p>The Actor Model awaits.</p>
<hr />
<h1
id="chapter-1-introduction-to-the-internet-computer-protocol">Chapter 1:
Introduction to the Internet Computer Protocol</h1>
<p>To master Motoko, one must first understand the hostile and
asynchronous environment in which it executes. The Internet Computer
does not function like a traditional server, nor does it mimic the
synchronous state transitions of the Ethereum Virtual Machine (EVM). It
operates as a distributed operating system hosting autonomous
agents.</p>
<h3 id="introduction-to-the-internet-computer-protocol-icp">1.0
Introduction to the Internet Computer Protocol (ICP)</h3>
<p>The Internet Computer Protocol (ICP), developed by the DFINITY
Foundation, represents the third generation of blockchain technology.
Unlike first-generation blockchains like Bitcoin (focused on value
transfer) or second-generation platforms like Ethereum (introducing
programmable smart contracts), ICP aims to create a “World Computer”—a
global, tamper-proof computational platform that can host full-stack
applications entirely on-chain.</p>
<p>At its core, ICP is a decentralized network of independent data
centers running specialized node machines. These nodes form “subnets,”
each functioning as a sovereign blockchain capable of processing smart
contracts at web speed. The protocol uses advanced cryptographic
techniques, including <strong>Chain-Key Cryptography</strong>, to enable
seamless communication between subnets and direct interaction with the
web. This allows ICP to scale horizontally by adding more subnets,
theoretically supporting billions of users without the performance
bottlenecks seen in monolithic blockchains like Ethereum.</p>
<p>ICP’s native token, also called ICP, serves multiple purposes:
governance (through the Network Nervous System), payment for
computational resources (via “cycles”), and staking for neuron-based
voting. However, unlike gas models in other chains, ICP employs a
“reverse gas model” where developers pre-pay for canister resources,
making user interactions feel free and instantaneous.</p>
<h4 id="a-new-paradigm-for-writing-applications">A New Paradigm for
Writing Applications</h4>
<p>Traditional web applications follow a client-server model: frontend
code runs in the browser, backend logic on centralized servers (e.g.,
AWS), and data in databases (e.g., PostgreSQL). This architecture is
efficient but vulnerable—servers can be hacked, censored, or shut down
by authorities or corporations.</p>
<p>Blockchain applications on platforms like Ethereum attempt to
decentralize the backend via smart contracts, but they remain
fragmented: contracts handle logic and state, but storage is expensive
(leading to off-chain solutions like IPFS), frontends are hosted
centrally, and scalability is limited by global consensus.</p>
<p>ICP introduces a paradigm shift by unifying the entire application
stack on-chain: - <strong>Canisters as Autonomous Units:</strong>
Applications are deployed as “canisters”—self-contained bundles of
WebAssembly code and persistent memory. A single canister can serve HTTP
requests, process backend logic, and store data, eliminating the need
for separate servers or databases. - <strong>Direct Web
Serving:</strong> Canisters can host and serve web assets (HTML, CSS,
JS) directly to browsers via certified HTTP responses, verified through
chain-key signatures. This makes dApps indistinguishable from Web2 apps
in speed and user experience. - <strong>Infinite Scalability:</strong>
Each canister runs on its own subnet, and subnets operate in parallel.
This “sharded” architecture allows ICP to scale by adding hardware, not
by optimizing a single chain. - <strong>Built-in Persistence:</strong>
State is automatically preserved across upgrades via orthogonal
persistence, abstracting away the complexities of data
serialization.</p>
<p>In essence, writing applications on ICP feels like developing for a
global, unstoppable cloud platform. Developers focus on business logic
rather than infrastructure, with the protocol handling replication,
security, and availability.</p>
<h4 id="why-icp-is-superior-for-decentralized-applications-dapps">Why
ICP is Superior for Decentralized Applications (dApps)</h4>
<p>ICP addresses the core limitations of previous blockchain platforms,
making it profoundly better for building dApps: - <strong>True
Decentralization:</strong> Unlike Ethereum dApps that rely on
centralized frontends (e.g., via Cloudflare) or off-chain storage, ICP
dApps run entirely on-chain. This provides censorship resistance—once
deployed, a canister cannot be taken down without consensus from the
entire network. - <strong>Performance and Cost Efficiency:</strong>
Transactions (messages) on ICP are processed in seconds with negligible
cost to users. Subnets enable parallel execution, avoiding the
“blockchain trilemma” where scalability sacrifices decentralization or
security. For context, ICP can handle over 250,000 queries per second
across its network, far surpassing Ethereum’s ~15 transactions per
second. - <strong>Developer-Friendly Economics:</strong> The reverse gas
model shifts costs to developers, who can subsidize users or implement
sustainable tokenomics. Cycles, burned for computation, create
deflationary pressure on ICP tokens, aligning incentives. -
<strong>Enhanced Security Features:</strong> Chain-key cryptography
enables unique capabilities like threshold signatures for secure
randomness and direct Bitcoin/Ethereum integration without oracles.
Canisters are replicated across geographically diverse nodes, mitigating
single points of failure. - <strong>Web3-Native Experiences:</strong>
dApps on ICP can use Internet Identity for seamless, privacy-preserving
authentication (no passwords or seed phrases needed). This lowers
barriers for mainstream adoption, as users interact with dApps like any
website.</p>
<p>Relevant Innovations: - <strong>Network Nervous System
(NNS):</strong> ICP’s on-chain governance DAO, where staked ICP holders
vote on proposals to upgrade the protocol or add subnets. -
<strong>Boundary Nodes:</strong> Act as gateways, handling HTTP traffic
and providing DDoS protection while preserving decentralization. -
<strong>Integration with Legacy Systems:</strong> ICP supports direct
calls to Bitcoin and Ethereum, enabling hybrid applications that
leverage multiple chains.</p>
<p>By mastering ICP’s model, developers can build dApps that are not
just “blockchain-enabled” but fundamentally reimagined as autonomous,
global services. This foundation sets the stage for understanding the
Actor Model and canisters, which are the building blocks of ICP
applications.</p>
<p>The fundamental unit of deployment on the Internet Computer is the
<strong>Canister Smart Contract</strong>. A canister is not merely a
script; it is a persistent process that encapsulates both its code
(Wasm) and its state (Memory). This architecture is heavily influenced
by the <strong>Actor Model</strong>, a conceptual model of concurrent
computation that originated in the 1970s but has found its ideal
implementation in the distributed nature of the ICP.</p>
<h3 id="the-necessity-of-the-actor-model">1.1 The Necessity of the Actor
Model</h3>
<p>In traditional software development, concurrency is often managed
through threads sharing the same memory space. This approach
necessitates complex locking mechanisms (mutexes, semaphores) to prevent
race conditions, where two processes attempt to modify the same data
simultaneously. In a distributed blockchain environment, shared memory
is impossible.</p>
<p>Motoko adopts the Actor Model to resolve this. An actor is a
self-contained unit of state and behavior.</p>
<ul>
<li><p><strong>Encapsulation:</strong> The state of an actor (variables,
data structures) is strictly private. No external entity—neither a user
nor another canister—can read or write to this state directly.</p></li>
<li><p><strong>Message Passing:</strong> Communication occurs solely
through asynchronous message passing. To request an action or data, an
external entity sends a message (a function call) to the actor.</p></li>
<li><p><strong>Sequential Processing:</strong> The actor processes its
mailbox of messages sequentially, one at a time. This guarantees that
within the execution of a single message, the developer has exclusive
access to the state, eliminating the need for locks.</p></li>
</ul>
<h3 id="the-canister-environment">1.2 The Canister Environment</h3>
<p>Every Motoko program compiles into a WebAssembly module that runs
inside a canister. The Internet Computer Protocol ensures that this
execution is deterministic and replicated across multiple nodes in a
subnet.</p>
<p><strong>Table 1: Comparison of Execution Models</strong></p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 29%" />
<col style="width: 29%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr>
<th>Feature</th>
<th>Traditional Server (AWS)</th>
<th>Ethereum Smart Contract</th>
<th>Internet Computer Canister</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>State Storage</strong></td>
<td>External Database (SQL/NoSQL)</td>
<td>Merkle Patricia Trie (expensive)</td>
<td>Orthogonal Persistence (Memory Pages)</td>
</tr>
<tr>
<td><strong>Concurrency</strong></td>
<td>Multi-threaded (Complex)</td>
<td>Serial/Atomic (Global Lock)</td>
<td>Actor Model (Async Inter-canister)</td>
</tr>
<tr>
<td><strong>Cost Model</strong></td>
<td>Monthly Server Rental</td>
<td>User pays Gas per Transaction</td>
<td>Developer pays “Cycles” (Reverse Gas)</td>
</tr>
<tr>
<td><strong>Frontend</strong></td>
<td>Hosted separately (S3/Nginx)</td>
<td>Hosted separately (IPFS/Centralized)</td>
<td>Served directly from Canister</td>
</tr>
</tbody>
</table>
<h3 id="the-development-lifecycle">1.3 The Development Lifecycle</h3>
<p>The development workflow relies on the DFINITY Canister SDK,
specifically the <code>dfx</code> command-line interface. This toolchain
manages the entire lifecycle of a canister, from creation to compilation
and deployment.</p>
<p>When initializing a new project (<code>dfx new open_patron</code>),
the <code>dfx.json</code> configuration file becomes the central nervous
system of the application. It defines the network topology, the distinct
canisters (backend logic vs. frontend assets), and their
dependencies.</p>
<p><strong>The Local Replica:</strong></p>
<p>Developing directly on the mainnet is costly and slow. The
<code>dfx start --clean --background</code> command launches a local
replica—a full simulation of the Internet Computer blockchain running on
the developer’s machine. This environment mocks the subnet consensus,
generates local canister IDs, and provides a local ledger for testing
token integration.</p>
<h3 id="setting-up-your-local-development-environment">1.4 Setting Up
Your Local Development Environment</h3>
<p>To write and deploy Motoko programs, you must establish a development
environment on your local machine. This section provides step-by-step
instructions for installing and configuring the necessary tools.</p>
<h4 id="system-requirements">1.4.1 System Requirements</h4>
<p>Before installation, ensure your system meets the following minimum
requirements:</p>
<p><strong>Operating System:</strong> - macOS 12.* Monterey or later -
Ubuntu 20.04 LTS or later - Windows 10/11 with Windows Subsystem for
Linux 2 (WSL2)</p>
<p><strong>Hardware:</strong> - Minimum 4GB RAM (8GB recommended for
running local replica) - 10GB available disk space - x86-64 processor
(Apple Silicon/M1/M2 supported via Rosetta 2)</p>
<p><strong>Network:</strong> - Stable internet connection for
downloading dependencies and deploying to mainnet</p>
<h4 id="installing-the-dfinity-canister-sdk-dfx">1.4.2 Installing the
DFINITY Canister SDK (dfx)</h4>
<p>The <code>dfx</code> command-line tool is the cornerstone of Motoko
development. It manages project scaffolding, local replicas, canister
compilation, and deployment.</p>
<p><strong>For macOS and Linux:</strong></p>
<p>Open a terminal and execute the following command:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sh</span> <span class="at">-ci</span> <span class="st">&quot;</span><span class="va">$(</span><span class="ex">curl</span> <span class="at">-fsSL</span> https://internetcomputer.org/install.sh<span class="va">)</span><span class="st">&quot;</span></span></code></pre></div>
<p>This script will: 1. Download the latest stable version of
<code>dfx</code> 2. Install it to
<code>~/.local/share/dfinity/bin/</code> 3. Add the binary to your
PATH</p>
<p><strong>Verifying the Installation:</strong></p>
<p>After installation completes, verify the version:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> <span class="at">--version</span></span></code></pre></div>
<p>You should see output similar to:</p>
<pre><code>dfx 0.16.1</code></pre>
<p><strong>For Windows (WSL2):</strong></p>
<ol type="1">
<li>First, install WSL2 if not already present. Open PowerShell as
Administrator:</li>
</ol>
<div class="sourceCode" id="cb4"><pre
class="sourceCode powershell"><code class="sourceCode powershell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>wsl <span class="op">--</span>install</span></code></pre></div>
<ol start="2" type="1">
<li>Restart your computer and set up Ubuntu from the Microsoft
Store</li>
<li>Launch Ubuntu and run the same installation script as Linux:</li>
</ol>
<div class="sourceCode" id="cb5"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sh</span> <span class="at">-ci</span> <span class="st">&quot;</span><span class="va">$(</span><span class="ex">curl</span> <span class="at">-fsSL</span> https://internetcomputer.org/install.sh<span class="va">)</span><span class="st">&quot;</span></span></code></pre></div>
<p><strong>Installing a Specific Version:</strong></p>
<p>If you need a particular version of <code>dfx</code> for
compatibility:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="va">DFX_VERSION</span><span class="op">=</span>0.16.1 <span class="fu">sh</span> <span class="at">-ci</span> <span class="st">&quot;</span><span class="va">$(</span><span class="ex">curl</span> <span class="at">-fsSL</span> https://internetcomputer.org/install.sh<span class="va">)</span><span class="st">&quot;</span></span></code></pre></div>
<p><strong>Updating dfx:</strong></p>
<p>To update to the latest version:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> upgrade</span></code></pre></div>
<h4 id="installing-node.js-and-npm-optional-but-recommended">1.4.3
Installing Node.js and npm (Optional but Recommended)</h4>
<p>While Motoko backend development doesn’t require Node.js, most
projects include a JavaScript/TypeScript frontend. Additionally, some
tooling and asset management depends on npm.</p>
<p><strong>Using Node Version Manager (nvm) - Recommended:</strong></p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Install nvm</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="ex">curl</span> <span class="at">-o-</span> https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.5/install.sh <span class="kw">|</span> <span class="fu">bash</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Reload shell configuration</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="bu">source</span> ~/.bashrc  <span class="co"># or ~/.zshrc for zsh</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Install Node.js LTS</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="ex">nvm</span> install <span class="at">--lts</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="ex">nvm</span> use <span class="at">--lts</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Verify installation</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="ex">node</span> <span class="at">--version</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="ex">npm</span> <span class="at">--version</span></span></code></pre></div>
<p><strong>Alternative: Direct Installation</strong></p>
<p>Visit <a href="https://nodejs.org/">nodejs.org</a> and download the
LTS version for your platform.</p>
<h4 id="creating-your-first-motoko-project">1.4.4 Creating Your First
Motoko Project</h4>
<p>With <code>dfx</code> installed, you can scaffold a new project:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a new project named &quot;hello_world&quot;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> new hello_world</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Navigate into the project directory</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> hello_world</span></code></pre></div>
<p>During project creation, <code>dfx</code> will prompt you to select a
frontend framework. For pure Motoko learning, choose “No JS template” or
“SvelteKit” for a more complete setup.</p>
<p><strong>Project Structure:</strong></p>
<pre><code>hello_world/
├── dfx.json              # Project configuration
├── src/
│   ├── hello_world_backend/
│   │   └── main.mo       # Motoko backend code
│   └── hello_world_frontend/
│       ├── assets/       # Static assets (HTML, CSS, images)
│       └── src/          # Frontend JavaScript/TypeScript
├── .dfx/                 # Build artifacts (gitignored)
└── canister_ids.json     # Canister identifiers (after deployment)</code></pre>
<p><strong>Understanding dfx.json:</strong></p>
<p>The <code>dfx.json</code> file is the manifest for your project.
Here’s an annotated example:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;canisters&quot;</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;hello_world_backend&quot;</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;main&quot;</span><span class="fu">:</span> <span class="st">&quot;src/hello_world_backend/main.mo&quot;</span><span class="fu">,</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;type&quot;</span><span class="fu">:</span> <span class="st">&quot;motoko&quot;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">},</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;hello_world_frontend&quot;</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;dependencies&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;hello_world_backend&quot;</span><span class="ot">]</span><span class="fu">,</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;source&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;src/hello_world_frontend/assets&quot;</span><span class="ot">]</span><span class="fu">,</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;type&quot;</span><span class="fu">:</span> <span class="st">&quot;assets&quot;</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">}</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">},</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;defaults&quot;</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;build&quot;</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;packtool&quot;</span><span class="fu">:</span> <span class="st">&quot;&quot;</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    <span class="fu">}</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">},</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;version&quot;</span><span class="fu">:</span> <span class="dv">1</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div>
<ul>
<li><strong>canisters:</strong> Defines each canister in your
project</li>
<li><strong>main:</strong> Entry point for the Motoko code</li>
<li><strong>type:</strong> “motoko” for backend, “assets” for static
frontend</li>
<li><strong>dependencies:</strong> Declares inter-canister
dependencies</li>
<li><strong>version:</strong> Schema version for
<code>dfx.json</code></li>
</ul>
<h4 id="starting-the-local-replica">1.4.5 Starting the Local
Replica</h4>
<p>Before deploying canisters, you must start a local Internet Computer
replica:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> start <span class="at">--background</span></span></code></pre></div>
<p><strong>Flags:</strong> - <code>--background</code>: Runs the replica
in the background, freeing your terminal - <code>--clean</code>: Wipes
all state (useful for fresh starts)</p>
<p><strong>What Happens:</strong></p>
<p>The local replica simulates a subnet on your machine, running on
<code>http://127.0.0.1:4943</code> (replica) and
<code>http://127.0.0.1:4943/?canisterId=&lt;id&gt;</code> for frontend
access.</p>
<p><strong>Checking Status:</strong></p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> ping</span></code></pre></div>
<p>Expected output:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;certified_height&quot;</span><span class="fu">:</span> <span class="dv">1234</span><span class="fu">,</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;healthy&quot;</span><span class="fu">:</span> <span class="kw">true</span><span class="fu">,</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;replica_health_status&quot;</span><span class="fu">:</span> <span class="st">&quot;healthy&quot;</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div>
<p><strong>Stopping the Replica:</strong></p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> stop</span></code></pre></div>
<h4 id="deploying-your-first-canister">1.4.6 Deploying Your First
Canister</h4>
<p>With the replica running, deploy your canisters:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> deploy</span></code></pre></div>
<p>This command: 1. Compiles <code>main.mo</code> to WebAssembly 2.
Generates canister IDs 3. Installs the Wasm module on the local replica
4. Deploys frontend assets</p>
<p><strong>Output Example:</strong></p>
<pre><code>Deploying all canisters.
Creating canisters...
Creating canister hello_world_backend...
hello_world_backend canister created with canister id: rrkah-fqaaa-aaaaa-aaaaq-cai
Creating canister hello_world_frontend...
hello_world_frontend canister created with canister id: ryjl3-tyaaa-aaaaa-aaaba-cai
Installing canisters...
Installing code for canister hello_world_backend...
Installing code for canister hello_world_frontend...</code></pre>
<p><strong>Interacting with Your Canister:</strong></p>
<p>If your <code>main.mo</code> contains a public function like:</p>
<pre class="motoko"><code>actor {
  public func greet(name : Text) : async Text {
    return &quot;Hello, &quot; # name # &quot;!&quot;;
  };
};</code></pre>
<p>You can call it from the command line:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> canister call hello_world_backend greet <span class="st">&#39;(&quot;World&quot;)&#39;</span></span></code></pre></div>
<p>Output:</p>
<pre><code>(&quot;Hello, World!&quot;)</code></pre>
<h4 id="essential-dfx-commands">1.4.7 Essential dfx Commands</h4>
<p>Master these commands for efficient development:</p>
<table>
<colgroup>
<col style="width: 40%" />
<col style="width: 59%" />
</colgroup>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dfx new &lt;name&gt;</code></td>
<td>Create a new project</td>
</tr>
<tr>
<td><code>dfx start [--background] [--clean]</code></td>
<td>Start local replica</td>
</tr>
<tr>
<td><code>dfx stop</code></td>
<td>Stop local replica</td>
</tr>
<tr>
<td><code>dfx deploy [canister]</code></td>
<td>Deploy all canisters (or specific one)</td>
</tr>
<tr>
<td><code>dfx build</code></td>
<td>Compile canisters without deploying</td>
</tr>
<tr>
<td><code>dfx canister call &lt;canister&gt; &lt;method&gt; &lt;args&gt;</code></td>
<td>Invoke canister function</td>
</tr>
<tr>
<td><code>dfx canister status &lt;canister&gt;</code></td>
<td>Check canister memory/cycles</td>
</tr>
<tr>
<td><code>dfx canister delete &lt;canister&gt;</code></td>
<td>Remove canister from replica</td>
</tr>
<tr>
<td><code>dfx identity list</code></td>
<td>View available identities</td>
</tr>
<tr>
<td><code>dfx identity use &lt;name&gt;</code></td>
<td>Switch active identity</td>
</tr>
<tr>
<td><code>dfx ledger account-id</code></td>
<td>Show your account identifier</td>
</tr>
</tbody>
</table>
<p><strong>Example Workflow:</strong></p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Start fresh</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> start <span class="at">--clean</span> <span class="at">--background</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Make changes to main.mo</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="co"># ...edit code...</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Rebuild and redeploy</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> deploy</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Test changes</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> canister call hello_world_backend greet <span class="st">&#39;(&quot;Motoko&quot;)&#39;</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Stop when done</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> stop</span></code></pre></div>
<h4 id="configuring-your-code-editor">1.4.8 Configuring Your Code
Editor</h4>
<p>For optimal Motoko development, configure your editor with proper
syntax highlighting and language server support.</p>
<p><strong>Visual Studio Code (Recommended):</strong></p>
<ol type="1">
<li>Install VS Code from <a
href="https://code.visualstudio.com/">code.visualstudio.com</a></li>
<li>Install the Motoko extension:
<ul>
<li>Open Extensions (Cmd+Shift+X / Ctrl+Shift+X)</li>
<li>Search for “Motoko”</li>
<li>Install the official extension by DFINITY Foundation</li>
</ul></li>
</ol>
<p><strong>Features:</strong> - Syntax highlighting - Code completion -
Inline error checking - Go to definition - Code formatting</p>
<p><strong>Vim/Neovim:</strong></p>
<p>Install the Motoko syntax plugin:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># For vim-plug</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="ex">Plug</span> <span class="st">&#39;dfinity/motoko.vim&#39;</span></span></code></pre></div>
<p><strong>IntelliJ IDEA:</strong></p>
<p>Currently no official plugin, but you can configure: 1. Settings →
Editor → File Types 2. Add new file type pattern: <code>*.mo</code> 3.
Associate with JavaScript for basic highlighting</p>
<p><strong>Configuring Language Server Protocol (LSP):</strong></p>
<p>For advanced IDE features, the Motoko language server provides: -
Type inference hints - Refactoring support - Jump to definition across
canisters</p>
<p>The language server is included with <code>dfx</code> and
automatically used by supported editors.</p>
<h4 id="understanding-identities-and-wallets">1.4.9 Understanding
Identities and Wallets</h4>
<p><code>dfx</code> manages cryptographic identities for authentication.
Each identity has: - A <strong>Principal ID</strong>: Your unique
identifier on ICP (like an address) - A <strong>Private Key</strong>:
Stored securely in <code>~/.config/dfx/identity/</code></p>
<p><strong>Viewing Your Default Identity:</strong></p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> identity whoami</span></code></pre></div>
<p>Output: <code>default</code></p>
<p><strong>Getting Your Principal:</strong></p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> identity get-principal</span></code></pre></div>
<p>Output (example):</p>
<pre><code>tsqwz-udeik-5migd-ehrev-pvoqv-szx2g-akh5s-fkyqc-zy6q7-qpqai-eqe</code></pre>
<p><strong>Creating New Identities:</strong></p>
<p>For testing multi-user scenarios:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create new identity</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> identity new alice</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> identity new bob</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Switch to alice</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> identity use alice</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Deploy as alice</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> deploy</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Switch back to default</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> identity use default</span></code></pre></div>
<p><strong>Cycles Wallet:</strong></p>
<p>On the mainnet, you’ll need cycles to power canisters. Create a
cycles wallet:</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> identity <span class="at">--network</span> ic get-wallet</span></code></pre></div>
<p>(This requires ICP tokens to be converted to cycles via the NNS.)</p>
<h4 id="troubleshooting-common-issues">1.4.10 Troubleshooting Common
Issues</h4>
<p><strong>Issue: “dfx: command not found”</strong></p>
<p>Solution: Add dfx to your PATH:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">&#39;export PATH=&quot;$PATH:$HOME/.local/share/dfinity/bin&quot;&#39;</span> <span class="op">&gt;&gt;</span> ~/.bashrc</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="bu">source</span> ~/.bashrc</span></code></pre></div>
<p><strong>Issue: “Replica failed to start”</strong></p>
<p>Solutions: - Ensure port 4943 is not in use:
<code>lsof -ti:4943</code> - Kill conflicting processes:
<code>dfx stop &amp;&amp; dfx start --clean</code> - Check for firewall
restrictions</p>
<p><strong>Issue: “Cannot connect to replica”</strong></p>
<p>Solution: Verify replica is running:</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> ping</span></code></pre></div>
<p>If it fails, restart:</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> start <span class="at">--background</span></span></code></pre></div>
<p><strong>Issue: “Canister method not found”</strong></p>
<p>Cause: Code changes not deployed.</p>
<p>Solution:</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> deploy <span class="at">--mode</span> reinstall</span></code></pre></div>
<p><strong>Issue: Memory errors when deploying</strong></p>
<p>Cause: Insufficient cycles or memory quota.</p>
<p>Solution: For local development, restart with clean state:</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> start <span class="at">--clean</span> <span class="at">--background</span></span></code></pre></div>
<h4 id="next-steps">1.4.11 Next Steps</h4>
<p>With your environment configured, you’re ready to dive into Motoko
programming:</p>
<ol type="1">
<li>Experiment with the default <code>main.mo</code> template</li>
<li>Read the generated canister interface in
<code>.dfx/local/canisters/</code></li>
<li>Explore the Candid UI at
<code>http://127.0.0.1:4943/?canisterId=&lt;candid_ui_id&gt;</code></li>
<li>Modify functions and observe how type signatures affect
deployment</li>
</ol>
<p>The subsequent chapters will dissect Motoko’s type system,
asynchronous patterns, and advanced canister architectures. The
foundational knowledge of the Actor Model and the operational mechanics
of <code>dfx</code> are essential prerequisites for mastering these
concepts.</p>
<hr />
<hr />
<h1 id="chapter-2-motoko-fundamentals">Chapter 2: Motoko
Fundamentals</h1>
<p>Motoko is a strongly typed, functional-first programming language
specifically designed for the Internet Computer. Its syntax draws
inspiration from JavaScript, Swift, and Rust, but its semantics are
meticulously crafted to leverage the unique capabilities and constraints
of the Internet Computer Protocol (ICP). This chapter provides a
comprehensive introduction to Motoko’s fundamental concepts, syntax, and
programming patterns.</p>
<p>Before building sophisticated decentralized applications, you must
master Motoko’s core building blocks. This chapter walks through the
essential language features that form the foundation of all Motoko
programs: from basic syntax and type systems to advanced concepts like
actors, asynchronous programming, and orthogonal persistence.</p>
<h2 id="hello-world">2.1 Hello, World!</h2>
<p>Every programming journey begins with a simple “Hello, World!”
program. In Motoko, this introduces you to the actor model and basic
output.</p>
<pre class="motoko"><code>actor {
    public func greet(name : Text) : async Text {
        return &quot;Hello, &quot; # name # &quot;!&quot;;
    };
};</code></pre>
<p>This minimal program demonstrates several key concepts: -
<strong>Actor</strong>: The fundamental unit of computation on the
Internet Computer - <strong>Public function</strong>: Exposed as a
canister endpoint - <strong>Async</strong>: All public functions must
return async values - <strong>Text concatenation</strong>: Using the
<code>#</code> operator</p>
<h2 id="basic-syntax">2.2 Basic Syntax</h2>
<p>Motoko’s syntax is designed to be familiar yet precise. Understanding
these foundational elements is crucial for writing correct and efficient
code.</p>
<h3 id="comments">2.2.1 Comments</h3>
<p>Motoko supports both single-line and multi-line comments:</p>
<pre class="motoko"><code>// This is a single-line comment

/* This is a 
   multi-line comment */

/// Documentation comment for functions
public func example() : async () {};</code></pre>
<h3 id="expressions-and-blocks">2.2.2 Expressions and Blocks</h3>
<p>Motoko is an <strong>expression-oriented language</strong>—nearly
everything evaluates to a value. Code blocks return the value of their
last expression.</p>
<pre class="motoko"><code>let result = {
    let x = 10;
    let y = 20;
    x + y  // Returns 30 (no semicolon!)
};

let noValue = {
    let x = 10;
    let y = 20;
    x + y;  // Returns () because of semicolon
};</code></pre>
<p><strong>The Semicolon Rule</strong>: The semicolon <code>;</code> is
a separator, not a terminator. If the last expression in a block ends
with a semicolon, the block returns <code>()</code> (Unit type, similar
to void).</p>
<h3 id="identifiers-and-naming">2.2.3 Identifiers and Naming</h3>
<ul>
<li><strong>Variables and functions</strong>: Use camelCase
(<code>myVariable</code>, <code>calculateTotal</code>)</li>
<li><strong>Types and modules</strong>: Use PascalCase
(<code>UserAccount</code>, <code>HashMapModule</code>)</li>
<li><strong>Constants</strong>: Can use UPPER_CASE by convention</li>
<li><strong>Reserved keywords</strong>: <code>actor</code>,
<code>async</code>, <code>await</code>, <code>break</code>,
<code>case</code>, <code>catch</code>, <code>class</code>,
<code>continue</code>, <code>debug</code>, <code>else</code>,
<code>false</code>, <code>for</code>, <code>func</code>,
<code>if</code>, <code>in</code>, <code>import</code>, <code>let</code>,
<code>loop</code>, <code>module</code>, <code>null</code>,
<code>object</code>, <code>public</code>, <code>private</code>,
<code>return</code>, <code>shared</code>, <code>switch</code>,
<code>true</code>, <code>try</code>, <code>type</code>,
<code>var</code>, <code>while</code></li>
</ul>
<pre class="motoko"><code>let userName = &quot;Alice&quot;;        // Valid
let user_name = &quot;Bob&quot;;         // Valid
let MAX_RETRIES = 3;           // Valid
// let 123abc = &quot;Invalid&quot;;     // Invalid: cannot start with digit</code></pre>
<h2 id="types">2.3 Types</h2>
<p>Motoko’s type system is its greatest strength, providing compile-time
guarantees that prevent entire categories of bugs. The language is
<strong>strongly typed</strong> and uses <strong>type inference</strong>
to reduce verbosity while maintaining safety.</p>
<h3 id="primitive-types">2.3.1 Primitive Types</h3>
<h4 id="numeric-types">Numeric Types</h4>
<pre class="motoko"><code>// Natural numbers (non-negative, unbounded)
let count : Nat = 42;
let large : Nat = 1_000_000_000;

// Integers (signed, unbounded)
let temperature : Int = -15;
let delta : Int = +100;

// Fixed-width unsigned integers
let byte : Nat8 = 255;          // 0 to 255
let port : Nat16 = 8080;        // 0 to 65,535
let id : Nat32 = 4_294_967_295; // 0 to 2^32-1
let bigId : Nat64 = 18_446_744_073_709_551_615;

// Fixed-width signed integers
let smallInt : Int8 = -128;     // -128 to 127
let medInt : Int16 = -32_768;   // -32,768 to 32,767
let normalInt : Int32 = -2_147_483_648;
let bigInt : Int64 = -9_223_372_036_854_775_808;

// Floating-point (64-bit IEEE 754)
let pi : Float = 3.14159;
let scientific : Float = 1.23e-4;</code></pre>
<p><strong>Key Points</strong>: - <code>Nat</code> and <code>Int</code>
are <strong>unbounded</strong> (arbitrary precision) - Use fixed-width
types (<code>Nat32</code>, <code>Int64</code>) for performance-critical
code - Overflow behavior: unbounded types never overflow; fixed-width
types trap</p>
<h4 id="boolean-type">Boolean Type</h4>
<pre class="motoko"><code>let isActive : Bool = true;
let hasPermission : Bool = false;

let result = isActive and hasPermission;  // false
let canProceed = isActive or hasPermission;  // true
let inverted = not isActive;  // false</code></pre>
<h4 id="text-and-character-types">Text and Character Types</h4>
<pre class="motoko"><code>// Text (UTF-8 strings)
let greeting : Text = &quot;Hello, Motoko!&quot;;
let emoji : Text = &quot;🚀&quot;;
let multiline : Text = &quot;Line 1\nLine 2\nLine 3&quot;;

// Character (single Unicode scalar value)
let letter : Char = &#39;M&#39;;
let unicode : Char = &#39;∑&#39;;

// Text concatenation
let fullName = &quot;Alice&quot; # &quot; &quot; # &quot;Smith&quot;;  // &quot;Alice Smith&quot;</code></pre>
<h4 id="special-types">Special Types</h4>
<pre class="motoko"><code>// Blob (immutable byte arrays)
let data : Blob = &quot;\00\01\02\03&quot;;
let empty : Blob = &quot;&quot;;

// Principal (unique identifiers for users and canisters)
let user : Principal = Principal.fromText(&quot;aaaaa-aa&quot;);
let canisterId : Principal = Principal.fromActor(myActor);

// Unit type (like void)
let nothing : () = ();</code></pre>
<h3 id="composite-types">2.3.2 Composite Types</h3>
<h4 id="arrays">Arrays</h4>
<p>Arrays in Motoko are <strong>immutable by default</strong> and have
fixed size.</p>
<pre class="motoko"><code>// Immutable array
let numbers : [Nat] = [1, 2, 3, 4, 5];
let names : [Text] = [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;];
let empty : [Int] = [];

// Array access
let first = numbers[0];  // 1
let last = numbers[numbers.size() - 1];  // 5

// Mutable array (requires explicit initialization)
let mutable : [var Nat] = [var 1, 2, 3];
mutable[0] := 10;  // Now [10, 2, 3]

// Array initialization
let zeros = Array.init&lt;Nat&gt;(100, 0);  // 100 zeros
let indices = Array.tabulate&lt;Nat&gt;(10, func(i) = i);  // [0,1,2,...,9]</code></pre>
<h4 id="tuples">Tuples</h4>
<p>Tuples are anonymous records with positional fields.</p>
<pre class="motoko"><code>// Simple tuple
let coordinates : (Float, Float) = (10.5, 20.3);
let person : (Text, Nat) = (&quot;Alice&quot;, 30);

// Accessing tuple elements
let x = coordinates.0;  // 10.5
let y = coordinates.1;  // 20.3

// Pattern matching with tuples
let (name, age) = person;

// Nested tuples
let complex : (Nat, (Text, Bool)) = (42, (&quot;active&quot;, true));</code></pre>
<h4 id="records">Records</h4>
<p>Records are structured types with named fields.</p>
<pre class="motoko"><code>// Type definition
type User = {
    name : Text;
    age : Nat;
    email : Text;
};

// Creating records
let alice : User = {
    name = &quot;Alice&quot;;
    age = 30;
    email = &quot;alice@example.com&quot;;
};

// Accessing fields
let userName = alice.name;
let userAge = alice.age;

// Record with mutable fields
type Counter = {
    var count : Nat;
    name : Text;
};

let myCounter : Counter = {
    var count = 0;
    name = &quot;Main Counter&quot;;
};

myCounter.count := myCounter.count + 1;</code></pre>
<h4 id="variants">Variants</h4>
<p>Variants are tagged unions (sum types), similar to enums in other
languages but more powerful.</p>
<pre class="motoko"><code>// Simple variant (enum-like)
type Color = {
    #Red;
    #Green;
    #Blue;
};

let favorite : Color = #Blue;

// Variant with associated data
type Result&lt;T, E&gt; = {
    #Ok : T;
    #Err : E;
};

let success : Result&lt;Nat, Text&gt; = #Ok(42);
let failure : Result&lt;Nat, Text&gt; = #Err(&quot;Division by zero&quot;);

// Complex variant
type PaymentMethod = {
    #Cash;
    #CreditCard : { number : Text; cvv : Nat };
    #Crypto : { wallet : Principal; amount : Nat };
};

let payment = #CreditCard({
    number = &quot;1234-5678-9012-3456&quot;;
    cvv = 123;
});</code></pre>
<h4 id="options">Options</h4>
<p>The <code>Option</code> type represents values that may or may not
exist, eliminating null pointer errors.</p>
<pre class="motoko"><code>// Option type
type OptionalNat = ?Nat;

let hasValue : ?Nat = ?42;
let noValue : ?Nat = null;

// Checking for values
switch (hasValue) {
    case null { Debug.print(&quot;No value&quot;); };
    case (?value) { Debug.print(&quot;Value: &quot; # Nat.toText(value)); };
};

// Option in records
type User = {
    name : Text;
    email : ?Text;  // Optional email
};

let bob = { name = &quot;Bob&quot;; email = null };
let alice = { name = &quot;Alice&quot;; email = ?&quot;alice@example.com&quot; };</code></pre>
<h3 id="function-types">2.3.3 Function Types</h3>
<p>Functions are first-class values with explicit types.</p>
<pre class="motoko"><code>// Function type signature
type MathOperation = (Nat, Nat) -&gt; Nat;

// Function implementation
let add : MathOperation = func(a, b) { a + b };
let multiply : MathOperation = func(a, b) { a * b };

// Higher-order functions
func applyOperation(op : MathOperation, x : Nat, y : Nat) : Nat {
    op(x, y);
};

let result = applyOperation(add, 5, 3);  // 8

// Generic function types
type Transformer&lt;A, B&gt; = A -&gt; B;

let toString : Transformer&lt;Nat, Text&gt; = Nat.toText;</code></pre>
<h3 id="async-types">2.3.4 Async Types</h3>
<p>Async types represent values that will be available in the future,
essential for inter-canister calls.</p>
<pre class="motoko"><code>// Async function
public func fetchData() : async Nat {
    // Simulated async operation
    return 42;
};

// Calling async functions
public func processData() : async Text {
    let data = await fetchData();
    return &quot;Received: &quot; # Nat.toText(data);
};</code></pre>
<h3 id="generic-types">2.3.5 Generic Types</h3>
<p>Generics enable code reuse while maintaining type safety.</p>
<pre class="motoko"><code>// Generic function
func identity&lt;T&gt;(x : T) : T {
    x;
};

let num = identity&lt;Nat&gt;(42);
let text = identity&lt;Text&gt;(&quot;hello&quot;);

// Generic type
type Container&lt;T&gt; = {
    value : T;
    isEmpty : Bool;
};

let numContainer : Container&lt;Nat&gt; = {
    value = 42;
    isEmpty = false;
};

// Generic with constraints
func compare&lt;T&gt;(a : T, b : T, eq : (T, T) -&gt; Bool) : Bool {
    eq(a, b);
};</code></pre>
<h2 id="declarations">2.4 Declarations</h2>
<p>Declarations introduce new names into scope. Motoko distinguishes
between immutable and mutable bindings.</p>
<h3 id="immutable-declarations-let">2.4.1 Immutable Declarations
(<code>let</code>)</h3>
<p>The default and recommended way to declare values.</p>
<pre class="motoko"><code>let name = &quot;Alice&quot;;
let age = 30;
let isActive = true;

// Type inference
let inferred = 42;  // Type: Nat

// Explicit type annotation
let explicit : Int = -42;

// Multiple bindings (pattern matching)
let (x, y) = (10, 20);
let {name = userName; age = userAge} = {name = &quot;Bob&quot;; age = 25};</code></pre>
<h3 id="mutable-declarations-var">2.4.2 Mutable Declarations
(<code>var</code>)</h3>
<p>Use <code>var</code> for values that need to change. Mutation uses
the <code>:=</code> operator.</p>
<pre class="motoko"><code>var counter = 0;
counter := counter + 1;  // 1
counter := counter * 2;  // 2

// Compound assignment
var total = 100;
total += 50;   // 150
total -= 30;   // 120
total *= 2;    // 240
total /= 4;    // 60

// Mutable in data structures
type Account = {
    var balance : Nat;
    owner : Text;
};

let account = {
    var balance = 1000;
    owner = &quot;Alice&quot;;
};

account.balance := account.balance - 100;</code></pre>
<h3 id="function-declarations">2.4.3 Function Declarations</h3>
<p>Functions can be declared in multiple ways.</p>
<pre class="motoko"><code>// Named function (private by default)
func add(a : Nat, b : Nat) : Nat {
    a + b;
};

// Public function (within actor)
public func publicAdd(a : Nat, b : Nat) : async Nat {
    async (a + b);
};

// Shared function (accessible from other canisters)
public shared func sharedAdd(a : Nat, b : Nat) : async Nat {
    a + b;
};

// Query function (fast, read-only)
public shared query func getBalance() : async Nat {
    balance;
};

// Anonymous function (lambda)
let multiply = func(a : Nat, b : Nat) : Nat {
    a * b;
};

// Function with generic parameters
func map&lt;A, B&gt;(arr : [A], f : A -&gt; B) : [B] {
    Array.map&lt;A, B&gt;(arr, f);
};</code></pre>
<h3 id="type-declarations">2.4.4 Type Declarations</h3>
<p>Define custom types for better code organization.</p>
<pre class="motoko"><code>// Type alias
type UserId = Principal;
type Balance = Nat;

// Record type
type Account = {
    id : UserId;
    balance : Balance;
    isActive : Bool;
};

// Variant type
type TransactionStatus = {
    #Pending;
    #Completed;
    #Failed : Text;
};

// Generic type
type Result&lt;T, E&gt; = {
    #Ok : T;
    #Err : E;
};</code></pre>
<h2 id="control-flow">2.5 Control Flow</h2>
<p>Motoko provides familiar control flow constructs, all designed as
expressions that return values.</p>
<h3 id="conditionals">2.5.1 Conditionals</h3>
<p>The <code>if-else</code> construct is an expression that must return
the same type from both branches.</p>
<pre class="motoko"><code>// Simple conditional
let status = if (balance &gt; 0) &quot;Active&quot; else &quot;Inactive&quot;;

// Multi-line conditional
let message = if (age &lt; 18) {
    &quot;Minor&quot;;
} else if (age &lt; 65) {
    &quot;Adult&quot;;
} else {
    &quot;Senior&quot;;
};

// Conditional with side effects
if (isValid) {
    processData();
} else {
    logError();
};

// Nested conditionals
let category = if (score &gt;= 90) {
    &quot;Excellent&quot;;
} else {
    if (score &gt;= 75) &quot;Good&quot; else &quot;Needs Improvement&quot;;
};</code></pre>
<h3 id="loops">2.5.2 Loops</h3>
<p>Motoko supports several looping constructs for iteration.</p>
<h4 id="for-loops">For Loops</h4>
<p>Iterate over collections using iterators.</p>
<pre class="motoko"><code>import Iter &quot;mo:base/Iter&quot;;

// Iterate over array
let numbers = [1, 2, 3, 4, 5];
for (num in numbers.vals()) {
    Debug.print(Nat.toText(num));
};

// Iterate with index
for ((index, value) in numbers.vals() |&gt; Iter.enumerate(_)) {
    Debug.print(Nat.toText(index) # &quot;: &quot; # Nat.toText(value));
};

// Iterate over range
for (i in Iter.range(0, 9)) {
    Debug.print(Nat.toText(i));  // 0 to 9
};

// Iterate over text characters
let text = &quot;Hello&quot;;
for (char in text.chars()) {
    Debug.print(Char.toText(char));
};</code></pre>
<h4 id="while-loops">While Loops</h4>
<p>Execute code while a condition is true.</p>
<pre class="motoko"><code>var counter = 0;
while (counter &lt; 5) {
    Debug.print(Nat.toText(counter));
    counter += 1;
};

// Infinite loop with break
var running = true;
while (running) {
    // Do something
    if (shouldStop) {
        running := false;
    };
};</code></pre>
<h4 id="loop-while">Loop-While</h4>
<p>Execute code at least once, then check condition.</p>
<pre class="motoko"><code>var attempts = 0;
loop {
    attempts += 1;
    Debug.print(&quot;Attempt: &quot; # Nat.toText(attempts));
} while (attempts &lt; 3);</code></pre>
<h4 id="loop-with-break-and-continue">Loop with Break and Continue</h4>
<pre class="motoko"><code>// Infinite loop with break
var count = 0;
loop {
    count += 1;
    if (count &gt; 10) {
        break;
    };
    if (count % 2 == 0) {
        continue;  // Skip even numbers
    };
    Debug.print(Nat.toText(count));
};</code></pre>
<h3 id="switch-and-pattern-matching">2.5.3 Switch and Pattern
Matching</h3>
<p>The <code>switch</code> statement provides exhaustive pattern
matching, ensuring all cases are handled.</p>
<pre class="motoko"><code>// Basic switch on variant
type Status = { #Active; #Suspended; #Closed };

func describeStatus(status : Status) : Text {
    switch (status) {
        case (#Active) &quot;Account is active&quot;;
        case (#Suspended) &quot;Account is suspended&quot;;
        case (#Closed) &quot;Account is closed&quot;;
    };
};

// Switch with data extraction
type Result = { #Ok : Nat; #Err : Text };

func handleResult(result : Result) : Text {
    switch (result) {
        case (#Ok(value)) &quot;Success: &quot; # Nat.toText(value);
        case (#Err(message)) &quot;Error: &quot; # message;
    };
};

// Switch on Option
func processOption(opt : ?Nat) : Nat {
    switch (opt) {
        case null 0;
        case (?value) value * 2;
    };
};

// Switch on tuples
func describe(point : (Int, Int)) : Text {
    switch (point) {
        case (0, 0) &quot;Origin&quot;;
        case (x, 0) &quot;X-axis at &quot; # Int.toText(x);
        case (0, y) &quot;Y-axis at &quot; # Int.toText(y);
        case (x, y) &quot;Point at (&quot; # Int.toText(x) # &quot;, &quot; # Int.toText(y) # &quot;)&quot;;
    };
};

// Complex pattern matching
type Shape = {
    #Circle : { radius : Float };
    #Rectangle : { width : Float; height : Float };
    #Triangle : { base : Float; height : Float };
};

func area(shape : Shape) : Float {
    switch (shape) {
        case (#Circle({radius})) 3.14159 * radius * radius;
        case (#Rectangle({width; height})) width * height;
        case (#Triangle({base; height})) 0.5 * base * height;
    };
};</code></pre>
<h2 id="actors-and-async-data">2.6 Actors and Async Data</h2>
<p>Actors are the fundamental building blocks of Internet Computer
applications. They encapsulate state and provide asynchronous
message-passing interfaces.</p>
<h3 id="understanding-actors">2.6.1 Understanding Actors</h3>
<p>An actor in Motoko represents a <strong>canister</strong>—a smart
contract running on the Internet Computer. Each actor: - Has its own
isolated state - Communicates asynchronously with other actors -
Processes messages one at a time (no concurrency issues) - Can be
upgraded while preserving state</p>
<pre class="motoko"><code>// Simple actor
actor Counter {
    var count : Nat = 0;
    
    public func increment() : async Nat {
        count += 1;
        return count;
    };
    
    public query func get() : async Nat {
        return count;
    };
};</code></pre>
<h3 id="public-and-private-functions">2.6.2 Public and Private
Functions</h3>
<pre class="motoko"><code>actor MyActor {
    var privateState : Nat = 0;
    
    // Private function (not exposed)
    func privateHelper(n : Nat) : Nat {
        n * 2;
    };
    
    // Public shared function (update call - goes through consensus)
    public shared func updateState(n : Nat) : async Nat {
        privateState := privateHelper(n);
        return privateState;
    };
    
    // Public query function (read-only - fast, no consensus)
    public query func getState() : async Nat {
        return privateState;
    };
};</code></pre>
<p><strong>Key Differences</strong>: - <strong>Update calls</strong>
(<code>public shared func</code>): Modify state, go through consensus,
take ~2 seconds - <strong>Query calls</strong>
(<code>public query func</code>): Read-only, do not modify state, return
in milliseconds - <strong>Private functions</strong>
(<code>func</code>): Only callable within the actor, synchronous</p>
<h3 id="async-and-await">2.6.3 Async and Await</h3>
<p>All inter-actor communication is asynchronous. Use <code>await</code>
to wait for async results.</p>
<pre class="motoko"><code>actor AsyncExample {
    // Call another actor
    public func callOtherActor() : async Nat {
        let otherActor = actor(&quot;canister-id&quot;) : actor {
            getValue : () -&gt; async Nat;
        };
        
        let result = await otherActor.getValue();
        return result * 2;
    };
    
    // Multiple async calls
    public func multipleCallsSequential() : async Nat {
        let actor1 = actor(&quot;id-1&quot;) : actor { get : () -&gt; async Nat };
        let actor2 = actor(&quot;id-2&quot;) : actor { get : () -&gt; async Nat };
        
        let val1 = await actor1.get();
        let val2 = await actor2.get();
        return val1 + val2;
    };
    
    // Error handling with async
    public func safeCall() : async ?Nat {
        try {
            let other = actor(&quot;id&quot;) : actor { get : () -&gt; async Nat };
            let result = await other.get();
            return ?result;
        } catch (e) {
            return null;
        };
    };
};</code></pre>
<h3 id="actor-classes">2.6.4 Actor Classes</h3>
<p>Actor classes are templates for creating multiple actor
instances.</p>
<pre class="motoko"><code>// Actor class definition
actor class Counter(initValue : Nat) {
    var count = initValue;
    
    public func increment() : async Nat {
        count += 1;
        return count;
    };
    
    public query func get() : async Nat {
        return count;
    };
};

// Usage (in a management canister)
import Counter &quot;counter&quot;;

actor Manager {
    public func createCounter(init : Nat) : async Principal {
        let newCounter = await Counter.Counter(init);
        return Principal.fromActor(newCounter);
    };
};</code></pre>
<h3 id="caller-identity">2.6.5 Caller Identity</h3>
<p>Access the caller’s principal in shared functions.</p>
<pre class="motoko"><code>import Principal &quot;mo:base/Principal&quot;;

actor Auth {
    var owner : Principal = Principal.fromText(&quot;aaaaa-aa&quot;);
    
    public shared(msg) func setOwner() : async () {
        owner := msg.caller;
    };
    
    public shared(msg) func restrictedAction() : async Text {
        if (msg.caller == owner) {
            return &quot;Access granted&quot;;
        } else {
            return &quot;Access denied&quot;;
        };
    };
    
    public shared query(msg) func whoAmI() : async Principal {
        return msg.caller;
    };
};</code></pre>
<h2 id="mutable-state">2.7 Mutable State</h2>
<p>Managing mutable state is crucial for building stateful applications.
Motoko provides clear semantics for mutation.</p>
<h3 id="mutable-variables">2.7.1 Mutable Variables</h3>
<pre class="motoko"><code>actor StateExample {
    // Mutable scalar
    var counter : Nat = 0;
    var name : Text = &quot;Default&quot;;
    var isActive : Bool = true;
    
    // Mutable in records
    type Account = {
        var balance : Nat;
        owner : Principal;
    };
    
    var account : Account = {
        var balance = 1000;
        owner = Principal.fromText(&quot;aaaaa-aa&quot;);
    };
    
    public func updateBalance(amount : Nat) : async () {
        account.balance += amount;
    };
    
    // Mutable arrays
    var items : [var Nat] = [var 1, 2, 3];
    
    public func updateItem(index : Nat, value : Nat) : async () {
        items[index] := value;
    };
};</code></pre>
<h3 id="mutable-collections">2.7.2 Mutable Collections</h3>
<p>Use specialized data structures for efficient mutable
collections.</p>
<pre class="motoko"><code>import Buffer &quot;mo:base/Buffer&quot;;
import HashMap &quot;mo:base/HashMap&quot;;
import Hash &quot;mo:base/Hash&quot;;
import Nat &quot;mo:base/Nat&quot;;

actor Collections {
    // Dynamic array (Buffer)
    let buffer = Buffer.Buffer&lt;Nat&gt;(0);
    
    public func addItem(item : Nat) : async () {
        buffer.add(item);
    };
    
    public query func getSize() : async Nat {
        buffer.size();
    };
    
    // HashMap (mutable key-value store)
    let map = HashMap.HashMap&lt;Nat, Text&gt;(10, Nat.equal, Hash.hash);
    
    public func putValue(key : Nat, value : Text) : async () {
        map.put(key, value);
    };
    
    public query func getValue(key : Nat) : async ?Text {
        map.get(key);
    };
};</code></pre>
<h3 id="state-transitions">2.7.3 State Transitions</h3>
<p>Pattern for safe state transitions.</p>
<pre class="motoko"><code>actor StateMachine {
    type State = {
        #Idle;
        #Processing;
        #Complete;
        #Failed : Text;
    };
    
    var currentState : State = #Idle;
    
    public func startProcessing() : async Result.Result&lt;(), Text&gt; {
        switch (currentState) {
            case (#Idle) {
                currentState := #Processing;
                #ok(());
            };
            case (_) {
                #err(&quot;Cannot start: not in idle state&quot;);
            };
        };
    };
    
    public func completeProcessing() : async Result.Result&lt;(), Text&gt; {
        switch (currentState) {
            case (#Processing) {
                currentState := #Complete;
                #ok(());
            };
            case (_) {
                #err(&quot;Cannot complete: not processing&quot;);
            };
        };
    };
    
    public query func getState() : async State {
        currentState;
    };
};</code></pre>
<h2 id="messaging">2.8 Messaging</h2>
<p>Messaging is how actors communicate. Understanding message types and
patterns is essential for building robust applications.</p>
<h3 id="update-vs-query-messages">2.8.1 Update vs Query Messages</h3>
<pre class="motoko"><code>actor Messaging {
    var data : Nat = 0;
    
    // Update message: modifies state, goes through consensus (~2s)
    public shared func update(value : Nat) : async () {
        data := value;
    };
    
    // Query message: read-only, fast (~100ms)
    public shared query func query() : async Nat {
        data;
    };
    
    // Composite query (calling other queries)
    public shared composite query func compositeQuery() : async Nat {
        // Can call other query functions
        let result = await query();
        result * 2;
    };
};</code></pre>
<h3 id="one-way-messages">2.8.2 One-way Messages</h3>
<p>Use one-way messages when you don’t need a response.</p>
<pre class="motoko"><code>actor Logger {
    var logs : [Text] = [];
    
    // One-way message (fire and forget)
    public shared func log(message : Text) : async () {
        // No return value needed
        logs := Array.append(logs, [message]);
    };
};</code></pre>
<h3 id="inter-canister-calls">2.8.3 Inter-Canister Calls</h3>
<pre class="motoko"><code>actor Caller {
    // Define remote actor interface
    type RemoteActor = actor {
        getData : () -&gt; async Nat;
        setData : (Nat) -&gt; async ();
    };
    
    public func callRemote(canisterId : Text) : async Nat {
        let remote : RemoteActor = actor(canisterId);
        
        // Call remote function
        let currentValue = await remote.getData();
        
        // Update remote state
        await remote.setData(currentValue + 1);
        
        return currentValue + 1;
    };
};</code></pre>
<h3 id="error-handling-in-messages">2.8.4 Error Handling in
Messages</h3>
<pre class="motoko"><code>actor ErrorHandling {
    public func riskyOperation() : async Result.Result&lt;Nat, Text&gt; {
        try {
            let remote = actor(&quot;unknown-id&quot;) : actor {
                compute : () -&gt; async Nat;
            };
            let result = await remote.compute();
            #ok(result);
        } catch (e) {
            #err(&quot;Failed to call remote: &quot; # Error.message(e));
        };
    };
};</code></pre>
<h2 id="modules-and-imports">2.9 Modules and Imports</h2>
<p>Modules organize code into reusable, composable units. Motoko
supports both local modules and package imports.</p>
<h3 id="defining-modules">2.9.1 Defining Modules</h3>
<pre class="motoko"><code>// MathUtils.mo
module {
    public func add(a : Nat, b : Nat) : Nat {
        a + b;
    };
    
    public func multiply(a : Nat, b : Nat) : Nat {
        a * b;
    };
    
    public func square(n : Nat) : Nat {
        multiply(n, n);
    };
};</code></pre>
<h3 id="importing-local-modules">2.9.2 Importing Local Modules</h3>
<pre class="motoko"><code>// Main.mo
import MathUtils &quot;./MathUtils&quot;;

actor {
    public func calculate() : async Nat {
        let sum = MathUtils.add(5, 3);
        let product = MathUtils.multiply(4, 7);
        return sum + product;
    };
};</code></pre>
<h3 id="importing-from-base-library">2.9.3 Importing from Base
Library</h3>
<p>The Motoko base library provides essential utilities.</p>
<pre class="motoko"><code>import Array &quot;mo:base/Array&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Text &quot;mo:base/Text&quot;;
import Debug &quot;mo:base/Debug&quot;;
import Iter &quot;mo:base/Iter&quot;;
import HashMap &quot;mo:base/HashMap&quot;;
import Buffer &quot;mo:base/Buffer&quot;;
import Result &quot;mo:base/Result&quot;;
import Option &quot;mo:base/Option&quot;;
import Principal &quot;mo:base/Principal&quot;;

actor Example {
    public func demonstrateBase() : async () {
        // Array operations
        let numbers = [1, 2, 3, 4, 5];
        let doubled = Array.map&lt;Nat, Nat&gt;(numbers, func(n) = n * 2);
        
        // Text operations
        let upper = Text.toUppercase(&quot;hello&quot;);
        
        // Iteration
        for (n in Iter.range(0, 9)) {
            Debug.print(Nat.toText(n));
        };
    };
};</code></pre>
<h3 id="module-patterns">2.9.4 Module Patterns</h3>
<pre class="motoko"><code>// Nested modules
module OuterModule {
    public module InnerModule {
        public func helper() : Nat { 42 };
    };
    
    public func useInner() : Nat {
        InnerModule.helper() * 2;
    };
};

// Module with private state
module Counter {
    var count : Nat = 0;
    
    public func increment() : Nat {
        count += 1;
        count;
    };
    
    public func get() : Nat {
        count;
    };
};

// Importing specific items
import { map; filter } = &quot;mo:base/Array&quot;;</code></pre>
<h2 id="pattern-matching">2.10 Pattern Matching</h2>
<p>Pattern matching is one of Motoko’s most powerful features, enabling
elegant and safe data destructuring.</p>
<h3 id="basic-patterns">2.10.1 Basic Patterns</h3>
<pre class="motoko"><code>// Literal patterns
func isZero(n : Nat) : Bool {
    switch (n) {
        case (0) true;
        case (_) false;  // wildcard
    };
};

// Variable binding
func describe(opt : ?Nat) : Text {
    switch (opt) {
        case null &quot;No value&quot;;
        case (?n) &quot;Value: &quot; # Nat.toText(n);
    };
};</code></pre>
<h3 id="tuple-patterns">2.10.2 Tuple Patterns</h3>
<pre class="motoko"><code>func swapIfNeeded(pair : (Nat, Nat)) : (Nat, Nat) {
    switch (pair) {
        case ((a, b)) if (a &gt; b) (b, a);
        case ((a, b)) (a, b);
    };
};

// Nested tuples
func processNested(data : (Nat, (Text, Bool))) : Text {
    switch (data) {
        case ((n, (s, true))) &quot;Active: &quot; # s # &quot; = &quot; # Nat.toText(n);
        case ((n, (s, false))) &quot;Inactive: &quot; # s;
    };
};</code></pre>
<h3 id="record-patterns">2.10.3 Record Patterns</h3>
<pre class="motoko"><code>type User = {
    name : Text;
    age : Nat;
    isAdmin : Bool;
};

func greetUser(user : User) : Text {
    switch (user) {
        case ({ name; isAdmin = true }) &quot;Hello, Admin &quot; # name;
        case ({ name; age }) if (age &lt; 18) &quot;Hello, young &quot; # name;
        case ({ name }) &quot;Hello, &quot; # name;
    };
};

// Partial record matching
func getUsername(user : User) : Text {
    let { name } = user;
    name;
};</code></pre>
<h3 id="variant-patterns">2.10.4 Variant Patterns</h3>
<pre class="motoko"><code>type Result&lt;T, E&gt; = {
    #Ok : T;
    #Err : E;
};

func unwrapOr&lt;T, E&gt;(result : Result&lt;T, E&gt;, default : T) : T {
    switch (result) {
        case (#Ok(value)) value;
        case (#Err(_)) default;
    };
};

// Nested variant matching
type Payment = {
    #Cash : Nat;
    #Card : { number : Text; amount : Nat };
    #Crypto : { token : Text; amount : Nat };
};

func processPayment(payment : Payment) : Text {
    switch (payment) {
        case (#Cash(amount)) &quot;Cash: &quot; # Nat.toText(amount);
        case (#Card({ amount })) &quot;Card: &quot; # Nat.toText(amount);
        case (#Crypto({ token; amount })) token # &quot;: &quot; # Nat.toText(amount);
    };
};</code></pre>
<h3 id="array-patterns">2.10.5 Array Patterns</h3>
<pre class="motoko"><code>func describeList(list : [Nat]) : Text {
    switch (list.size()) {
        case (0) &quot;Empty list&quot;;
        case (1) &quot;Single element: &quot; # Nat.toText(list[0]);
        case (_) &quot;Multiple elements, first: &quot; # Nat.toText(list[0]);
    };
};</code></pre>
<h3 id="guards">2.10.6 Guards</h3>
<p>Use guards (<code>if</code>) for additional conditions.</p>
<pre class="motoko"><code>func categorize(n : Int) : Text {
    switch (n) {
        case (x) if (x &lt; 0) &quot;Negative&quot;;
        case (0) &quot;Zero&quot;;
        case (x) if (x &gt; 0 and x &lt;= 10) &quot;Small positive&quot;;
        case (_) &quot;Large positive&quot;;
    };
};

type Account = {
    balance : Nat;
    isVIP : Bool;
};

func checkWithdrawal(account : Account, amount : Nat) : Bool {
    switch (account) {
        case ({ balance; isVIP = true }) if (balance &gt;= amount) true;
        case ({ balance; isVIP = false }) if (balance &gt;= amount + 10) true;
        case (_) false;
    };
};</code></pre>
<h2 id="error-handling">2.11 Error Handling</h2>
<p>Robust error handling is critical for production applications. Motoko
provides multiple mechanisms for dealing with errors.</p>
<h3 id="try-catch">2.11.1 Try-Catch</h3>
<p>Handle runtime errors with try-catch blocks.</p>
<pre class="motoko"><code>import Error &quot;mo:base/Error&quot;;

actor ErrorHandling {
    public func divide(a : Nat, b : Nat) : async Result.Result&lt;Nat, Text&gt; {
        try {
            if (b == 0) {
                throw Error.reject(&quot;Division by zero&quot;);
            };
            #ok(a / b);
        } catch (e) {
            #err(Error.message(e));
        };
    };
    
    public func multipleOperations() : async ?Nat {
        try {
            let step1 = await remoteCall1();
            let step2 = await remoteCall2(step1);
            let step3 = await remoteCall3(step2);
            ?step3;
        } catch (e) {
            Debug.print(&quot;Error: &quot; # Error.message(e));
            null;
        };
    };
    
    // Helper functions (example)
    func remoteCall1() : async Nat { 10 };
    func remoteCall2(n : Nat) : async Nat { n * 2 };
    func remoteCall3(n : Nat) : async Nat { n + 5 };
};</code></pre>
<h3 id="result-type">2.11.2 Result Type</h3>
<p>Use the <code>Result</code> type for explicit error handling.</p>
<pre class="motoko"><code>import Result &quot;mo:base/Result&quot;;

type Result&lt;T, E&gt; = Result.Result&lt;T, E&gt;;

actor ResultExample {
    type Error = {
        #NotFound;
        #InvalidInput : Text;
        #Unauthorized;
    };
    
    func validateInput(input : Text) : Result&lt;Text, Error&gt; {
        if (input.size() == 0) {
            return #err(#InvalidInput(&quot;Empty input&quot;));
        };
        if (input.size() &gt; 100) {
            return #err(#InvalidInput(&quot;Input too long&quot;));
        };
        #ok(input);
    };
    
    func findUser(id : Nat) : Result&lt;User, Error&gt; {
        // Simulated lookup
        if (id == 0) {
            #err(#NotFound);
        } else {
            #ok({ name = &quot;User &quot; # Nat.toText(id); age = 25 });
        };
    };
    
    public func processUser(id : Nat, input : Text) : async Result&lt;Text, Error&gt; {
        switch (validateInput(input)) {
            case (#err(e)) #err(e);
            case (#ok(validInput)) {
                switch (findUser(id)) {
                    case (#err(e)) #err(e);
                    case (#ok(user)) {
                        #ok(&quot;Processed &quot; # validInput # &quot; for &quot; # user.name);
                    };
                };
            };
        };
    };
};</code></pre>
<h3 id="option-type">2.11.3 Option Type</h3>
<p>Use <code>Option</code> for operations that may not return a
value.</p>
<pre class="motoko"><code>import Option &quot;mo:base/Option&quot;;

actor OptionExample {
    func safeDivide(a : Nat, b : Nat) : ?Nat {
        if (b == 0) {
            null;
        } else {
            ?(a / b);
        };
    };
    
    public func calculate(a : Nat, b : Nat) : async Nat {
        switch (safeDivide(a, b)) {
            case null 0;  // Default value
            case (?result) result;
        };
    };
    
    // Option utilities
    public func demonstrateOption() : async () {
        let maybeValue : ?Nat = ?42;
        
        // Check if value exists
        let exists = Option.isSome(maybeValue);
        
        // Get value or default
        let value = Option.get(maybeValue, 0);
        
        // Map over option
        let doubled = Option.map&lt;Nat, Nat&gt;(maybeValue, func(n) = n * 2);
        
        // Chain operations
        let result = Option.chain&lt;Nat, Nat&gt;(
            maybeValue,
            func(n) = if (n &gt; 0) ?n else null
        );
    };
};</code></pre>
<h3 id="assert-and-debug">2.11.4 Assert and Debug</h3>
<p>Use assertions for development and invariant checking.</p>
<pre class="motoko"><code>import Debug &quot;mo:base/Debug&quot;;

actor Assertions {
    public func criticalOperation(value : Nat) : async () {
        // Assert preconditions
        assert value &gt; 0;
        assert value &lt; 1000;
        
        // Perform operation
        let result = value * 2;
        
        // Assert postconditions
        assert result &gt; value;
        
        Debug.print(&quot;Operation successful: &quot; # Nat.toText(result));
    };
    
    public func debugExample() : async () {
        Debug.print(&quot;Starting operation&quot;);
        
        let x = 42;
        Debug.print(&quot;x = &quot; # debug_show(x));
        
        let record = { name = &quot;Alice&quot;; age = 30 };
        Debug.print(&quot;record = &quot; # debug_show(record));
    };
};</code></pre>
<h3 id="error-propagation">2.11.5 Error Propagation</h3>
<p>Chain error-prone operations cleanly.</p>
<pre class="motoko"><code>actor ErrorPropagation {
    type Error = { #DatabaseError; #NetworkError; #ValidationError };
    
    func step1() : Result&lt;Nat, Error&gt; {
        // Simulated operation
        #ok(10);
    };
    
    func step2(n : Nat) : Result&lt;Nat, Error&gt; {
        if (n &gt; 5) #ok(n * 2) else #err(#ValidationError);
    };
    
    func step3(n : Nat) : Result&lt;Text, Error&gt; {
        #ok(&quot;Final: &quot; # Nat.toText(n));
    };
    
    public func pipeline() : async Result&lt;Text, Error&gt; {
        // Manual error propagation
        switch (step1()) {
            case (#err(e)) #err(e);
            case (#ok(v1)) {
                switch (step2(v1)) {
                    case (#err(e)) #err(e);
                    case (#ok(v2)) {
                        step3(v2);
                    };
                };
            };
        };
    };
    
    // Helper for cleaner propagation
    func andThen&lt;T, U, E&gt;(
        result : Result&lt;T, E&gt;,
        f : T -&gt; Result&lt;U, E&gt;
    ) : Result&lt;U, E&gt; {
        switch (result) {
            case (#err(e)) #err(e);
            case (#ok(value)) f(value);
        };
    };
    
    public func pipelineClean() : async Result&lt;Text, Error&gt; {
        step1()
        |&gt; andThen(_, step2)
        |&gt; andThen(_, step3);
    };
};</code></pre>
<h2 id="data-persistence">2.12 Data Persistence</h2>
<p>Unlike traditional smart contracts, Motoko provides
<strong>orthogonal persistence</strong>—your data automatically persists
across upgrades without explicit serialization.</p>
<h3 id="stable-variables">2.12.1 Stable Variables</h3>
<p>Mark variables as <code>stable</code> to persist them across canister
upgrades.</p>
<pre class="motoko"><code>actor PersistentCounter {
    stable var count : Nat = 0;
    stable var users : [Text] = [];
    stable var lastUpdate : Nat = 0;
    
    public func increment() : async Nat {
        count += 1;
        lastUpdate := count;  // Simplified timestamp
        count;
    };
    
    public func addUser(name : Text) : async () {
        users := Array.append(users, [name]);
    };
    
    public query func getStats() : async (Nat, Nat, Nat) {
        (count, users.size(), lastUpdate);
    };
};</code></pre>
<h3 id="stable-types">2.12.2 Stable Types</h3>
<p>Only certain types can be marked as stable:</p>
<ul>
<li><p>✅ Primitive types: <code>Nat</code>, <code>Int</code>,
<code>Bool</code>, <code>Text</code>, <code>Principal</code>,
<code>Blob</code></p></li>
<li><p>✅ Immutable arrays: <code>[T]</code> where <code>T</code> is
stable</p></li>
<li><p>✅ Tuples of stable types</p></li>
<li><p>✅ Records of stable types</p></li>
<li><p>✅ Variants of stable types</p></li>
<li><p>✅ Options of stable types</p></li>
<li><p>❌ Mutable arrays: <code>[var T]</code></p></li>
<li><p>❌ Functions</p></li>
<li><p>❌ Objects with methods</p></li>
</ul>
<pre class="motoko"><code>actor StableTypes {
    type StableUser = {
        name : Text;
        balance : Nat;
        registered : Nat;
    };
    
    type StableRecord = {
        #Active : StableUser;
        #Suspended : { reason : Text };
    };
    
    stable var users : [StableUser] = [];
    stable var records : [StableRecord] = [];
    
    // This won&#39;t work - mutable array
    // stable var mutableArray : [var Nat] = [var 1, 2, 3];
    
    // This won&#39;t work - HashMap is not stable
    // import HashMap &quot;mo:base/HashMap&quot;;
    // stable var map = HashMap.HashMap&lt;Nat, Text&gt;(10, Nat.equal, Hash.hash);
};</code></pre>
<h3 id="upgrade-hooks">2.12.3 Upgrade Hooks</h3>
<p>Use <code>preupgrade</code> and <code>postupgrade</code> hooks for
complex state migration.</p>
<pre class="motoko"><code>import Buffer &quot;mo:base/Buffer&quot;;
import HashMap &quot;mo:base/HashMap&quot;;

actor UpgradeExample {
    // Non-stable runtime state
    var runtimeCache = HashMap.HashMap&lt;Nat, Text&gt;(10, Nat.equal, Hash.hash);
    let buffer = Buffer.Buffer&lt;Nat&gt;(0);
    
    // Stable storage
    stable var stableData : [(Nat, Text)] = [];
    stable var stableArray : [Nat] = [];
    
    // Before upgrade: save state
    system func preupgrade() {
        // Convert HashMap to stable array
        stableData := Iter.toArray(runtimeCache.entries());
        
        // Convert Buffer to stable array
        stableArray := Buffer.toArray(buffer);
        
        Debug.print(&quot;Preupgrade: saved &quot; # Nat.toText(stableData.size()) # &quot; entries&quot;);
    };
    
    // After upgrade: restore state
    system func postupgrade() {
        // Restore HashMap from stable array
        for ((key, value) in stableData.vals()) {
            runtimeCache.put(key, value);
        };
        
        // Restore Buffer from stable array
        for (item in stableArray.vals()) {
            buffer.add(item);
        };
        
        // Clear stable storage to save memory
        stableData := [];
        stableArray := [];
        
        Debug.print(&quot;Postupgrade: restored cache and buffer&quot;);
    };
    
    public func addEntry(key : Nat, value : Text) : async () {
        runtimeCache.put(key, value);
        buffer.add(key);
    };
};</code></pre>
<h3 id="migration-patterns">2.12.4 Migration Patterns</h3>
<p>Handle schema changes gracefully during upgrades.</p>
<pre class="motoko"><code>actor VersionedStorage {
    // Version 1 schema
    type UserV1 = {
        name : Text;
        balance : Nat;
    };
    
    // Version 2 schema (added email field)
    type UserV2 = {
        name : Text;
        balance : Nat;
        email : ?Text;
    };
    
    stable var version : Nat = 2;
    stable var usersV2 : [UserV2] = [];
    
    // Migration from V1 to V2
    system func postupgrade() {
        if (version == 1) {
            // Migrate V1 users to V2 format
            // usersV2 := Array.map(usersV1, func(u : UserV1) : UserV2 {
            //     { name = u.name; balance = u.balance; email = null }
            // });
            version := 2;
            Debug.print(&quot;Migrated from V1 to V2&quot;);
        };
    };
};</code></pre>
<h2 id="garbage-collection">2.13 Garbage Collection</h2>
<p>Motoko features automatic memory management with incremental garbage
collection. Understanding GC behavior helps optimize performance.</p>
<h3 id="memory-management">2.13.1 Memory Management</h3>
<p>Motoko’s garbage collector runs incrementally during message
execution: - <strong>Automatic</strong>: No manual memory management
needed - <strong>Incremental</strong>: Spreads GC work across multiple
messages - <strong>Generational</strong>: Optimizes for short-lived
objects - <strong>Compacting</strong>: Reduces fragmentation</p>
<pre class="motoko"><code>actor GCExample {
    // Short-lived objects (collected quickly)
    public func processData() : async Nat {
        let temp1 = Array.init&lt;Nat&gt;(1000, 0);
        let temp2 = Array.tabulate&lt;Nat&gt;(1000, func(i) = i);
        // temp1 and temp2 become garbage when function returns
        temp2[500];
    };
    
    // Long-lived objects (stay in memory)
    stable var persistentData : [Nat] = [];
    
    public func storeData(items : [Nat]) : async () {
        persistentData := Array.append(persistentData, items);
        // persistentData survives across calls
    };
};</code></pre>
<h3 id="memory-optimization">2.13.2 Memory Optimization</h3>
<p>Best practices for memory efficiency:</p>
<pre class="motoko"><code>import Buffer &quot;mo:base/Buffer&quot;;

actor Optimized {
    // ❌ Bad: Creates many intermediate arrays
    func inefficientProcessing(data : [Nat]) : [Nat] {
        let step1 = Array.map&lt;Nat, Nat&gt;(data, func(n) = n * 2);
        let step2 = Array.filter&lt;Nat&gt;(step1, func(n) = n &gt; 10);
        let step3 = Array.map&lt;Nat, Nat&gt;(step2, func(n) = n + 1);
        step3;
    };
    
    // ✅ Good: Uses Buffer for efficient incremental building
    func efficientProcessing(data : [Nat]) : [Nat] {
        let result = Buffer.Buffer&lt;Nat&gt;(data.size());
        for (n in data.vals()) {
            let doubled = n * 2;
            if (doubled &gt; 10) {
                result.add(doubled + 1);
            };
        };
        Buffer.toArray(result);
    };
    
    // ✅ Good: Reuse existing structures
    var cache = HashMap.HashMap&lt;Nat, Text&gt;(100, Nat.equal, Hash.hash);
    
    public func getValue(key : Nat) : async ?Text {
        switch (cache.get(key)) {
            case (?value) ?value;  // Reuse cached value
            case null {
                let computed = computeExpensiveValue(key);
                cache.put(key, computed);
                ?computed;
            };
        };
    };
    
    func computeExpensiveValue(key : Nat) : Text {
        &quot;Value for &quot; # Nat.toText(key);
    };
};</code></pre>
<h3 id="monitoring-memory-usage">2.13.3 Monitoring Memory Usage</h3>
<pre class="motoko"><code>import Prim &quot;mo:prim&quot;;

actor MemoryMonitor {
    public query func getMemorySize() : async Nat {
        Prim.rts_memory_size();
    };
    
    public query func getHeapSize() : async Nat {
        Prim.rts_heap_size();
    };
    
    public func reportMemory() : async Text {
        let total = Prim.rts_memory_size();
        let heap = Prim.rts_heap_size();
        &quot;Total: &quot; # Nat.toText(total) # &quot; bytes, Heap: &quot; # Nat.toText(heap) # &quot; bytes&quot;;
    };
};</code></pre>
<h2 id="orthogonal-persistence">2.14 Orthogonal Persistence</h2>
<p>Orthogonal persistence is a revolutionary feature of the Internet
Computer that automatically persists program state without explicit
save/load operations.</p>
<h3 id="understanding-orthogonal-persistence">2.14.1 Understanding
Orthogonal Persistence</h3>
<p>In traditional systems, you must: 1. Serialize state to storage 2.
Deserialize state from storage 3. Manage database connections 4. Handle
data consistency</p>
<p>With orthogonal persistence:</p>
<ul>
<li><p>✅ All state persists automatically</p></li>
<li><p>✅ No serialization/deserialization</p></li>
<li><p>✅ No database management</p></li>
<li><p>✅ Consistency guaranteed</p></li>
</ul>
<pre class="motoko"><code>actor AutoPersist {
    // All these persist automatically!
    var counter : Nat = 0;
    var users : [Text] = [];
    let records = Buffer.Buffer&lt;Text&gt;(0);
    var map = HashMap.HashMap&lt;Nat, Text&gt;(10, Nat.equal, Hash.hash);
    
    public func increment() : async Nat {
        counter += 1;
        // Automatically persisted after message execution
        counter;
    };
    
    public func addUser(name : Text) : async () {
        users := Array.append(users, [name]);
        // State change persisted automatically
    };
};</code></pre>
<h3 id="stable-vs-regular-variables">2.14.2 Stable vs Regular
Variables</h3>
<pre class="motoko"><code>actor PersistenceTypes {
    // Regular variable: persists between calls, 
    // but NOT across upgrades
    var temporary : Nat = 0;
    
    // Stable variable: persists between calls 
    // AND across upgrades
    stable var permanent : Nat = 0;
    
    public func incrementBoth() : async (Nat, Nat) {
        temporary += 1;
        permanent += 1;
        (temporary, permanent);
    };
    
    // After upgrade:
    // - temporary resets to 0
    // - permanent keeps its value
};</code></pre>
<h3 id="persistence-lifecycle">2.14.3 Persistence Lifecycle</h3>
<pre class="motoko"><code>actor Lifecycle {
    var callCount : Nat = 0;
    stable var totalCalls : Nat = 0;
    
    public func recordCall() : async Text {
        callCount += 1;
        totalCalls += 1;
        
        &quot;This call: &quot; # Nat.toText(callCount) # 
        &quot;, Total: &quot; # Nat.toText(totalCalls);
    };
    
    // Persistence timeline:
    // 1. Message received
    // 2. Function executes
    // 3. State changes made
    // 4. Message completes
    // 5. State automatically persisted ✓
    // 6. Next message sees updated state
};</code></pre>
<h3 id="best-practices">2.14.4 Best Practices</h3>
<pre class="motoko"><code>actor BestPractices {
    // ✅ Use stable for critical data
    stable var userBalances : [(Principal, Nat)] = [];
    stable var totalSupply : Nat = 0;
    
    // ✅ Use regular vars for caches (can rebuild)
    var computedCache = HashMap.HashMap&lt;Nat, Nat&gt;(100, Nat.equal, Hash.hash);
    
    // ✅ Use stable vars for configuration
    stable var adminPrincipal : Principal = Principal.fromText(&quot;aaaaa-aa&quot;);
    stable var feeBasisPoints : Nat = 30;  // 0.3%
    
    // ✅ Large collections: use stable storage patterns
    stable var entries : [(Nat, Text)] = [];
    
    public func addEntry(key : Nat, value : Text) : async () {
        entries := Array.append(entries, [(key, value)]);
    };
    
    // ⚠️ For upgrades, use pre/postupgrade hooks
    system func preupgrade() {
        // Convert complex structures to stable format
        entries := Iter.toArray(computedCache.entries());
    };
    
    system func postupgrade() {
        // Rebuild complex structures from stable data
        for ((k, v) in entries.vals()) {
            computedCache.put(k, Nat.fromText(v) |&gt; Option.get(_, 0));
        };
    };
};</code></pre>
<hr />
<h2 id="summary">Summary</h2>
<p>This chapter covered the fundamental building blocks of Motoko
programming:</p>
<ol type="1">
<li><strong>Hello, World!</strong> - Your first Motoko program</li>
<li><strong>Basic Syntax</strong> - Expressions, blocks, comments, and
naming conventions</li>
<li><strong>Types</strong> - Rich type system with primitives,
composites, and generics</li>
<li><strong>Declarations</strong> - Immutable (<code>let</code>) and
mutable (<code>var</code>) bindings</li>
<li><strong>Control Flow</strong> - Conditionals, loops, and powerful
pattern matching</li>
<li><strong>Actors &amp; Async</strong> - The foundation of Internet
Computer applications</li>
<li><strong>Mutable State</strong> - Managing state safely and
efficiently</li>
<li><strong>Messaging</strong> - Inter-actor communication patterns</li>
<li><strong>Modules &amp; Imports</strong> - Code organization and
reuse</li>
<li><strong>Pattern Matching</strong> - Exhaustive, type-safe data
destructuring</li>
<li><strong>Error Handling</strong> - Robust error management with
Result and Option types</li>
<li><strong>Data Persistence</strong> - Stable variables and upgrade
hooks</li>
<li><strong>Garbage Collection</strong> - Automatic memory
management</li>
<li><strong>Orthogonal Persistence</strong> - Automatic state
persistence without serialization</li>
</ol>
<p>With these fundamentals mastered, you’re ready to build sophisticated
decentralized applications on the Internet Computer. The next chapter
will dive deeper into Motoko’s advanced type system and how it prevents
common programming errors at compile time.</p>
<hr />
<hr />
<h1 id="chapter-3-type-system-and-safety">Chapter 3: Type System and
Safety</h1>
<p>The primary design goal of Motoko is <strong>safety</strong>. The
language employs a sound type system that enforces rigorous checks at
compile time, preventing entire classes of errors such as null pointer
dereferences, type mismatches, and memory corruption.</p>
<h3 id="nominal-vs.-structural-typing">3.1 Nominal vs. Structural
Typing</h3>
<p>Motoko employs a mix of nominal and structural typing, but it leans
heavily on structural typing for records and objects. This allows for
flexible interaction between different actors that may not share the
same source code but share the same data shape.</p>
<p><strong>Primitives and Bounded Types:</strong></p>
<p>Unlike languages that default to a generic int, Motoko forces the
developer to be precise about the nature of numbers:</p>
<ul>
<li><p><strong><code>Nat</code> (Natural Number):</strong> An unbounded
non-negative integer (0, 1, 2…). This is the default for counters,
balances, and IDs. Using <code>Nat</code> prevents underflow errors
(e.g., a balance going below zero) by definition.</p></li>
<li><p><strong><code>Int</code> (Integer):</strong> Unbounded signed
integers.</p></li>
<li><p><strong><code>Nat8</code>, <code>Nat32</code>,
<code>Nat64</code>:</strong> Fixed-width types used for binary data
processing, cryptographic operations, and interacting with standard
interfaces like the Ledger (which often uses
<code>Nat64</code>).</p></li>
</ul>
<h3 id="the-billion-dollar-mistake-option-types">3.2 The Billion Dollar
Mistake: Option Types</h3>
<p>Motoko eliminates the concept of a “null” value that can be
implicitly assigned to any reference type. Instead, it utilizes
<strong>Option Types</strong> (<code>?T</code>). A variable of type
<code>Text</code> <em>must</em> contain text. It cannot be null. If a
value might be missing, it must be declared as <code>?Text</code>.</p>
<p>This forces the developer to handle the “missing” case explicitly
using pattern matching, eliminating the risk of runtime null pointer
exceptions.</p>
<p><strong>Code Snippet: Pattern Matching Options</strong></p>
<pre class="motoko"><code>let bio : ?Text = null;

// The compiler forces us to handle both cases
let displayBio = switch(bio) {
    case (null) { &quot;User has not provided a bio.&quot; };
    case (?text) { text };
};</code></pre>
<h3 id="more-primitive-types">3.3 More Primitive Types</h3>
<p>In addition to numeric types, Motoko provides several other primitive
types that ensure safety and precision:</p>
<ul>
<li><strong><code>Bool</code></strong>: Represents true or false
values.</li>
<li><strong><code>Text</code></strong>: Immutable strings of Unicode
characters.</li>
<li><strong><code>Blob</code></strong>: Binary data, useful for raw
bytes.</li>
<li><strong><code>Principal</code></strong>: Unique identifiers for
users and canisters on the Internet Computer.</li>
<li><strong><code>Float</code></strong>: 64-bit floating-point numbers
for decimal arithmetic.</li>
</ul>
<p>These types are designed to prevent common errors, such as overflow
in numerics or invalid string operations.</p>
<p><strong>Example:</strong></p>
<pre class="motoko"><code>let isActive : Bool = true;
let username : Text = &quot;motoko_dev&quot;;
let userId : Principal = Principal.fromText(&quot;aaaaa-aa&quot;);</code></pre>
<h3 id="composite-types-1">3.4 Composite Types</h3>
<p>Motoko supports several composite types to structure data safely.</p>
<h4 id="records-1">Records</h4>
<p>Records are structural types that group named fields.</p>
<p><strong>Example:</strong></p>
<pre class="motoko"><code>type Person = {
  name : Text;
  age : Nat;
  var balance : Int;
};

let user : Person = { name = &quot;Alice&quot;; age = 30; var balance = 100 };
user.balance := 200;</code></pre>
<h4 id="variants-1">Variants</h4>
<p>Variants represent tagged unions, useful for enumerations or error
handling.</p>
<p><strong>Example:</strong></p>
<pre class="motoko"><code>type Result&lt;T, E&gt; = {
  #Ok : T;
  #Err : E;
};

let success : Result&lt;Nat, Text&gt; = #Ok(42);
let failure : Result&lt;Nat, Text&gt; = #Err(&quot;Operation failed&quot;);</code></pre>
<h4 id="arrays-and-tuples">Arrays and Tuples</h4>
<p>Arrays can be immutable or mutable, and tuples are anonymous
records.</p>
<p><strong>Example:</strong></p>
<pre class="motoko"><code>let numbers : [Nat] = [1, 2, 3];
let mutableArray : [var Nat] = [var 4, 5, 6];

let pair : (Text, Nat) = (&quot;Score&quot;, 100);</code></pre>
<h3 id="type-aliases">3.5 Type Aliases</h3>
<p>Type aliases improve code readability without creating new types.</p>
<p><strong>Example:</strong></p>
<pre class="motoko"><code>type Username = Text;
type Age = Nat;

type User = {
  username : Username;
  age : Age;
};</code></pre>
<h3 id="generics">3.6 Generics</h3>
<p>Generics allow functions and classes to work with any type.</p>
<p><strong>Example:</strong></p>
<pre class="motoko"><code>func identity&lt;T&gt;(x : T) : T {
  return x;
};

ignore identity&lt;Nat&gt;(42);

class Box&lt;T&gt;(value : T) {
  public func open() : T { value };
};

let intBox = Box&lt;Nat&gt;(10);
ignore intBox.open();</code></pre>
<h3 id="type-inference">3.7 Type Inference</h3>
<p>Motoko infers types where possible, reducing annotations.</p>
<p><strong>Example:</strong></p>
<pre class="motoko"><code>let ar = [1, 2, 3]; // Inferred as [Nat]
let doubled = Array.map(ar, func x { x * 2 }); // Inferred types</code></pre>
<hr />
<hr />
<h1 id="chapter-4-motoko-memory-architecture">Chapter 4: Motoko Memory
Architecture</h1>
<p>This section explores the most disruptive feature of Motoko:
<strong>Orthogonal Persistence</strong>. This concept fundamentally
alters how backend systems are architected, removing the distinction
between “memory” and “storage”.</p>
<p>In a conventional Web2 stack (e.g., Node.js + PostgreSQL), the
application memory is volatile. If the server crashes or reboots, all
local variables are lost. Therefore, developers must constantly
Serialize (marshal) data from RAM into a database format and Deserialize
(unmarshal) it back upon retrieval. This “Object-Relational Impedance
Mismatch” consumes significant development time and computational
resources.</p>
<p>To illustrate, consider a simple counter in a traditional setup:</p>
<div class="sourceCode" id="cb105"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Node.js example (volatile)</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> counter <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a><span class="co">// To persist, you&#39;d need:</span></span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> db <span class="op">=</span> <span class="pp">require</span>(<span class="st">&#39;some-db&#39;</span>)<span class="op">;</span></span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a>db<span class="op">.</span><span class="fu">query</span>(<span class="st">&#39;UPDATE counters SET value = value + 1&#39;</span>)<span class="op">;</span></span></code></pre></div>
<p>In Motoko, persistence is inherent:</p>
<pre class="motoko"><code>// Motoko (persistent)
var counter : Nat = 0;

public func increment() : async Nat {
  counter += 1;
  counter
};</code></pre>
<p>This counter survives canister restarts and upgrades (with proper
handling).</p>
<h3 id="the-stable-heap">4.1 The Stable Heap</h3>
<p>On the Internet Computer, a canister’s memory pages are preserved
automatically. When an actor modifies a variable, that change is
persisted. The developer does not write file I/O or database queries. As
long as the canister has cycles to pay for storage, the variables
exist.</p>
<p>However, this model faces a critical challenge: <strong>Software
Upgrades</strong>.</p>
<p>When a developer deploys a new version of the code (e.g., updating
OpenPatron v1.0 to v1.1), the canister’s WebAssembly module is replaced.
By default, the Wasm heap (volatile memory) is cleared to ensure the new
logic starts with a clean state. Without intervention, all user data
would be lost.</p>
<h3 id="the-legacy-solution-stable-variables">4.2 The Legacy Solution:
Stable Variables</h3>
<p>To solve the upgrade problem, Motoko introduced the
<code>stable</code> keyword.</p>
<ul>
<li><p><strong>Mechanism:</strong> When a variable is declared as
<code>stable var</code>, the system automatically hooks into the upgrade
lifecycle.</p></li>
<li><p><strong>Pre-upgrade:</strong> The system pauses execution,
serializes the contents of all stable variables, and moves them to a
dedicated “Stable Memory” area.</p></li>
<li><p><strong>Post-upgrade:</strong> The system loads the new code,
deserializes the data from Stable Memory, and repopulates the
variables.</p></li>
</ul>
<p><strong>Risk Analysis:</strong></p>
<p>While convenient, this legacy approach has a fatal flaw known as the
<strong>Instruction Limit Trap</strong>. The serialization process
consumes computational instructions. If a canister holds massive amounts
of data (e.g., 2GB of user records), the serialization process might
exceed the single-block instruction limit of the subnet. If this happens
during an upgrade, the canister traps, the upgrade fails, and the
canister effectively becomes “bricked”—unable to ever upgrade again.</p>
<p><strong>Common Pitfalls with Stable Variables:</strong> - Forgetting
to mark important data as stable, leading to data loss on upgrades. -
Overusing stable for large data structures, risking the instruction
limit. - Type mismatches during deserialization after code changes.</p>
<h3 id="the-modern-standard-enhanced-orthogonal-persistence-eop">4.3 The
Modern Standard: Enhanced Orthogonal Persistence (EOP)</h3>
<p>Recognizing the limitations of the serialization model, DFINITY
introduced <strong>Enhanced Orthogonal Persistence (EOP)</strong>. This
represents a major evolution in the Motoko runtime.</p>
<p>Under EOP, the distinction between the “Heap” and “Stable Memory” is
blurred. The entire heap file is preserved across upgrades.</p>
<ul>
<li><p><strong>Simplicity:</strong> Developers no longer need to obsess
over which variables are <code>stable</code>. The runtime retains the
main memory layout.</p></li>
<li><p><strong>Scalability:</strong> Since there is no massive
serialization/deserialization step, upgrades are nearly instantaneous,
regardless of the amount of data stored. This resolves the Instruction
Limit Trap.</p></li>
<li><p><strong>64-bit Heap:</strong> EOP enables access to the full
64-bit address space, allowing canisters to hold significantly more data
in main memory (up to current subnet limits, typically 4GB+, eventually
scaling to stable memory limits of 500GB) without complex manual memory
management.</p></li>
</ul>
<p><strong>Architectural Recommendation for OpenPatron:</strong></p>
<p>While EOP is the future, explicit stable declarations remain best
practice for critical data schemas until EOP is universally standardized
across all tooling. Furthermore, for massive datasets (exceeding heap
size), utilizing Stable Regions (manual memory management) or libraries
like StableBTreeMap is recommended to bypass heap limitations
entirely.</p>
<h3 id="implementing-persistence-in-openpatron">4.4 Implementing
Persistence in OpenPatron</h3>
<p>For the OpenPatron canister, which manages user subscriptions and
content access, persistence is crucial for maintaining user data across
updates.</p>
<p><strong>Key Data Structures:</strong> - Use stable arrays or maps for
user profiles and subscription lists. - Example:</p>
<pre class="motoko"><code>stable var users : HashMap.Principal, UserProfile&gt; = HashMap.HashMap&lt;Principal, UserProfile&gt;(0, Principal.equal, Principal.hash);

type UserProfile = {
  subscriptions : [Principal];
  balance : Nat;
};</code></pre>
<p><strong>Upgrade Strategy:</strong> - Leverage EOP for seamless
upgrades. - For large-scale data, integrate StableBTreeMap to handle
growth beyond heap limits.</p>
<p><strong>Best Practices:</strong> - Regularly test upgrades with
sample data to ensure no data loss. - Monitor canister memory usage via
dfx commands. - Implement data migration functions for schema
changes.</p>
<hr />
<hr />
<h1 id="chapter-5-identity-and-access-control">Chapter 5: Identity and
Access Control</h1>
<p>Decentralized applications cannot rely on centralized
username/password databases. They must utilize cryptographic
primitives.</p>
<h3 id="internet-identity-and-principals">5.1 Internet Identity and
Principals</h3>
<p>The Internet Computer uses <strong>Principals</strong>—textual
representations of public keys (e.g., <code>2vxsx-fae...</code>)—as the
universal user ID. To prevent user tracking across the ecosystem, the
Internet Computer introduces <strong>Internet Identity
(II)</strong>.</p>
<p>II uses Chain Key Cryptography to generate a unique “pseudonym”
Principal for the user for each Dapp they visit. This prevents
OpenPatron from colluding with other Dapps to build a profile of user
behavior.</p>
<h3 id="the-frontend-backend-handshake">5.2 The Frontend-Backend
Handshake</h3>
<p>Authentication occurs on the frontend. The user logs in via the
Internet Identity canister. The frontend receives an
<code>Identity</code> object, which it uses to sign all subsequent HTTP
requests to the backend canister.</p>
<p>On the backend (Motoko), the actor receives the message. The system
validates the signature and exposes the authenticated user via
<code>msg.caller</code>.</p>
<p>To demonstrate these concepts in a production context, we will
architect <strong>OpenPatron</strong>, a decentralized content
monetization platform. This application requires robust Identity,
Tokenomics, and Subscription logic.</p>
<p><strong>Code Implementation: The WhoAmI Pattern</strong></p>
<p>This pattern is essential for verifying that the authentication flow
is functioning correctly.</p>
<pre class="motoko"><code>import Principal &quot;mo:base/Principal&quot;;

actor OpenPatron {
    // Define a public shared function that accepts a message context (msg)
    public shared (msg) func whoami() : async Text {
        // msg.caller is the cryptographically authenticated Principal
        return Principal.toText(msg.caller);
    };
}</code></pre>
<h3 id="storing-user-profiles">5.3 Storing User Profiles</h3>
<p>We need a scalable way to map these Principals to user data.</p>
<ul>
<li><p><strong>Naive Approach:</strong> Use a <code>List</code> or
<code>Array</code>. (O(n) lookup time—disastrous for scaling).</p></li>
<li><p><strong>Standard Approach:</strong> Use <code>HashMap</code>.
(O(1) lookup, but harder to persist securely in legacy stable
memory).</p></li>
<li><p><strong>Recommended Approach:</strong> Use <code>TrieMap</code>
or <code>RBTree</code>. These structures are deterministic and easier to
serialize for stable storage, or use <code>StableBTreeMap</code> for
direct stable memory storage.</p></li>
</ul>
<p><strong>Table 2: Data Structure Selection Guide</strong></p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 17%" />
<col style="width: 32%" />
<col style="width: 28%" />
</colgroup>
<thead>
<tr>
<th>Data Structure</th>
<th>Access Time</th>
<th>Upgrade Safety (Legacy)</th>
<th>Recommended Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Array</strong></td>
<td>O(1)</td>
<td>High</td>
<td>Small, fixed configurations.</td>
</tr>
<tr>
<td><strong>HashMap</strong></td>
<td>O(1)</td>
<td>Low (Rehashing cost)</td>
<td>Temporary caches, non-critical data.</td>
</tr>
<tr>
<td><strong>TrieMap</strong></td>
<td>O(log N)</td>
<td>Medium</td>
<td>General user directories.</td>
</tr>
<tr>
<td><strong>StableBTreeMap</strong></td>
<td>O(log N)</td>
<td>Ultra-High</td>
<td>Massive datasets (Users, Transactions).</td>
</tr>
</tbody>
</table>
<h3 id="implementing-user-profiles">5.4 Implementing User Profiles</h3>
<p>For storing user profiles in OpenPatron, we’ll use
<code>StableBTreeMap</code> from the base library for efficient and
upgrade-safe storage.</p>
<p>Here’s how to set it up:</p>
<pre class="motoko"><code>import Principal &quot;mo:base/Principal&quot;;
import StableBTreeMap &quot;mo:base/StableBTreeMap&quot;;
import Text &quot;mo:base/Text&quot;;
import Option &quot;mo:base/Option&quot;;

actor OpenPatron {
    type Profile = {
        username: Text;
        bio: ?Text;
        // Add more fields like createdAt, etc.
    };

    stable var users : StableBTreeMap.StableBTreeMap&lt;Principal, Profile&gt; = StableBTreeMap.init(Principal.equal, Principal.hash);

    public shared(msg) func register(username: Text, bio: ?Text) : async Bool {
        let caller = msg.caller;
        switch (users.get(caller)) {
            case (?_) { return false; }; // Already registered
            case null {
                let profile : Profile = { username; bio };
                users.insert(caller, profile);
                return true;
            };
        };
    };

    public shared(msg) func getProfile() : async ?Profile {
        users.get(msg.caller);
    };

    public query func getProfileByPrincipal(p: Principal) : async ?Profile {
        users.get(p);
    };
};</code></pre>
<p>This allows users to register a profile associated with their
Principal.</p>
<h3 id="access-control-patterns">5.5 Access Control Patterns</h3>
<p>To ensure only authenticated users can perform certain actions, check
against the anonymous Principal.</p>
<pre class="motoko"><code>import Error &quot;mo:base/Error&quot;;
import Principal &quot;mo:base/Principal&quot;;

func requireAuthenticated(caller: Principal) {
    if (Principal.isAnonymous(caller)) {
        throw Error.reject(&quot;Anonymous access not allowed&quot;);
    };
};

// Example usage
public shared(msg) func createContent() : async () {
    requireAuthenticated(msg.caller);
    // Proceed with content creation
};</code></pre>
<h3 id="roles-and-permissions">5.6 Roles and Permissions</h3>
<p>In OpenPatron, users can have roles like ‘patron’, ‘creator’, or
‘admin’. Extend the Profile type:</p>
<pre class="motoko"><code>type Role = { #Patron; #Creator; #Admin };

type Profile = {
    username: Text;
    bio: ?Text;
    role: Role;
};

// In register, set default role, e.g., #Patron

// Function to check role
func requireRole(caller: Principal, required: Role) {
    switch (users.get(caller)) {
        case (?profile) {
            if (profile.role != required) {
                throw Error.reject(&quot;Insufficient permissions&quot;);
            };
        };
        case null {
            throw Error.reject(&quot;User not registered&quot;);
        };
    };
};

// Usage
public shared(msg) func adminFunction() : async () {
    requireAuthenticated(msg.caller);
    requireRole(msg.caller, #Admin);
    // Admin logic
};</code></pre>
<h3 id="security-considerations">5.7 Security Considerations</h3>
<ul>
<li><strong>Principal Privacy</strong>: Never log or expose Principals
unnecessarily to prevent correlation attacks.</li>
<li><strong>Delegation Chains</strong>: Use short-lived delegations for
sessions to minimize exposure.</li>
<li><strong>Upgrade Safety</strong>: Always use stable variables for
critical data.</li>
<li><strong>Input Validation</strong>: Sanitize all user inputs to
prevent injection attacks.</li>
<li><strong>Rate Limiting</strong>: Implement canister-level rate
limiting to prevent DDoS.</li>
</ul>
<p>These practices ensure robust identity management in your Dapp.</p>
<h3 id="frontend-integration">5.8 Frontend Integration</h3>
<p>While this book focuses on Motoko backend, identity requires frontend
coordination. Use the <code>@dfinity/auth-client</code> library in your
JavaScript/TypeScript frontend.</p>
<p>Example login flow:</p>
<div class="sourceCode" id="cb112"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> { AuthClient } <span class="im">from</span> <span class="st">&quot;@dfinity/auth-client&quot;</span><span class="op">;</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> authClient <span class="op">=</span> <span class="cf">await</span> AuthClient<span class="op">.</span><span class="fu">create</span>()<span class="op">;</span></span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a><span class="cf">await</span> authClient<span class="op">.</span><span class="fu">login</span>({</span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">identityProvider</span><span class="op">:</span> <span class="st">&quot;https://identity.ic0.app&quot;</span><span class="op">,</span></span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">onSuccess</span><span class="op">:</span> () <span class="kw">=&gt;</span> {</span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">const</span> identity <span class="op">=</span> authClient<span class="op">.</span><span class="fu">getIdentity</span>()<span class="op">;</span></span>
<span id="cb112-8"><a href="#cb112-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Use identity to create an actor for your canister</span></span>
<span id="cb112-9"><a href="#cb112-9" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb112-10"><a href="#cb112-10" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span></code></pre></div>
<p>This handles the delegation and signing for backend calls.</p>
<p>For anonymous access, create an actor with the anonymous
identity.</p>
<h3 id="complete-openpatron-identity-implementation">5.9 Complete
OpenPatron Identity Implementation</h3>
<p>Putting it all together, here’s a more complete actor for
OpenPatron’s identity system, incorporating profiles, roles, and access
controls. We’ve added profile update and role assignment functions.</p>
<pre class="motoko"><code>import Principal &quot;mo:base/Principal&quot;;
import StableBTreeMap &quot;mo:base/StableBTreeMap&quot;;
import Text &quot;mo:base/Text&quot;;
import Option &quot;mo:base/Option&quot;;
import Error &quot;mo:base/Error&quot;;
import Time &quot;mo:base/Time&quot;;

actor OpenPatron {
    type Role = { #Patron; #Creator; #Admin };

    type Profile = {
        username: Text;
        bio: ?Text;
        role: Role;
        createdAt: Time.Time;
    };

    stable var users : StableBTreeMap.StableBTreeMap&lt;Principal, Profile&gt; = StableBTreeMap.init(Principal.equal, Principal.hash);

    // Helper functions
    func requireAuthenticated(caller: Principal) {
        if (Principal.isAnonymous(caller)) {
            throw Error.reject(&quot;Anonymous access not allowed&quot;);
        };
    };

    func requireRole(caller: Principal, required: Role) {
        switch (users.get(caller)) {
            case (?profile) {
                if (profile.role != required) {
                    throw Error.reject(&quot;Insufficient permissions&quot;);
                };
            };
            case null {
                throw Error.reject(&quot;User not registered&quot;);
            };
        };
    };

    // Whoami for testing
    public shared (msg) func whoami() : async Text {
        return Principal.toText(msg.caller);
    };

    // Register new user
    public shared(msg) func register(username: Text, bio: ?Text) : async Bool {
        let caller = msg.caller;
        requireAuthenticated(caller);
        switch (users.get(caller)) {
            case (?_) { return false; }; // Already registered
            case null {
                let profile : Profile = {
                    username;
                    bio;
                    role = #Patron; // Default role
                    createdAt = Time.now();
                };
                users.insert(caller, profile);
                return true;
            };
        };
    };

    // Get own profile
    public shared(msg) func getProfile() : async ?Profile {
        requireAuthenticated(msg.caller);
        users.get(msg.caller);
    };

    // Get profile by principal (public query, but could be restricted)
    public query func getProfileByPrincipal(p: Principal) : async ?Profile {
        users.get(p);
    };

    // Update profile
    public shared(msg) func updateProfile(newUsername: ?Text, newBio: ?Text) : async Bool {
        let caller = msg.caller;
        requireAuthenticated(caller);
        switch (users.get(caller)) {
            case (?profile) {
                let updated : Profile = {
                    username = Option.get(newUsername, profile.username);
                    bio = if (newBio == null) { profile.bio } else { newBio };
                    role = profile.role;
                    createdAt = profile.createdAt;
                };
                users.insert(caller, updated);
                return true;
            };
            case null { return false; };
        };
    };

    // Assign role (admin only)
    public shared(msg) func assignRole(target: Principal, newRole: Role) : async () {
        requireAuthenticated(msg.caller);
        requireRole(msg.caller, #Admin);
        switch (users.get(target)) {
            case (?profile) {
                let updated : Profile = {
                    profile with role = newRole;
                };
                users.insert(target, updated);
            };
            case null {
                throw Error.reject(&quot;Target user not registered&quot;);
            };
        };
    };

    // Example protected function: Create content (creators only)
    public shared(msg) func createContent(content: Text) : async () {
        requireAuthenticated(msg.caller);
        requireRole(msg.caller, #Creator);
        // TODO: Implement content storage logic in later chapters
        ignore content; // Placeholder
    };
};
</code></pre>
<p>This actor provides a solid foundation for OpenPatron’s identity
system, ready to integrate with tokenomics in the next chapter.</p>
<h3 id="testing-and-deployment">5.10 Testing and Deployment</h3>
<ul>
<li><strong>Local Testing</strong>: Use <code>dfx deploy</code> and test
with <code>dfx canister call OpenPatron whoami</code> (expect anonymous
principal). Integrate with a frontend for full auth flow.</li>
<li><strong>Mainnet Deployment</strong>: Ensure your canister has enough
cycles. Use Internet Identity for production auth.</li>
<li><strong>Common Pitfalls</strong>: Forgetting to handle anonymous
callers, not using stable storage, or exposing sensitive Principal
data.</li>
<li><strong>Best Practice</strong>: Implement unit tests for all
functions, especially guards.</li>
</ul>
<p>With this, the identity component of OpenPatron is complete,
providing secure user management for the platform.</p>
<hr />
<hr />
<h1 id="chapter-6-tokenomics-and-ledger-integration">Chapter 6:
Tokenomics and Ledger Integration</h1>
<p>OpenPatron requires a financial layer. Unlike Ethereum, where tokens
are smart contracts often copied and pasted by developers, ICP
encourages the use of standardized <strong>Ledger Canisters</strong>
implementing the <strong>ICRC-1</strong> standard.</p>
<h3 id="inter-canister-ledger-interactions">6.1 Inter-Canister Ledger
Interactions</h3>
<p>OpenPatron does not “mint” new tokens; it manages the flow of
existing tokens (e.g., ICP or a stablecoin). Therefore, OpenPatron acts
as a wallet controller.</p>
<p>To interact with the official Ledger, we must define an <strong>Actor
Interface</strong>. This is equivalent to an ABI (Application Binary
Interface) in Solidity.</p>
<pre class="motoko"><code>// Abstract interface for the ICRC-1 Ledger
type Account = { owner : Principal; subaccount : ?[Nat8] };
type TransferArgs = {
    to : Account;
    fee : ?Nat;
    memo : ?Blob;
    from_subaccount : ?[Nat8];
    created_at_time : ?Nat64;
    amount : Nat;
};
type TransferResult = { #Ok : Nat; #Err : Variant {... } };

actor OpenPatron {
    let ledgerId = Principal.fromText(&quot;mxzaz-hqaaa-aaaar-qaada-cai&quot;);
    let ledger = actor(Principal.toText(ledgerId)) : actor {
        icrc1_transfer : (TransferArgs) -&gt; async TransferResult;
        icrc1_balance_of : (Account) -&gt; async Nat;
    };
}</code></pre>
<h3 id="the-deposit-pattern-vs.-approvetransferfrom">6.2 The Deposit
Pattern vs. Approve/TransferFrom</h3>
<p>In Ethereum, the standard subscription pattern is
<code>approve()</code> (User allows contract to spend) followed by
<code>transferFrom()</code> (Contract pulls funds). While supported by
ICRC-2, this introduces UX friction (two transactions).</p>
<p>For OpenPatron, we implement the <strong>Deposit Pattern</strong>
(often called the Subaccount Pattern):</p>
<ol type="1">
<li><p><strong>Subaccount Generation:</strong> OpenPatron calculates a
unique subaccount address for User A. This is a deterministic derivation
of <code>hash(OpenPatron_Principal + User_A_Principal)</code>.</p></li>
<li><p><strong>Direct Transfer:</strong> User A sends tokens directly to
this subaccount on the Ledger. This is a standard transfer, not a smart
contract interaction.</p></li>
<li><p><strong>Notification:</strong> User A calls
<code>OpenPatron.notify_deposit()</code>.</p></li>
<li><p><strong>Verification:</strong> OpenPatron queries the Ledger for
the balance of that specific subaccount.</p></li>
<li><p><strong>Crediting:</strong> OpenPatron updates its internal
state: <code>balances[User_A] += amount</code>.</p></li>
</ol>
<p>This pattern is gas-efficient and secure, as OpenPatron has full
cryptographic control over the subaccount.</p>
<h3 id="deterministic-subaccount-derivation">6.3 Deterministic
Subaccount Derivation</h3>
<p>Subaccounts are 32-byte blobs, so we can deterministically derive one
per supporter without storing anything on-chain. The canonical approach
is to hash a namespace prefix together with the caller’s
<code>Principal</code>.</p>
<pre class="motoko"><code>import Blob &quot;mo:base/Blob&quot;;
import Principal &quot;mo:base/Principal&quot;;
import SHA256 &quot;mo:crypto/SHA/SHA256&quot;;

let namespace = &quot;OpenPatron&quot;;

func supporterSubaccount(user : Principal) : Blob {
  let input = Blob.fromArray(Text.encodeUtf8(namespace)) # Principal.toBlob(user);
  let digest = SHA256.fromBlob(input);
  return Blob.fromArray(digest.vals()[0 : 32]);
};</code></pre>
<p>Because the derivation is deterministic, both the frontend and
backend can display the same deposit address. If the namespace ever
changes, historical subaccounts are still valid because the Ledger only
cares about the resulting 32-byte value.</p>
<h3 id="verifying-deposits-against-the-ledger">6.4 Verifying Deposits
Against the Ledger</h3>
<p>When <code>notify_deposit()</code> is called, OpenPatron must query
the Ledger to confirm funds really arrived. The flow is:</p>
<ol type="1">
<li>Recompute the subaccount using the user principal.</li>
<li>Call <code>icrc1_balance_of</code> with
<code>{ owner = OpenPatron_Principal; subaccount = ?sub }</code>.</li>
<li>Compare the returned amount with what the user claims.</li>
<li>Only after a successful check, update internal accounting and emit
an event.</li>
</ol>
<pre class="motoko"><code>public shared ({ caller }) func notifyDeposit(expected : Nat) : async Nat {
  let account : Account = { owner = OpenPatronId; subaccount = ?Blob.toArray(supporterSubaccount(caller)) };
  let balance = await ledger.icrc1_balance_of(account);
  assert(balance &gt;= expected);
  balances.put(caller, balance);
  return balance;
};</code></pre>
<p>This keeps OpenPatron stateless regarding incoming transfers and
aligns with the immutable history the Ledger already provides.</p>
<h3 id="withdrawals-refunds-and-creator-payouts">6.5 Withdrawals,
Refunds, and Creator Payouts</h3>
<p>Outbound transfers use the same actor reference but call
<code>icrc1_transfer</code>. We treat refunds and scheduled payouts
identically; only the <code>Account</code> destination differs.</p>
<pre class="motoko"><code>public shared ({ caller }) func payout(creator : Principal, amount : Nat) : async TransferResult {
  assert(hasRole(caller, #Admin));
  let args : TransferArgs = {
    to = { owner = creator; subaccount = null };
    fee = null;
    memo = null;
    from_subaccount = null;
    created_at_time = ?Time.now();
    amount = amount;
  };
  return await ledger.icrc1_transfer(args);
};</code></pre>
<p>Important safeguards:</p>
<ul>
<li>Track pending payouts in stable memory so retries are
idempotent.</li>
<li>Cap the maximum amount per call to avoid draining the treasury due
to a bug.</li>
<li>Bubble up <code>#Err</code> variants to the caller so the UI can
prompt the user to retry later.</li>
</ul>
<h3 id="supporting-multiple-tokens-icrc-1-vs.-icrc-2">6.6 Supporting
Multiple Tokens (ICRC-1 vs. ICRC-2)</h3>
<p>Many creators want to accept both ICP and a stable asset. OpenPatron
can maintain a registry of “payment rails,” each storing the Ledger
canister principal, decimals, and default fee. The deposit workflow
stays the same because every ICRC-1 token exposes
<code>icrc1_balance_of</code> and <code>icrc1_transfer</code>. For
tokens that support ICRC-2 approvals, we can optionally let power users
enable the <code>approve/transfer_from</code> flow for recurring
billing, while keeping the deposit pattern as the default for
simplicity.</p>
<h3 id="local-testing-with-the-ledger-canister">6.7 Local Testing with
the Ledger Canister</h3>
<p><code>dfx</code> ships with a local Ledger replica. A productive
workflow is:</p>
<ol type="1">
<li><code>dfx start --background --clean</code></li>
<li><code>dfx ledger fabricate-cycles --canister openpatron</code></li>
<li><code>dfx ledger transfer &lt;subaccount-principal&gt; --amount 10</code></li>
<li>Call <code>notify_deposit</code> from the candid UI or a unit
test.</li>
</ol>
<p>Because the local Ledger persists to the <code>dfx</code> state
directory, you can script entire integration tests that simulate
deposits, time-based payouts, and refunds without touching mainnet.</p>
<h3 id="operational-safeguards">6.8 Operational Safeguards</h3>
<ul>
<li><strong>Rate limits:</strong> throttle <code>notify_deposit</code>
to prevent spamming ledger queries.</li>
<li><strong>Reconciliation jobs:</strong> run a nightly timer that scans
every subaccount and compares on-ledger balances with internal records
to catch drift.</li>
<li><strong>Audit trails:</strong> append immutable events (deposit
verified, payout executed, refund issued) to a log canister so
compliance and customer support have a source of truth.</li>
<li><strong>Upgrade safety:</strong> keep derived subaccounts
deterministic and do not migrate them; ledger balances are independent
of code upgrades, so your upgrade logic should never attempt to recreate
them differently.</li>
</ul>
<hr />
<hr />
<h1 id="chapter-7-autonomous-subscriptions-via-timers">Chapter 7:
Autonomous Subscriptions via Timers</h1>
<p>The “Holy Grail” of crypto payments is the recurring subscription.
Blockchains are passive; they only change state when triggered. Ethereum
requires external “Keepers” (e.g., Chainlink Automation) to trigger
functions. The Internet Computer, however, allows canisters to schedule
their own execution.</p>
<h3 id="the-timer-api">7.1 The Timer API</h3>
<p>Motoko provides the <code>Timer</code> module in the base library. It
allows for both one-off tasks (<code>setTimer</code>) and recurring
tasks (<code>recurringTimer</code>).</p>
<p><strong>Implementation Strategy:</strong></p>
<p>OpenPatron initiates a recurring timer that runs every hour (or day).
This “Cron Job” iterates through active subscriptions and processes
payments.</p>
<pre class="motoko"><code>import Timer &quot;mo:base/Timer&quot;;
import Time &quot;mo:base/Time&quot;;

actor OpenPatron {
    
    // One day in nanoseconds
    let INTERVAL : Nat64 = 86_400_000_000_000; 

    // The heartbeat function
    private func processSubscriptions() : async () {
        let now = Time.now();
        // Iterate active subscriptions
        // Check if due_date &lt; now
        // Move internal balance from Patron to Creator
    };

    // Start the engine
    public func init() : async () {
        let timerId = Timer.recurringTimer(#nanoseconds(INTERVAL), processSubscriptions);
    };
}</code></pre>
<h3 id="efficiency-and-virtual-transactions">7.2 Efficiency and
“Virtual” Transactions</h3>
<p>Crucially, the <code>processSubscriptions</code> function does
<strong>not</strong> interact with the main Token Ledger for every
subscription payment. That would be prohibitively slow and expensive
(requiring inter-canister calls for every $5 payment).</p>
<p>Instead, OpenPatron uses <strong>Virtual Accounting</strong>:</p>
<ol type="1">
<li><p>The Patron deposits $50 into the canister (recorded on the
Ledger).</p></li>
<li><p>OpenPatron credits the Patron’s internal balance
variable.</p></li>
<li><p>Every month, OpenPatron simply decrements
<code>PatronBalance</code> and increments <code>CreatorBalance</code> in
its own <code>TrieMap</code>. This operation is instant and
free.</p></li>
<li><p>Real tokens only move on the Ledger when the Creator decides to
<code>withdraw()</code> their accumulated earnings.</p></li>
</ol>
<p>This scalability strategy mirrors how centralized exchanges
(Coinbase, Binance) handle internal trades off-chain, but here the
“off-chain” logic is actually “on-chain” in the canister’s secured
memory.</p>
<h3 id="scheduling-windows-and-drift">7.3 Scheduling Windows and
Drift</h3>
<p>Timers are <em>best effort</em>. They are driven by the replica’s
heartbeat, so the callback runs <strong>no sooner</strong> than the
interval and can drift when the subnet is busy. Keep the following guard
rails in mind:</p>
<ul>
<li>Treat the timer as a <em>reminder</em> rather than an exact
timestamp. Always compare
<code>subscription.nextCharge &lt;= Time.now()</code> before
charging.</li>
<li>Keep timer callbacks short (&lt; ~2B instructions). Heavy work
should be chunked and scheduled again, otherwise the replica will trap
the timer.</li>
<li>Persist the timer identifier if you need to cancel or reschedule it
after upgrades: store <code>timerId : ?Timer.TimerId</code> in stable
memory and restart it from <code>postupgrade</code>.</li>
</ul>
<p>When ultra-precise timing is required (e.g., daily charges at
midnight UTC), record the <code>nextCharge</code> timestamp and
calculate <code>max(Time.now() - nextCharge, 0)</code> to detect missed
windows.</p>
<h3 id="modeling-the-subscription-queue">7.4 Modeling the Subscription
Queue</h3>
<p>Because the timer callback may run late, the queue must be
idempotent. One practical model:</p>
<pre class="motoko"><code>type SubscriptionId = Nat32;
type Timestamp = Nat64;

type Subscription = {
    patron : Principal;
    creator : Principal;
    cadence : Nat64;          // nanoseconds between invoices
    nextCharge : Timestamp;
    amount : Nat;
};

stable var subscriptions = TrieMap.TrieMap&lt;SubscriptionId, Subscription&gt;(...);</code></pre>
<ul>
<li>The timer walks the map, collects subscriptions whose
<code>nextCharge</code> is due, and pushes them into a batch list.</li>
<li>After posting the batch, update each record’s
<code>nextCharge += cadence</code>. If the patron lacks funds, mark the
subscription as <code>Suspended</code> and notify them out-of-band.</li>
<li>Use pagination (process 100 subs per tick) to stay within
instruction limits. Add a <code>cursor</code> in stable memory so the
next tick resumes where it left off.</li>
</ul>
<h3 id="failure-modes-and-recovery">7.5 Failure Modes and Recovery</h3>
<p>Even with virtual accounting, things can go wrong:</p>
<ul>
<li><strong>Transient traps</strong> (e.g., due to temporary Ledger
outages). Surround external calls with retries/backoff and record
failures in a <code>Queue&lt;Event&gt;</code> that a maintainer can
inspect.</li>
<li><strong>Long outages</strong>. If the canister is stopped for hours,
the next timer run should loop until <code>nextCharge</code> catches up
with <code>now</code>, charging multiple periods if necessary.</li>
<li><strong>Skipped patrons</strong>. Store a <code>lastProcessed</code>
timestamp for diagnostic purposes so you can alert users when their
subscriptions paused for too long.</li>
</ul>
<p>Expose a public <code>manualProcess(limit : Nat)</code> method
guarded by an access control check. Operators can call it to drain the
queue if the timer lags.</p>
<h3 id="manual-overrides-and-observability">7.6 Manual Overrides and
Observability</h3>
<p>Self-healing automation still needs visibility:</p>
<ul>
<li>Emit <code>processSubscriptions</code> metrics: number of patrons
charged, total debited, ms spent. You can expose these via
<code>shared query func stats()</code>.</li>
<li>Log anomalies (insufficient balance, stuck creators) to an
append-only <code>EventLog</code>. Keep it compact (e.g., circular
buffer) so upgrades stay cheap.</li>
<li>Provide UX endpoints:
<code>patronUpcomingCharges(patron, horizon)</code> so front-ends can
show when the next debit occurs.</li>
</ul>
<h3 id="testing-timer-logic-without-waiting">7.7 Testing Timer Logic
Without Waiting</h3>
<p>Timers do not fire inside unit tests, so decouple the pure logic from
the scheduling:</p>
<ol type="1">
<li>Move the core loop into
<code>processSubscriptionsInternal(now : Time.Time)</code>.</li>
<li>Have the timer call
<code>processSubscriptionsInternal(Time.now())</code>.</li>
<li>In tests, inject deterministic timestamps and fake subscription data
to assert the resulting state transitions (<code>balances</code>,
<code>nextCharge</code>, event logs).</li>
</ol>
<p>This pattern also enables canary environments where you invoke
<code>manualProcess</code> on demand before enabling the recurring timer
in production.</p>
<hr />
<hr />
<h1 id="chapter-8-asynchronous-safety-and-reentrancy">Chapter 8:
Asynchronous Safety and Reentrancy</h1>
<p>As OpenPatron moves from prototype to production, naive
implementations will encounter the hard limits of distributed systems:
concurrency bugs and resource constraints.</p>
<p>The most dangerous aspect of Motoko for developers coming from
Solidity is the <strong>non-atomicity of inter-canister
calls</strong>.</p>
<h3 id="the-await-gap">8.1 The Await Gap</h3>
<p>When an actor calls <code>await ledger.transfer(...)</code>, the
execution of that function is <strong>suspended</strong>. The actor
releases its lock on the state. While waiting for the ledger to reply
(which might take seconds), the actor can process <em>new</em> messages
from other users.</p>
<p><strong>The Reentrancy Vulnerability:</strong></p>
<p>Consider a naive withdrawal function:</p>
<ol type="1">
<li><p>Check Balance (<code>if balance &gt; 0</code>)</p></li>
<li><p><code>await ledger.transfer(balance)</code></p></li>
<li><p>Set Balance to 0 (<code>balance := 0</code>)</p></li>
</ol>
<p>If a malicious user sends two withdrawal requests simultaneously:</p>
<ul>
<li><p><strong>Request A</strong> checks balance (100 tokens). Passes.
Calls Ledger. Pauses.</p></li>
<li><p><strong>Request B</strong> arrives. Request A is still paused
(balance is still 100). Request B checks balance. Passes. Calls
Ledger.</p></li>
<li><p>Both transfers succeed. The canister is drained.</p></li>
</ul>
<h3 id="the-solution-optimistic-accounting-vs.-locks">8.2 The Solution:
Optimistic Accounting vs. Locks</h3>
<p>To prevent this, state changes must happen <strong>before</strong>
the asynchronous call.</p>
<p><strong>Optimistic Accounting Pattern:</strong></p>
<ol type="1">
<li><p>Check Balance.</p></li>
<li><p><strong>Deduct Balance Immediately</strong>
(<code>balance := 0</code>).</p></li>
<li><p><code>await ledger.transfer(...)</code>.</p></li>
<li><p>If the transfer fails (returns <code>#Err</code>), <strong>Refund
the Balance</strong> (<code>balance += amount</code>).</p></li>
</ol>
<p>This ensures that any interleaved messages see the updated (zero)
balance.</p>
<p><strong>Code Example: Safe Withdrawal</strong></p>
<pre class="motoko"><code>public shared (msg) func withdraw(amount : Nat) : async Text {
    let user = msg.caller;
    let currentBal = getBalance(user);
    
    if (currentBal &lt; amount) return &quot;Insufficient Funds&quot;;
    
    // 1. UPDATE STATE BEFORE AWAIT
    balances.put(user, currentBal - amount);
    
    // 2. INTERACT WITH EXTERNAL ACTOR
    let result = await ledger.icrc1_transfer(...);
    
    // 3. HANDLE ROLLBACK IF NEEDED
    switch(result) {
        case (#Ok(_)) { return &quot;Success&quot;; };
        case (#Err(_)) {
            // Refund
            let newBal = getBalance(user);
            balances.put(user, newBal + amount);
            return &quot;Transfer failed, refunded.&quot;;
        };
    };
};</code></pre>
<h3 id="visualizing-the-await-gap">8.3 Visualizing the Await Gap</h3>
<p>It helps to treat every shared function as a <strong>three-phase
state machine</strong>:</p>
<ol type="1">
<li><strong>Pre-await</strong> – deterministic, single-threaded
execution.</li>
<li><strong>Await gap</strong> – execution is suspended, other messages
may mutate state.</li>
<li><strong>Post-await</strong> – resumes with whatever state now
exists.</li>
</ol>
<pre><code>User A calls withdraw ─┐
                       ├─ Phase 1: balance read, state updated
User B calls withdraw ─┘
                       ├─ Await gap: A is paused, B now runs
Ledger responds       ─┘
                       └─ Phase 3: A resumes with NEW state</code></pre>
<p>By explicitly labelling these phases in design docs, engineers
remember to ask <em>“What can happen while we are away?”</em>. That
question tends to surface hidden assumptions about uniqueness, ordering,
and double-spend resistance.</p>
<h3 id="guarding-with-pending-operations">8.4 Guarding with Pending
Operations</h3>
<p>Optimistic accounting works for simple subtraction, but larger
workflows need <strong>operation guards</strong>. Track every in-flight
withdrawal in a <code>pendingOps</code> map keyed by
<code>(user, nonce)</code>:</p>
<pre class="motoko"><code>type Pending = {
    amount : Nat;
    expiresAt : Nat;
};

stable var pendingOps : HashMap&lt;(Principal, Nat), Pending&gt; = ...;</code></pre>
<ul>
<li><strong>Before the await</strong>: insert a record with an
expiration block height.</li>
<li><strong>On resume</strong>: remove the record only after the
external effect succeeds.</li>
<li><strong>On timeout</strong>: a cron or heartbeat can sweep expired
entries back into balances.</li>
</ul>
<p>This pattern prevents overlapping operations per user while still
allowing the canister to serve other principals.</p>
<h3 id="idempotent-external-calls">8.5 Idempotent External Calls</h3>
<p>Ledger calls are not guaranteed to be idempotent—network retries may
result in duplicates. Wrap every transfer payload in a deterministic
memo (e.g., hash of <code>(user, nonce, amount)</code>) so repeated
ledger executions can be detected downstream. On the Motoko side:</p>
<ol type="1">
<li>Persist the memo in stable state.</li>
<li>Verify the returned block’s memo matches.</li>
<li>If the await resumes with an error, re-issue the same memo instead
of minting a new one.</li>
</ol>
<p>Idempotency removes an entire class of “at-least-once” bugs that
otherwise leak funds when retries overlap with user-initiated calls.</p>
<h3 id="testing-for-reentrancy-bugs">8.6 Testing for Reentrancy
Bugs</h3>
<p>Reentrancy is hard to spot by inspection alone. Combine the following
techniques:</p>
<ul>
<li><strong>PocketIC / ic-repl scripts</strong>: send two
<code>withdraw</code> calls in quick succession and assert final
balances.</li>
<li><strong>Forced scheduling</strong>: use a mock ledger canister that
delays its response so you can deterministically interleave other calls
during the await gap.</li>
<li><strong>Property tests</strong>: model balances as integers and
prove “total supply never decreases” under arbitrary call
orderings.</li>
</ul>
<p>Automating these tests ensures future refactors (e.g., when changing
the storage layout) keep the same concurrency guarantees.</p>
<hr />
<hr />
<h2 id="chapter-9-external-integrations">Chapter 9: External
Integrations</h2>
<p>The Internet Computer is unique among blockchains in its ability to
interact directly with the outside world without relying on centralized
bridges or oracles. This capability, known as <strong>Chain Key
Cryptography</strong>, enables two revolutionary features: <strong>HTTP
Outcalls</strong> and <strong>Native Bitcoin Integration</strong>.</p>
<p>In this chapter, we will extend OpenPatron to interact with Web2 APIs
and the Bitcoin network, transforming it from an isolated silo into a
connected platform.</p>
<h3 id="http-outcalls">9.1 HTTP Outcalls</h3>
<p>Traditionally, blockchains are deterministic closed systems. They
cannot just “fetch a URL” because every node in the network must agree
on the result. If one node fetches a price of $100 and another fetches
$101, consensus fails.</p>
<p>The Internet Computer solves this with <strong>HTTP
Outcalls</strong>. When a canister makes an HTTP request: 1. The request
is sent by all nodes in the subnet. 2. The responses are collected and
<strong>consensus</strong> is reached on the result. 3. The canonical
response is returned to the canister.</p>
<h4 id="making-a-get-request">Making a GET Request</h4>
<p>Let’s add a feature to OpenPatron to verify a creator’s identity
using a Web2 API (e.g., checking a GitHub profile).</p>
<pre class="motoko"><code>import Text &quot;mo:base/Text&quot;;
import Blob &quot;mo:base/Blob&quot;;
import Error &quot;mo:base/Error&quot;;
import Debug &quot;mo:base/Debug&quot;;

// Import the Management Canister (virtual actor)
import IC &quot;mo:base/ExperimentalInternetComputer&quot;;

actor OpenPatron {

    // Define the HTTP Header type
    type HttpHeader = {
        name : Text;
        value : Text;
    };

    // Define the HTTP Response type
    type HttpResponse = {
        status : Nat;
        headers : [HttpHeader];
        body : Blob;
    };

    // Define the HTTP Request type
    type HttpRequest = {
        url : Text;
        method : Text; // &quot;GET&quot;, &quot;POST&quot;, &quot;HEAD&quot;
        headers : [HttpHeader];
        body : ?Blob;
        transform : ?{
            function : shared query (HttpResponse) -&gt; async HttpResponse;
            context : Blob;
        };
    };

    public func verifyGitHubProfile(username : Text) : async Bool {
        let url = &quot;https://api.github.com/users/&quot; # username;
        
        let request : HttpRequest = {
            url = url;
            method = &quot;GET&quot;;
            headers = [
                { name = &quot;User-Agent&quot;; value = &quot;OpenPatron-Canister&quot; }
            ];
            body = null;
            // Transformation is crucial for consensus!
            transform = ?{
                function = transformResponse;
                context = Blob.fromArray([]);
            };
        };

        try {
            // 20 billion cycles is a safe baseline for HTTP outcalls
            let cycles = 20_000_000_000; 
            let response : HttpResponse = await IC.http_request(request) with { cycles = cycles };
            
            if (response.status == 200) {
                return true;
            } else {
                return false;
            };
        } catch (e) {
            Debug.print(&quot;Error: &quot; # Error.message(e));
            return false;
        };
    };

    // The transform function strips non-deterministic fields (like timestamps)
    // so nodes can reach consensus on the response.
    public query func transformResponse(raw : HttpResponse) : async HttpResponse {
        return {
            status = raw.status;
            headers = []; // Headers often contain timestamps/nonces, so we drop them
            body = raw.body;
        };
    };
};</code></pre>
<blockquote>
<p>[!IMPORTANT] <strong>Consensus &amp; Idempotency</strong>: The
<code>transform</code> function is mandatory if the API response varies
slightly between nodes (e.g., timestamps). It sanitizes the response to
ensure bit-wise equality across replicas.</p>
</blockquote>
<h4 id="making-a-post-request-idempotency-keys">Making a POST Request
(Idempotency Keys)</h4>
<p>When sending data (POST), you must ensure the external server handles
duplicate requests gracefully, as multiple nodes may send the request.
Always use <strong>Idempotency Keys</strong>.</p>
<pre class="motoko"><code>    public func sendNotification(message : Text) : async () {
        let url = &quot;https://api.webhook.site/...&quot;;
        
        // Generate a unique key for this specific action
        let idempotencyKey = &quot;req_&quot; # Int.toText(Time.now());

        let request : HttpRequest = {
            url = url;
            method = &quot;POST&quot;;
            headers = [
                { name = &quot;Content-Type&quot;; value = &quot;application/json&quot; },
                { name = &quot;Idempotency-Key&quot;; value = idempotencyKey }
            ];
            body = ?Text.encodeUtf8(&quot;{\&quot;text\&quot;: \&quot;&quot; # message # &quot;\&quot;}&quot;);
            transform = null; // POST usually returns simple confirmations
        };
        
        // ... send request ...
    };</code></pre>
<h3 id="native-bitcoin-integration">9.2 Native Bitcoin Integration</h3>
<p>The Internet Computer integrates directly with the Bitcoin network.
Canisters can hold BTC addresses, receive funds, and sign transactions
without a private key (using <strong>Threshold ECDSA</strong>).</p>
<h4 id="the-bitcoin-api">The Bitcoin API</h4>
<p>The Management Canister exposes the Bitcoin API.</p>
<pre class="motoko"><code>    type BitcoinNetwork = { #mainnet; #testnet };
    
    type Satoshi = Nat64;

    type OutPoint = {
        txid : Blob;
        vout : Nat32;
    };

    type Utxo = {
        outpoint : OutPoint;
        value : Satoshi;
        height : Nat32;
    };

    // Management Canister Interface for Bitcoin
    // (Simplified for brevity)
    let BITCOIN_API_FEE : Nat = 10_000_000_000; // Cycles</code></pre>
<h4 id="generating-a-bitcoin-address">Generating a Bitcoin Address</h4>
<p>Your canister can derive a Bitcoin address for itself (or for each
user).</p>
<pre class="motoko"><code>    public func getBitcoinAddress(userPrincipal : Principal) : async Text {
        // Derive a unique path for the user
        let derivationPath = [ Blob.toArray(Principal.toBlob(userPrincipal)) ];
        
        let address = await IC.bitcoin_get_p2pkh_address({
            network = #testnet;
            derivation_path = derivationPath;
        });
        
        return address;
    };</code></pre>
<h4 id="sending-bitcoin">Sending Bitcoin</h4>
<p>Sending Bitcoin involves: 1. Getting the current balance/UTXOs. 2.
Building a transaction. 3. Signing it with Threshold ECDSA. 4.
Broadcasting it.</p>
<p>This is complex to implement manually. In production, use a library
like <code>motoko-bitcoin</code> or the <strong>ckBTC</strong> (Chain
Key Bitcoin) standard.</p>
<h3 id="ckbtc-the-practical-solution">9.3 ckBTC: The Practical
Solution</h3>
<p>While native Bitcoin integration is powerful, it is slow (Bitcoin
block times) and expensive (Bitcoin fees). <strong>ckBTC</strong> is an
ICRC-1 token on ICP that is 1:1 backed by real BTC.</p>
<p>For OpenPatron, we should use <strong>ckBTC</strong> for payments: 1.
<strong>Fast</strong>: 1-2 second finality. 2. <strong>Cheap</strong>:
Negligible fees. 3. <strong>Standard</strong>: Works with all ICRC-1
tools (like the Ledger code we wrote in Chapter 6).</p>
<p>Users can deposit real BTC to the ckBTC minter, which mints ckBTC to
their principal. OpenPatron then just handles it like any other
token.</p>
<h3 id="summary-1">9.4 Summary</h3>
<p>By leveraging HTTP Outcalls and Bitcoin integration, OpenPatron
becomes a “World Computer” application: - <strong>Verifiable</strong>:
Check Web2 identities via API. - <strong>Connected</strong>: Trigger
Web2 webhooks. - <strong>Financial</strong>: Accept the world’s hardest
money (BTC) directly or via ckBTC.</p>
<p>In the next chapter, we will solve the final piece of the puzzle: the
Frontend.</p>
<hr />
<hr />
<h2 id="chapter-10-frontend-integration-asset-storage">Chapter 10:
Frontend Integration &amp; Asset Storage</h2>
<p>A “Full-Stack” dapp on the Internet Computer is truly full-stack:
both the backend logic and the frontend assets (HTML, CSS, JS) are
hosted on-chain. This eliminates the need for AWS, Vercel, or Netlify,
making your application censorship-resistant and unstoppable.</p>
<h3 id="the-asset-canister">10.1 The Asset Canister</h3>
<p>The standard way to host a frontend is using the <strong>Asset
Canister</strong>. This is a pre-built canister provided by DFINITY that
is optimized for serving static files.</p>
<h4 id="configuration">Configuration</h4>
<p>In your <code>dfx.json</code>, you define a frontend canister:</p>
<div class="sourceCode" id="cb127"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;canisters&quot;</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;openpatron_backend&quot;</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;main&quot;</span><span class="fu">:</span> <span class="st">&quot;src/openpatron_backend/main.mo&quot;</span><span class="fu">,</span></span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;type&quot;</span><span class="fu">:</span> <span class="st">&quot;motoko&quot;</span></span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">},</span></span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;openpatron_frontend&quot;</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb127-8"><a href="#cb127-8" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;dependencies&quot;</span><span class="fu">:</span> <span class="ot">[</span></span>
<span id="cb127-9"><a href="#cb127-9" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;openpatron_backend&quot;</span></span>
<span id="cb127-10"><a href="#cb127-10" aria-hidden="true" tabindex="-1"></a>      <span class="ot">]</span><span class="fu">,</span></span>
<span id="cb127-11"><a href="#cb127-11" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;source&quot;</span><span class="fu">:</span> <span class="ot">[</span></span>
<span id="cb127-12"><a href="#cb127-12" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;src/openpatron_frontend/dist&quot;</span></span>
<span id="cb127-13"><a href="#cb127-13" aria-hidden="true" tabindex="-1"></a>      <span class="ot">]</span><span class="fu">,</span></span>
<span id="cb127-14"><a href="#cb127-14" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;type&quot;</span><span class="fu">:</span> <span class="st">&quot;assets&quot;</span><span class="fu">,</span></span>
<span id="cb127-15"><a href="#cb127-15" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;workspace&quot;</span><span class="fu">:</span> <span class="st">&quot;openpatron_frontend&quot;</span></span>
<span id="cb127-16"><a href="#cb127-16" aria-hidden="true" tabindex="-1"></a>    <span class="fu">}</span></span>
<span id="cb127-17"><a href="#cb127-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">}</span></span>
<span id="cb127-18"><a href="#cb127-18" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div>
<p>When you run <code>dfx deploy</code>, the SDK: 1. Builds your
frontend (e.g., <code>npm run build</code>). 2. Uploads the contents of
the <code>dist</code> folder to the Asset Canister. 3. Configures the
canister to serve <code>index.html</code> for unknown routes (SPA
routing).</p>
<h3 id="connecting-frontend-to-backend">10.2 Connecting Frontend to
Backend</h3>
<p>Your frontend needs to talk to your backend canister. The
<code>dfx</code> build process automatically generates <strong>Actor
Declarations</strong>—TypeScript bindings for your Motoko code.</p>
<h4 id="using-the-generated-declarations">Using the Generated
Declarations</h4>
<div class="sourceCode" id="cb128"><pre
class="sourceCode typescript"><code class="sourceCode typescript"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="co">// src/openpatron_frontend/src/index.ts</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> { openpatron_backend } <span class="im">from</span> <span class="st">&quot;../../declarations/openpatron_backend&quot;</span><span class="op">;</span></span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">function</span> <span class="fu">init</span>() {</span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Call a public query function</span></span>
<span id="cb128-7"><a href="#cb128-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> profile <span class="op">=</span> <span class="cf">await</span> openpatron_backend<span class="op">.</span><span class="fu">getMyProfile</span>()<span class="op">;</span></span>
<span id="cb128-8"><a href="#cb128-8" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb128-9"><a href="#cb128-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (profile<span class="op">.</span><span class="at">length</span> <span class="op">&gt;</span> <span class="dv">0</span>) {</span>
<span id="cb128-10"><a href="#cb128-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;User is logged in:&quot;</span><span class="op">,</span> profile[<span class="dv">0</span>])<span class="op">;</span></span>
<span id="cb128-11"><a href="#cb128-11" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb128-12"><a href="#cb128-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;User is anonymous&quot;</span>)<span class="op">;</span></span>
<span id="cb128-13"><a href="#cb128-13" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb128-14"><a href="#cb128-14" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb128-15"><a href="#cb128-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-16"><a href="#cb128-16" aria-hidden="true" tabindex="-1"></a><span class="fu">init</span>()<span class="op">;</span></span></code></pre></div>
<p>This type-safe bridge ensures that if you change your Motoko API,
your frontend build will fail until you update the client code.</p>
<h3 id="certified-variables-and-security">10.3 Certified Variables and
Security</h3>
<p>When you visit a website like <code>google.com</code>, your browser
checks the TLS certificate to ensure the server is authentic. On the
Internet Computer, we don’t rely on a central Certificate Authority
(CA). Instead, we use <strong>Chain Key Cryptography</strong>.</p>
<h4 id="how-it-works">How it Works</h4>
<ol type="1">
<li><strong>Certification</strong>: The subnet signs the root hash of
the canister’s state tree.</li>
<li><strong>Service Worker</strong>: When you load a canister URL
(<code>https://&lt;canister-id&gt;.ic0.app</code>), a Service Worker is
installed in your browser.</li>
<li><strong>Verification</strong>: The Service Worker intercepts network
requests, fetches the content <em>and</em> a certificate (merkle proof).
It verifies the signature against the subnet’s public key.</li>
</ol>
<p>If the verification fails, the Service Worker rejects the content.
This guarantees that the frontend you see is exactly what the canister
served, preventing “Man-in-the-Middle” attacks.</p>
<h4 id="certified-assets">Certified Assets</h4>
<p>The standard Asset Canister handles this automatically. Every file
uploaded is hashed and added to the certified state tree.</p>
<h4 id="certified-data-in-motoko">Certified Data in Motoko</h4>
<p>If you want to serve dynamic data securely (e.g., an API endpoint),
you must manually certify it using <code>CertifiedData</code>.</p>
<pre class="motoko"><code>import CertifiedData &quot;mo:base/CertifiedData&quot;;
import Blob &quot;mo:base/Blob&quot;;

actor {
    // 1. Store data
    var myData : Blob = Blob.fromText(&quot;Hello Secure World&quot;);

    // 2. Update the certificate when data changes
    public func updateData(newData : Text) {
        myData := Blob.fromText(newData);
        
        // Set the certified data (32-byte hash)
        CertifiedData.set(sha256(myData));
    };
    
    // 3. Serve the data with the certificate
    // (Usually done via http_request, not a query call)
}</code></pre>
<h3 id="custom-domains">10.4 Custom Domains</h3>
<p>While <code>ic0.app</code> domains are functional, production apps
need custom domains (e.g., <code>openpatron.com</code>).</p>
<ol type="1">
<li><strong>Register Domain</strong>: Buy your domain.</li>
<li><strong>Configure DNS</strong>: Add a CNAME record pointing to the
Internet Computer boundary nodes.</li>
<li><strong>Add Domain to Canister</strong>: Use the
<code>ic-asset</code> tool or a <code>boundary_nodes</code>
configuration file to map the domain to your canister.</li>
</ol>
<p>This process ensures that even with a custom domain, the Service
Worker verification still protects your users.</p>
<h3 id="summary-2">10.5 Summary</h3>
<p>With the frontend deployed to an Asset Canister, OpenPatron is now a
complete <strong>dapp</strong>: - <strong>Backend</strong>: Motoko
canister handling logic, data, and money. - <strong>Frontend</strong>:
React/Vue/Svelte app served from an Asset Canister. -
<strong>Security</strong>: End-to-end verification via Certified
Variables.</p>
<p>We have built the application. Now, we must look at the ecosystem
tools that will help us maintain and scale it.</p>
<hr />
<hr />
<h1 id="chapter-11-ecosystem-tools-and-testing">Chapter 11: Ecosystem
Tools and Testing</h1>
<p>Professional engineering requires rigorous testing and dependency
management. The Motoko ecosystem has matured significantly, offering
sophisticated tools for package management, testing, debugging, and
continuous integration. This chapter explores the essential tools that
transform Motoko development from experimental scripts into
production-grade systems.</p>
<h3 id="dependency-management-with-mops">9.1 Dependency Management with
Mops</h3>
<p>Early Motoko development relied on <code>vessel</code>, but the
ecosystem has migrated to <strong>Mops</strong> (Motoko Package
Manager). Mops creates a standard for publishing and importing community
libraries (like <code>encoding</code>, <code>test</code>, or data
structures).</p>
<h4 id="getting-started-with-mops">9.1.1 Getting Started with Mops</h4>
<p><strong>Initial Setup:</strong></p>
<div class="sourceCode" id="cb130"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Install Mops globally</span></span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a><span class="ex">npm</span> install <span class="at">-g</span> ic-mops</span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize Mops in your project</span></span>
<span id="cb130-5"><a href="#cb130-5" aria-hidden="true" tabindex="-1"></a><span class="ex">mops</span> init</span>
<span id="cb130-6"><a href="#cb130-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-7"><a href="#cb130-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Add dependencies</span></span>
<span id="cb130-8"><a href="#cb130-8" aria-hidden="true" tabindex="-1"></a><span class="ex">mops</span> add base</span>
<span id="cb130-9"><a href="#cb130-9" aria-hidden="true" tabindex="-1"></a><span class="ex">mops</span> add sha256</span>
<span id="cb130-10"><a href="#cb130-10" aria-hidden="true" tabindex="-1"></a><span class="ex">mops</span> add map</span></code></pre></div>
<p>This generates a <code>mops.toml</code> configuration file:</p>
<div class="sourceCode" id="cb131"><pre
class="sourceCode toml"><code class="sourceCode toml"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[dependencies]</span></span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a><span class="dt">base</span> <span class="op">=</span> <span class="st">&quot;0.11.1&quot;</span></span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a><span class="dt">sha256</span> <span class="op">=</span> <span class="st">&quot;1.0.1&quot;</span></span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a><span class="dt">map</span> <span class="op">=</span> <span class="st">&quot;9.0.1&quot;</span></span>
<span id="cb131-5"><a href="#cb131-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb131-6"><a href="#cb131-6" aria-hidden="true" tabindex="-1"></a><span class="kw">[toolchain]</span></span>
<span id="cb131-7"><a href="#cb131-7" aria-hidden="true" tabindex="-1"></a><span class="dt">moc</span> <span class="op">=</span> <span class="st">&quot;0.11.1&quot;</span></span></code></pre></div>
<h4 id="using-dependencies-in-code">9.1.2 Using Dependencies in
Code</h4>
<p>Once dependencies are installed, import them using the
<code>mo:</code> prefix:</p>
<pre class="motoko"><code>import SHA256 &quot;mo:sha256&quot;;
import Map &quot;mo:map/Map&quot;;
import { nhash } &quot;mo:map&quot;;

actor {
  type Map&lt;K, V&gt; = Map.Map&lt;K, V&gt;;
  
  stable var subscriptions : Map&lt;Principal, Nat64&gt; = Map.new();
  
  public func hashPassword(password : Text) : async Blob {
    SHA256.fromText(password)
  };
}</code></pre>
<h4 id="publishing-your-own-package">9.1.3 Publishing Your Own
Package</h4>
<p>Mops makes it easy to share reusable code with the community:</p>
<div class="sourceCode" id="cb133"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create package metadata</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a><span class="ex">mops</span> init <span class="at">--name</span> my-library <span class="at">--version</span> 1.0.0</span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Add package description</span></span>
<span id="cb133-5"><a href="#cb133-5" aria-hidden="true" tabindex="-1"></a><span class="ex">mops</span> config set description <span class="st">&quot;My awesome Motoko library&quot;</span></span>
<span id="cb133-6"><a href="#cb133-6" aria-hidden="true" tabindex="-1"></a><span class="ex">mops</span> config set repository <span class="st">&quot;https://github.com/username/my-library&quot;</span></span>
<span id="cb133-7"><a href="#cb133-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-8"><a href="#cb133-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Publish to Mops registry</span></span>
<span id="cb133-9"><a href="#cb133-9" aria-hidden="true" tabindex="-1"></a><span class="ex">mops</span> publish</span></code></pre></div>
<p><strong>Best Practices:</strong> - <strong>Semantic
Versioning</strong>: Follow semver (1.0.0 → 1.0.1 for patches, 1.1.0 for
features, 2.0.0 for breaking changes) - <strong>Documentation</strong>:
Include README.md with usage examples - <strong>Type Safety</strong>:
Export well-typed public interfaces - <strong>Testing</strong>: Include
test files demonstrating correct usage</p>
<h4 id="version-pinning-and-reproducibility">9.1.4 Version Pinning and
Reproducibility</h4>
<p>Mops generates a <code>mops.lock</code> file to ensure deterministic
builds:</p>
<div class="sourceCode" id="cb134"><pre
class="sourceCode toml"><code class="sourceCode toml"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="co"># mops.lock</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a><span class="kw">[[packages]]</span></span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a><span class="dt">name</span> <span class="op">=</span> <span class="st">&quot;base&quot;</span></span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a><span class="dt">version</span> <span class="op">=</span> <span class="st">&quot;0.11.1&quot;</span></span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a><span class="dt">hash</span> <span class="op">=</span> <span class="st">&quot;sha256:a1b2c3d4...&quot;</span></span>
<span id="cb134-6"><a href="#cb134-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-7"><a href="#cb134-7" aria-hidden="true" tabindex="-1"></a><span class="kw">[[packages]]</span></span>
<span id="cb134-8"><a href="#cb134-8" aria-hidden="true" tabindex="-1"></a><span class="dt">name</span> <span class="op">=</span> <span class="st">&quot;sha256&quot;</span></span>
<span id="cb134-9"><a href="#cb134-9" aria-hidden="true" tabindex="-1"></a><span class="dt">version</span> <span class="op">=</span> <span class="st">&quot;1.0.1&quot;</span></span>
<span id="cb134-10"><a href="#cb134-10" aria-hidden="true" tabindex="-1"></a><span class="dt">hash</span> <span class="op">=</span> <span class="st">&quot;sha256:e5f6g7h8...&quot;</span></span></code></pre></div>
<p><strong>Always commit <code>mops.lock</code> to version
control</strong> to ensure all team members and CI/CD pipelines use
identical dependencies.</p>
<h3 id="testing-strategies">9.2 Testing Strategies</h3>
<p>Testing on the Internet Computer requires different approaches than
traditional web development. Canisters are stateful, asynchronous, and
interact with other canisters, requiring sophisticated testing
strategies.</p>
<h4 id="unit-testing-pure-functions">9.2.1 Unit Testing Pure
Functions</h4>
<p>For pure Motoko functions (no state, no async), use the built-in
<code>Debug.print</code> for simple assertions:</p>
<pre class="motoko"><code>import Debug &quot;mo:base/Debug&quot;;
import Text &quot;mo:base/Text&quot;;

module {
  public func calculateFee(amount : Nat) : Nat {
    amount * 5 / 100  // 5% fee
  };
  
  // Simple test
  public func testCalculateFee() {
    let result = calculateFee(1000);
    assert(result == 50);
    Debug.print(&quot;✓ calculateFee test passed&quot;);
  };
}</code></pre>
<p>For more sophisticated unit testing, use the
<code>motoko-matchers</code> library:</p>
<pre class="motoko"><code>import Suite &quot;mo:matchers/Suite&quot;;
import T &quot;mo:matchers/Testable&quot;;
import M &quot;mo:matchers/Matchers&quot;;

let suite = Suite.suite(&quot;Fee Calculation Tests&quot;, [
  Suite.test(&quot;calculates 5% fee correctly&quot;,
    calculateFee(1000),
    M.equals(T.nat(50))
  ),
  Suite.test(&quot;handles zero amount&quot;,
    calculateFee(0),
    M.equals(T.nat(0))
  ),
  Suite.test(&quot;rounds down for odd amounts&quot;,
    calculateFee(999),
    M.equals(T.nat(49))
  ),
]);

Suite.run(suite);</code></pre>
<h4 id="testing-actor-methods">9.2.2 Testing Actor Methods</h4>
<p>Testing actor methods requires a different approach since they’re
asynchronous and maintain state. Use <code>dfx</code> to deploy
locally:</p>
<div class="sourceCode" id="cb137"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Start local replica</span></span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> start <span class="at">--clean</span> <span class="at">--background</span></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Deploy canister</span></span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> deploy my_canister</span>
<span id="cb137-6"><a href="#cb137-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-7"><a href="#cb137-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Test via dfx command line</span></span>
<span id="cb137-8"><a href="#cb137-8" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> canister call my_canister deposit <span class="st">&#39;(100 : nat64)&#39;</span></span>
<span id="cb137-9"><a href="#cb137-9" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> canister call my_canister getBalance <span class="st">&#39;()&#39;</span></span></code></pre></div>
<h3 id="integration-testing-with-pocketic">9.3 Integration Testing with
PocketIC</h3>
<p>Unit testing Motoko functions is useful, but integration testing
involving multiple canisters (OpenPatron + Ledger + Internet Identity)
is critical.</p>
<p><strong>PocketIC</strong> is the industry-standard testing framework.
It allows developers to write tests in Python or Rust that spin up a
lightweight, deterministic instance of the Internet Computer. Unlike a
full local replica, PocketIC allows for <strong>Time Travel</strong>
(advancing the clock to test subscriptions) and inspecting the raw state
of canisters.</p>
<h4 id="setting-up-pocketic">9.3.1 Setting Up PocketIC</h4>
<p><strong>Python Setup:</strong></p>
<div class="sourceCode" id="cb138"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install pocket-ic</span></code></pre></div>
<p><strong>Rust Setup:</strong></p>
<div class="sourceCode" id="cb139"><pre
class="sourceCode toml"><code class="sourceCode toml"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Cargo.toml</span></span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a><span class="kw">[dev-dependencies]</span></span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true" tabindex="-1"></a><span class="dt">pocket-ic</span> <span class="op">=</span> <span class="st">&quot;3.0.0&quot;</span></span>
<span id="cb139-4"><a href="#cb139-4" aria-hidden="true" tabindex="-1"></a><span class="dt">candid</span> <span class="op">=</span> <span class="st">&quot;0.10&quot;</span></span></code></pre></div>
<h4 id="basic-pocketic-test-python">9.3.2 Basic PocketIC Test
(Python)</h4>
<div class="sourceCode" id="cb140"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pocket_ic <span class="im">import</span> PocketIC</span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_deposit_and_withdrawal():</span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create IC instance</span></span>
<span id="cb140-5"><a href="#cb140-5" aria-hidden="true" tabindex="-1"></a>    pic <span class="op">=</span> PocketIC()</span>
<span id="cb140-6"><a href="#cb140-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb140-7"><a href="#cb140-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Deploy OpenPatron canister</span></span>
<span id="cb140-8"><a href="#cb140-8" aria-hidden="true" tabindex="-1"></a>    canister_id <span class="op">=</span> pic.create_canister()</span>
<span id="cb140-9"><a href="#cb140-9" aria-hidden="true" tabindex="-1"></a>    pic.install_code(</span>
<span id="cb140-10"><a href="#cb140-10" aria-hidden="true" tabindex="-1"></a>        canister_id,</span>
<span id="cb140-11"><a href="#cb140-11" aria-hidden="true" tabindex="-1"></a>        wasm_path<span class="op">=</span><span class="st">&quot;./target/wasm32-unknown-unknown/release/openpatron.wasm&quot;</span></span>
<span id="cb140-12"><a href="#cb140-12" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb140-13"><a href="#cb140-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb140-14"><a href="#cb140-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create test user</span></span>
<span id="cb140-15"><a href="#cb140-15" aria-hidden="true" tabindex="-1"></a>    user_principal <span class="op">=</span> pic.create_principal(<span class="st">&quot;user_a&quot;</span>)</span>
<span id="cb140-16"><a href="#cb140-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb140-17"><a href="#cb140-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Test deposit</span></span>
<span id="cb140-18"><a href="#cb140-18" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> pic.update_call(</span>
<span id="cb140-19"><a href="#cb140-19" aria-hidden="true" tabindex="-1"></a>        canister_id,</span>
<span id="cb140-20"><a href="#cb140-20" aria-hidden="true" tabindex="-1"></a>        user_principal,</span>
<span id="cb140-21"><a href="#cb140-21" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;deposit&quot;</span>,</span>
<span id="cb140-22"><a href="#cb140-22" aria-hidden="true" tabindex="-1"></a>        encode([{<span class="st">&quot;amount&quot;</span>: <span class="dv">100</span>}])</span>
<span id="cb140-23"><a href="#cb140-23" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb140-24"><a href="#cb140-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> result[<span class="st">&quot;status&quot;</span>] <span class="op">==</span> <span class="st">&quot;success&quot;</span></span>
<span id="cb140-25"><a href="#cb140-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb140-26"><a href="#cb140-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Verify balance</span></span>
<span id="cb140-27"><a href="#cb140-27" aria-hidden="true" tabindex="-1"></a>    balance <span class="op">=</span> pic.query_call(</span>
<span id="cb140-28"><a href="#cb140-28" aria-hidden="true" tabindex="-1"></a>        canister_id,</span>
<span id="cb140-29"><a href="#cb140-29" aria-hidden="true" tabindex="-1"></a>        user_principal,</span>
<span id="cb140-30"><a href="#cb140-30" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;getBalance&quot;</span>,</span>
<span id="cb140-31"><a href="#cb140-31" aria-hidden="true" tabindex="-1"></a>        encode([])</span>
<span id="cb140-32"><a href="#cb140-32" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb140-33"><a href="#cb140-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> balance <span class="op">==</span> <span class="dv">100</span></span>
<span id="cb140-34"><a href="#cb140-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb140-35"><a href="#cb140-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Test withdrawal</span></span>
<span id="cb140-36"><a href="#cb140-36" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> pic.update_call(</span>
<span id="cb140-37"><a href="#cb140-37" aria-hidden="true" tabindex="-1"></a>        canister_id,</span>
<span id="cb140-38"><a href="#cb140-38" aria-hidden="true" tabindex="-1"></a>        user_principal,</span>
<span id="cb140-39"><a href="#cb140-39" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;withdraw&quot;</span>,</span>
<span id="cb140-40"><a href="#cb140-40" aria-hidden="true" tabindex="-1"></a>        encode([{<span class="st">&quot;amount&quot;</span>: <span class="dv">50</span>}])</span>
<span id="cb140-41"><a href="#cb140-41" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb140-42"><a href="#cb140-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> result[<span class="st">&quot;status&quot;</span>] <span class="op">==</span> <span class="st">&quot;success&quot;</span></span>
<span id="cb140-43"><a href="#cb140-43" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb140-44"><a href="#cb140-44" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Verify final balance</span></span>
<span id="cb140-45"><a href="#cb140-45" aria-hidden="true" tabindex="-1"></a>    balance <span class="op">=</span> pic.query_call(canister_id, user_principal, <span class="st">&quot;getBalance&quot;</span>, encode([]))</span>
<span id="cb140-46"><a href="#cb140-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> balance <span class="op">==</span> <span class="dv">50</span></span></code></pre></div>
<h4 id="time-travel-testing">9.3.3 Time Travel Testing</h4>
<p><strong>Example PocketIC Scenario with Time Travel:</strong></p>
<div class="sourceCode" id="cb141"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pocket_ic <span class="im">import</span> PocketIC</span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_subscription_payment():</span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true" tabindex="-1"></a>    pic <span class="op">=</span> PocketIC()</span>
<span id="cb141-6"><a href="#cb141-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb141-7"><a href="#cb141-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1. Instantiate OpenPatron Canister</span></span>
<span id="cb141-8"><a href="#cb141-8" aria-hidden="true" tabindex="-1"></a>    openpatron_id <span class="op">=</span> pic.create_canister()</span>
<span id="cb141-9"><a href="#cb141-9" aria-hidden="true" tabindex="-1"></a>    pic.install_code(openpatron_id, wasm_path<span class="op">=</span><span class="st">&quot;openpatron.wasm&quot;</span>)</span>
<span id="cb141-10"><a href="#cb141-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb141-11"><a href="#cb141-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2. Instantiate Ledger Canister</span></span>
<span id="cb141-12"><a href="#cb141-12" aria-hidden="true" tabindex="-1"></a>    ledger_id <span class="op">=</span> pic.create_canister()</span>
<span id="cb141-13"><a href="#cb141-13" aria-hidden="true" tabindex="-1"></a>    pic.install_code(ledger_id, wasm_path<span class="op">=</span><span class="st">&quot;ledger.wasm&quot;</span>)</span>
<span id="cb141-14"><a href="#cb141-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb141-15"><a href="#cb141-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 3. Mint 100 tokens to User A</span></span>
<span id="cb141-16"><a href="#cb141-16" aria-hidden="true" tabindex="-1"></a>    user_a <span class="op">=</span> pic.create_principal(<span class="st">&quot;alice&quot;</span>)</span>
<span id="cb141-17"><a href="#cb141-17" aria-hidden="true" tabindex="-1"></a>    pic.update_call(ledger_id, pic.admin_principal(), <span class="st">&quot;mint&quot;</span>, </span>
<span id="cb141-18"><a href="#cb141-18" aria-hidden="true" tabindex="-1"></a>                    encode([{<span class="st">&quot;to&quot;</span>: user_a, <span class="st">&quot;amount&quot;</span>: <span class="dv">100_000_000</span>}]))</span>
<span id="cb141-19"><a href="#cb141-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb141-20"><a href="#cb141-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 4. User A calls deposit on OpenPatron</span></span>
<span id="cb141-21"><a href="#cb141-21" aria-hidden="true" tabindex="-1"></a>    pic.update_call(openpatron_id, user_a, <span class="st">&quot;deposit&quot;</span>,</span>
<span id="cb141-22"><a href="#cb141-22" aria-hidden="true" tabindex="-1"></a>                   encode([{<span class="st">&quot;amount&quot;</span>: <span class="dv">100_000_000</span>}]))</span>
<span id="cb141-23"><a href="#cb141-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb141-24"><a href="#cb141-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 5. User A subscribes to Creator B</span></span>
<span id="cb141-25"><a href="#cb141-25" aria-hidden="true" tabindex="-1"></a>    creator_b <span class="op">=</span> pic.create_principal(<span class="st">&quot;bob&quot;</span>)</span>
<span id="cb141-26"><a href="#cb141-26" aria-hidden="true" tabindex="-1"></a>    pic.update_call(openpatron_id, user_a, <span class="st">&quot;subscribe&quot;</span>,</span>
<span id="cb141-27"><a href="#cb141-27" aria-hidden="true" tabindex="-1"></a>                   encode([{<span class="st">&quot;creator&quot;</span>: creator_b, <span class="st">&quot;amount&quot;</span>: <span class="dv">10_000_000</span>}]))</span>
<span id="cb141-28"><a href="#cb141-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb141-29"><a href="#cb141-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 6. **Advance time by 31 days** (Crucial step impossible in standard unit tests)</span></span>
<span id="cb141-30"><a href="#cb141-30" aria-hidden="true" tabindex="-1"></a>    pic.advance_time_seconds(<span class="dv">31</span> <span class="op">*</span> <span class="dv">24</span> <span class="op">*</span> <span class="dv">60</span> <span class="op">*</span> <span class="dv">60</span>)</span>
<span id="cb141-31"><a href="#cb141-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb141-32"><a href="#cb141-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Trigger heartbeat/timer to process subscriptions</span></span>
<span id="cb141-33"><a href="#cb141-33" aria-hidden="true" tabindex="-1"></a>    pic.tick()</span>
<span id="cb141-34"><a href="#cb141-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb141-35"><a href="#cb141-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 7. Assert that OpenPatron triggered the subscription payment automatically</span></span>
<span id="cb141-36"><a href="#cb141-36" aria-hidden="true" tabindex="-1"></a>    creator_balance <span class="op">=</span> pic.query_call(openpatron_id, creator_b, <span class="st">&quot;getBalance&quot;</span>, encode([]))</span>
<span id="cb141-37"><a href="#cb141-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> creator_balance <span class="op">==</span> <span class="dv">10_000_000</span>, <span class="st">&quot;Subscription payment should have been processed&quot;</span></span>
<span id="cb141-38"><a href="#cb141-38" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb141-39"><a href="#cb141-39" aria-hidden="true" tabindex="-1"></a>    user_balance <span class="op">=</span> pic.query_call(openpatron_id, user_a, <span class="st">&quot;getBalance&quot;</span>, encode([]))</span>
<span id="cb141-40"><a href="#cb141-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> user_balance <span class="op">==</span> <span class="dv">90_000_000</span>, <span class="st">&quot;User balance should be reduced by subscription amount&quot;</span></span></code></pre></div>
<h4 id="multi-canister-testing">9.3.4 Multi-Canister Testing</h4>
<p>Testing inter-canister calls is where PocketIC shines:</p>
<div class="sourceCode" id="cb142"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_ledger_integration():</span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a>    pic <span class="op">=</span> PocketIC()</span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Deploy multiple canisters</span></span>
<span id="cb142-5"><a href="#cb142-5" aria-hidden="true" tabindex="-1"></a>    ledger <span class="op">=</span> pic.create_and_install(<span class="st">&quot;ledger.wasm&quot;</span>)</span>
<span id="cb142-6"><a href="#cb142-6" aria-hidden="true" tabindex="-1"></a>    openpatron <span class="op">=</span> pic.create_and_install(<span class="st">&quot;openpatron.wasm&quot;</span>)</span>
<span id="cb142-7"><a href="#cb142-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb142-8"><a href="#cb142-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Configure OpenPatron to use Ledger</span></span>
<span id="cb142-9"><a href="#cb142-9" aria-hidden="true" tabindex="-1"></a>    pic.update_call(openpatron, pic.admin_principal(), <span class="st">&quot;setLedgerId&quot;</span>, </span>
<span id="cb142-10"><a href="#cb142-10" aria-hidden="true" tabindex="-1"></a>                    encode([{<span class="st">&quot;ledger&quot;</span>: ledger}]))</span>
<span id="cb142-11"><a href="#cb142-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb142-12"><a href="#cb142-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># User deposits via Ledger</span></span>
<span id="cb142-13"><a href="#cb142-13" aria-hidden="true" tabindex="-1"></a>    user <span class="op">=</span> pic.create_principal(<span class="st">&quot;user&quot;</span>)</span>
<span id="cb142-14"><a href="#cb142-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb142-15"><a href="#cb142-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Approve OpenPatron to spend tokens</span></span>
<span id="cb142-16"><a href="#cb142-16" aria-hidden="true" tabindex="-1"></a>    pic.update_call(ledger, user, <span class="st">&quot;icrc2_approve&quot;</span>, encode([{</span>
<span id="cb142-17"><a href="#cb142-17" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;spender&quot;</span>: openpatron,</span>
<span id="cb142-18"><a href="#cb142-18" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;amount&quot;</span>: <span class="dv">1_000_000</span></span>
<span id="cb142-19"><a href="#cb142-19" aria-hidden="true" tabindex="-1"></a>    }]))</span>
<span id="cb142-20"><a href="#cb142-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb142-21"><a href="#cb142-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># OpenPatron pulls tokens from Ledger</span></span>
<span id="cb142-22"><a href="#cb142-22" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> pic.update_call(openpatron, user, <span class="st">&quot;depositFromLedger&quot;</span>, </span>
<span id="cb142-23"><a href="#cb142-23" aria-hidden="true" tabindex="-1"></a>                             encode([{<span class="st">&quot;amount&quot;</span>: <span class="dv">1_000_000</span>}]))</span>
<span id="cb142-24"><a href="#cb142-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb142-25"><a href="#cb142-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> result[<span class="st">&quot;success&quot;</span>] <span class="op">==</span> <span class="va">True</span></span>
<span id="cb142-26"><a href="#cb142-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb142-27"><a href="#cb142-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Verify internal balance matches</span></span>
<span id="cb142-28"><a href="#cb142-28" aria-hidden="true" tabindex="-1"></a>    balance <span class="op">=</span> pic.query_call(openpatron, user, <span class="st">&quot;getBalance&quot;</span>, encode([]))</span>
<span id="cb142-29"><a href="#cb142-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> balance <span class="op">==</span> <span class="dv">1_000_000</span></span></code></pre></div>
<h3 id="property-based-testing">9.4 Property-Based Testing</h3>
<p>Property-based testing generates random inputs to verify that certain
properties always hold:</p>
<div class="sourceCode" id="cb143"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> hypothesis <span class="im">import</span> given, strategies <span class="im">as</span> st</span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pocket_ic <span class="im">import</span> PocketIC</span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-4"><a href="#cb143-4" aria-hidden="true" tabindex="-1"></a><span class="at">@given</span>(</span>
<span id="cb143-5"><a href="#cb143-5" aria-hidden="true" tabindex="-1"></a>    amount<span class="op">=</span>st.integers(min_value<span class="op">=</span><span class="dv">1</span>, max_value<span class="op">=</span><span class="dv">1_000_000_000</span>),</span>
<span id="cb143-6"><a href="#cb143-6" aria-hidden="true" tabindex="-1"></a>    fee_percentage<span class="op">=</span>st.integers(min_value<span class="op">=</span><span class="dv">0</span>, max_value<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb143-7"><a href="#cb143-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb143-8"><a href="#cb143-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_fee_calculation_properties(amount, fee_percentage):</span>
<span id="cb143-9"><a href="#cb143-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Test that fee calculation always produces valid results&quot;&quot;&quot;</span></span>
<span id="cb143-10"><a href="#cb143-10" aria-hidden="true" tabindex="-1"></a>    pic <span class="op">=</span> PocketIC()</span>
<span id="cb143-11"><a href="#cb143-11" aria-hidden="true" tabindex="-1"></a>    canister <span class="op">=</span> pic.create_and_install(<span class="st">&quot;fee_calculator.wasm&quot;</span>)</span>
<span id="cb143-12"><a href="#cb143-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb143-13"><a href="#cb143-13" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> pic.query_call(canister, pic.admin_principal(), </span>
<span id="cb143-14"><a href="#cb143-14" aria-hidden="true" tabindex="-1"></a>                           <span class="st">&quot;calculateFee&quot;</span>, encode([{</span>
<span id="cb143-15"><a href="#cb143-15" aria-hidden="true" tabindex="-1"></a>                               <span class="st">&quot;amount&quot;</span>: amount,</span>
<span id="cb143-16"><a href="#cb143-16" aria-hidden="true" tabindex="-1"></a>                               <span class="st">&quot;feePercentage&quot;</span>: fee_percentage</span>
<span id="cb143-17"><a href="#cb143-17" aria-hidden="true" tabindex="-1"></a>                           }]))</span>
<span id="cb143-18"><a href="#cb143-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb143-19"><a href="#cb143-19" aria-hidden="true" tabindex="-1"></a>    fee <span class="op">=</span> decode(result)[<span class="st">&quot;fee&quot;</span>]</span>
<span id="cb143-20"><a href="#cb143-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb143-21"><a href="#cb143-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Property 1: Fee should never exceed amount</span></span>
<span id="cb143-22"><a href="#cb143-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> fee <span class="op">&lt;=</span> amount</span>
<span id="cb143-23"><a href="#cb143-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb143-24"><a href="#cb143-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Property 2: Fee should be non-negative</span></span>
<span id="cb143-25"><a href="#cb143-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> fee <span class="op">&gt;=</span> <span class="dv">0</span></span>
<span id="cb143-26"><a href="#cb143-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb143-27"><a href="#cb143-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Property 3: Fee should match expected calculation</span></span>
<span id="cb143-28"><a href="#cb143-28" aria-hidden="true" tabindex="-1"></a>    expected_fee <span class="op">=</span> (amount <span class="op">*</span> fee_percentage) <span class="op">//</span> <span class="dv">100</span></span>
<span id="cb143-29"><a href="#cb143-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> fee <span class="op">==</span> expected_fee</span></code></pre></div>
<h3 id="debugging-techniques">9.5 Debugging Techniques</h3>
<h4 id="debug.print-for-runtime-inspection">9.5.1 Debug.print for
Runtime Inspection</h4>
<pre class="motoko"><code>import Debug &quot;mo:base/Debug&quot;;

actor {
  public func processPayment(amount : Nat) : async Bool {
    Debug.print(&quot;Processing payment for amount: &quot; # debug_show(amount));
    
    if (amount &lt; 100) {
      Debug.print(&quot;⚠️  Payment amount too small&quot;);
      return false;
    };
    
    Debug.print(&quot;✓ Payment processed successfully&quot;);
    true
  };
}</code></pre>
<p>Run with <code>dfx deploy</code> and view output in the terminal.</p>
<h4 id="canister-profiling">9.5.2 Canister Profiling</h4>
<p>Monitor canister performance:</p>
<div class="sourceCode" id="cb145"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Check canister status</span></span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> canister status my_canister</span>
<span id="cb145-3"><a href="#cb145-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-4"><a href="#cb145-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Output:</span></span>
<span id="cb145-5"><a href="#cb145-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Canister status: Running</span></span>
<span id="cb145-6"><a href="#cb145-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Memory allocation: 0</span></span>
<span id="cb145-7"><a href="#cb145-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Memory size: 1_234_567</span></span>
<span id="cb145-8"><a href="#cb145-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Cycles: 3_500_000_000_000</span></span>
<span id="cb145-9"><a href="#cb145-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Module hash: 0xabcd...</span></span></code></pre></div>
<h4 id="state-inspection">9.5.3 State Inspection</h4>
<p>PocketIC allows direct state inspection:</p>
<div class="sourceCode" id="cb146"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_inspect_canister_state():</span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a>    pic <span class="op">=</span> PocketIC()</span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a>    canister <span class="op">=</span> pic.create_and_install(<span class="st">&quot;my_canister.wasm&quot;</span>)</span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb146-5"><a href="#cb146-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Perform some operations</span></span>
<span id="cb146-6"><a href="#cb146-6" aria-hidden="true" tabindex="-1"></a>    pic.update_call(canister, user, <span class="st">&quot;addItem&quot;</span>, encode([{<span class="st">&quot;item&quot;</span>: <span class="st">&quot;test&quot;</span>}]))</span>
<span id="cb146-7"><a href="#cb146-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb146-8"><a href="#cb146-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Inspect stable memory directly</span></span>
<span id="cb146-9"><a href="#cb146-9" aria-hidden="true" tabindex="-1"></a>    stable_memory <span class="op">=</span> pic.get_stable_memory(canister)</span>
<span id="cb146-10"><a href="#cb146-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Stable memory size: </span><span class="sc">{</span><span class="bu">len</span>(stable_memory)<span class="sc">}</span><span class="ss"> bytes&quot;</span>)</span>
<span id="cb146-11"><a href="#cb146-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb146-12"><a href="#cb146-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get canister cycles balance</span></span>
<span id="cb146-13"><a href="#cb146-13" aria-hidden="true" tabindex="-1"></a>    cycles <span class="op">=</span> pic.get_cycle_balance(canister)</span>
<span id="cb146-14"><a href="#cb146-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> cycles <span class="op">&gt;</span> <span class="dv">0</span>, <span class="st">&quot;Canister should have cycles&quot;</span></span></code></pre></div>
<h3 id="continuous-integration">9.6 Continuous Integration</h3>
<p>Integrate PocketIC tests into CI/CD pipelines:</p>
<p><strong>GitHub Actions Example:</strong></p>
<div class="sourceCode" id="cb147"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a><span class="fu">name</span><span class="kw">:</span><span class="at"> Motoko Tests</span></span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a><span class="fu">on</span><span class="kw">:</span><span class="at"> </span><span class="kw">[</span><span class="at">push</span><span class="kw">,</span><span class="at"> pull_request</span><span class="kw">]</span></span>
<span id="cb147-4"><a href="#cb147-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-5"><a href="#cb147-5" aria-hidden="true" tabindex="-1"></a><span class="fu">jobs</span><span class="kw">:</span></span>
<span id="cb147-6"><a href="#cb147-6" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">test</span><span class="kw">:</span></span>
<span id="cb147-7"><a href="#cb147-7" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">runs-on</span><span class="kw">:</span><span class="at"> ubuntu-latest</span></span>
<span id="cb147-8"><a href="#cb147-8" aria-hidden="true" tabindex="-1"></a><span class="at">    </span></span>
<span id="cb147-9"><a href="#cb147-9" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">steps</span><span class="kw">:</span></span>
<span id="cb147-10"><a href="#cb147-10" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> </span><span class="fu">uses</span><span class="kw">:</span><span class="at"> actions/checkout@v3</span></span>
<span id="cb147-11"><a href="#cb147-11" aria-hidden="true" tabindex="-1"></a><span class="at">      </span></span>
<span id="cb147-12"><a href="#cb147-12" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Install DFX</span></span>
<span id="cb147-13"><a href="#cb147-13" aria-hidden="true" tabindex="-1"></a><span class="fu">        run</span><span class="kw">: </span><span class="ch">|</span></span>
<span id="cb147-14"><a href="#cb147-14" aria-hidden="true" tabindex="-1"></a>          sh -ci &quot;$(curl -fsSL https://internetcomputer.org/install.sh)&quot;</span>
<span id="cb147-15"><a href="#cb147-15" aria-hidden="true" tabindex="-1"></a>          echo &quot;$HOME/.local/bin&quot; &gt;&gt; $GITHUB_PATH</span>
<span id="cb147-16"><a href="#cb147-16" aria-hidden="true" tabindex="-1"></a><span class="at">      </span></span>
<span id="cb147-17"><a href="#cb147-17" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Install Mops</span></span>
<span id="cb147-18"><a href="#cb147-18" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">run</span><span class="kw">:</span><span class="at"> npm install -g ic-mops</span></span>
<span id="cb147-19"><a href="#cb147-19" aria-hidden="true" tabindex="-1"></a><span class="at">      </span></span>
<span id="cb147-20"><a href="#cb147-20" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Install Dependencies</span></span>
<span id="cb147-21"><a href="#cb147-21" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">run</span><span class="kw">:</span><span class="at"> mops install</span></span>
<span id="cb147-22"><a href="#cb147-22" aria-hidden="true" tabindex="-1"></a><span class="at">      </span></span>
<span id="cb147-23"><a href="#cb147-23" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Build Canisters</span></span>
<span id="cb147-24"><a href="#cb147-24" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">run</span><span class="kw">:</span><span class="at"> dfx build</span></span>
<span id="cb147-25"><a href="#cb147-25" aria-hidden="true" tabindex="-1"></a><span class="at">      </span></span>
<span id="cb147-26"><a href="#cb147-26" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Install Python Dependencies</span></span>
<span id="cb147-27"><a href="#cb147-27" aria-hidden="true" tabindex="-1"></a><span class="fu">        run</span><span class="kw">: </span><span class="ch">|</span></span>
<span id="cb147-28"><a href="#cb147-28" aria-hidden="true" tabindex="-1"></a>          pip install pocket-ic pytest</span>
<span id="cb147-29"><a href="#cb147-29" aria-hidden="true" tabindex="-1"></a><span class="at">      </span></span>
<span id="cb147-30"><a href="#cb147-30" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Run Tests</span></span>
<span id="cb147-31"><a href="#cb147-31" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">run</span><span class="kw">:</span><span class="at"> pytest tests/</span></span></code></pre></div>
<h3 id="best-practices-1">9.7 Best Practices</h3>
<ol type="1">
<li><strong>Test Pyramid</strong>: Write many unit tests, fewer
integration tests, and even fewer end-to-end tests</li>
<li><strong>Deterministic Tests</strong>: Avoid flaky tests by using
PocketIC’s controlled environment</li>
<li><strong>Test Coverage</strong>: Aim for &gt;80% code coverage for
critical paths</li>
<li><strong>Fast Feedback</strong>: Keep unit tests fast (&lt;1s),
integration tests moderate (&lt;30s)</li>
<li><strong>Realistic Data</strong>: Use production-like data in tests
to catch edge cases</li>
<li><strong>Upgrade Testing</strong>: Test canister upgrades to verify
stable variables persist correctly</li>
</ol>
<pre class="motoko"><code>import Debug &quot;mo:base/Debug&quot;;

actor {
  stable var version : Nat = 1;
  stable var data : [Nat] = [];
  
  system func preupgrade() {
    Debug.print(&quot;Preparing for upgrade, version: &quot; # debug_show(version));
  };
  
  system func postupgrade() {
    version += 1;
    Debug.print(&quot;Upgraded to version: &quot; # debug_show(version));
    assert(data.size() &gt; 0);  // Verify data persisted
  };
}</code></pre>
<h3 id="performance-testing">9.8 Performance Testing</h3>
<p>Load testing ensures your canister handles production traffic:</p>
<div class="sourceCode" id="cb149"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> concurrent.futures</span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pocket_ic <span class="im">import</span> PocketIC</span>
<span id="cb149-3"><a href="#cb149-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb149-4"><a href="#cb149-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> stress_test_concurrent_calls():</span>
<span id="cb149-5"><a href="#cb149-5" aria-hidden="true" tabindex="-1"></a>    pic <span class="op">=</span> PocketIC()</span>
<span id="cb149-6"><a href="#cb149-6" aria-hidden="true" tabindex="-1"></a>    canister <span class="op">=</span> pic.create_and_install(<span class="st">&quot;my_canister.wasm&quot;</span>)</span>
<span id="cb149-7"><a href="#cb149-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb149-8"><a href="#cb149-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> make_call(i):</span>
<span id="cb149-9"><a href="#cb149-9" aria-hidden="true" tabindex="-1"></a>        user <span class="op">=</span> pic.create_principal(<span class="ss">f&quot;user_</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb149-10"><a href="#cb149-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> pic.update_call(canister, user, <span class="st">&quot;processRequest&quot;</span>, </span>
<span id="cb149-11"><a href="#cb149-11" aria-hidden="true" tabindex="-1"></a>                              encode([{<span class="st">&quot;data&quot;</span>: <span class="ss">f&quot;request_</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">&quot;</span>}]))</span>
<span id="cb149-12"><a href="#cb149-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb149-13"><a href="#cb149-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Execute 100 concurrent calls</span></span>
<span id="cb149-14"><a href="#cb149-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> concurrent.futures.ThreadPoolExecutor(max_workers<span class="op">=</span><span class="dv">100</span>) <span class="im">as</span> executor:</span>
<span id="cb149-15"><a href="#cb149-15" aria-hidden="true" tabindex="-1"></a>        futures <span class="op">=</span> [executor.submit(make_call, i) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">100</span>)]</span>
<span id="cb149-16"><a href="#cb149-16" aria-hidden="true" tabindex="-1"></a>        results <span class="op">=</span> [f.result() <span class="cf">for</span> f <span class="kw">in</span> futures]</span>
<span id="cb149-17"><a href="#cb149-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb149-18"><a href="#cb149-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># All calls should succeed</span></span>
<span id="cb149-19"><a href="#cb149-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="bu">all</span>(r[<span class="st">&quot;success&quot;</span>] <span class="cf">for</span> r <span class="kw">in</span> results)</span>
<span id="cb149-20"><a href="#cb149-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb149-21"><a href="#cb149-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check canister didn&#39;t run out of cycles</span></span>
<span id="cb149-22"><a href="#cb149-22" aria-hidden="true" tabindex="-1"></a>    cycles <span class="op">=</span> pic.get_cycle_balance(canister)</span>
<span id="cb149-23"><a href="#cb149-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> cycles <span class="op">&gt;</span> <span class="dv">1_000_000_000</span>, <span class="st">&quot;Canister running low on cycles&quot;</span></span></code></pre></div>
<hr />
<p>The combination of Mops for dependency management, PocketIC for
integration testing, and proper CI/CD pipelines transforms Motoko
development into a professional engineering discipline. These tools
enable developers to ship complex, multi-canister systems with
confidence.</p>
<hr />
<hr />
<h1 id="chapter-12-the-economics-of-deployment">Chapter 12: The
Economics of Deployment</h1>
<p>Deploying to the mainnet requires a fundamental shift in economic
thinking. Unlike traditional blockchain platforms where users pay gas
fees for every transaction, the Internet Computer utilizes a
revolutionary “Reverse Gas Model.” In this paradigm, users do not pay
gas to interact with OpenPatron; instead, the OpenPatron canister itself
pays for its own computation and storage.</p>
<p>This model creates a Web2-like user experience—users can interact
with dapps without needing tokens in their wallet—but introduces new
challenges for developers. You must now think like a product owner,
ensuring your canister has sufficient resources to operate
sustainably.</p>
<h3 id="understanding-cycles-the-fuel-of-the-internet-computer">10.1
Understanding Cycles: The Fuel of the Internet Computer</h3>
<p>The fuel for canisters is <strong>Cycles</strong>. Unlike volatile
cryptocurrencies, cycles are designed to be stable in real-world
cost:</p>
<ul>
<li><p><strong>1 Trillion Cycles ≈ 1 SDR (Special Drawing Rights) ≈
$1.30 USD</strong></p></li>
<li><p><strong>SDR Peg:</strong> The SDR is an international reserve
asset created by the IMF, providing stability against currency
fluctuations.</p></li>
</ul>
<h4 id="cost-breakdown">Cost Breakdown</h4>
<p>Understanding the cost structure is essential for sustainable
deployment:</p>
<p><strong>Storage Costs:</strong> - <strong>1 GB of data
storage:</strong> ~4.2 billion cycles per day (~127 billion cycles per
month) - <strong>Example:</strong> Storing user profiles, subscription
data, and metadata for 10,000 users (≈100 MB) costs ~420 million cycles
per day</p>
<p><strong>Computation Costs:</strong> - <strong>Ingress
messages:</strong> Based on instruction count (typically 5-100 million
cycles per call) - <strong>Consensus:</strong> Update calls that modify
state are more expensive than query calls - <strong>Cross-canister
calls:</strong> Additional overhead for inter-canister communication</p>
<p><strong>HTTP Outcalls:</strong> - <strong>Per request:</strong> 49
million cycles for the base cost + data transfer costs - <strong>Use
case:</strong> Fetching external data like token prices or off-chain
verification</p>
<h4 id="monitoring-cycle-balance">Monitoring Cycle Balance</h4>
<p>Your canister must actively monitor its cycle balance to avoid
running out of fuel:</p>
<pre class="motoko"><code>import Cycles &quot;mo:base/ExperimentalCycles&quot;;
import Debug &quot;mo:base/Debug&quot;;

actor OpenPatron {
    
    // Minimum threshold to trigger refill alert
    private let MINIMUM_CYCLES : Nat = 1_000_000_000_000; // 1 Trillion cycles
    
    // Check canister cycle balance
    public query func getCycleBalance() : async Nat {
        return Cycles.balance();
    };
    
    // Alert if balance is low
    public func checkHealth() : async Text {
        let balance = Cycles.balance();
        if (balance &lt; MINIMUM_CYCLES) {
            return &quot;⚠️ WARNING: Low cycle balance. Refill needed!&quot;;
        } else {
            return &quot;✅ Healthy: &quot; # debug_show(balance) # &quot; cycles remaining&quot;;
        };
    };
    
    // Accept cycles when receiving top-ups
    public func acceptCycles() : async Nat {
        let available = Cycles.available();
        let accepted = Cycles.accept(available);
        Debug.print(&quot;Accepted &quot; # debug_show(accepted) # &quot; cycles&quot;);
        return accepted;
    };
};</code></pre>
<h3 id="building-a-sustainable-economic-model">10.2 Building a
Sustainable Economic Model</h3>
<p>OpenPatron cannot operate for free forever. The canister must
generate revenue to sustain itself. Here’s a comprehensive
sustainability strategy:</p>
<h4 id="the-tax-model">The Tax Model</h4>
<p>Implement a small platform fee on each transaction:</p>
<pre class="motoko"><code>import Result &quot;mo:base/Result&quot;;
import Nat &quot;mo:base/Nat&quot;;

actor OpenPatron {
    
    // Platform fee: 1% of each subscription
    private let PLATFORM_FEE_PERCENT : Nat = 1;
    private stable var treasuryBalance : Nat = 0;
    
    // Process subscription payment with automatic fee deduction
    public shared(msg) func processSubscription(
        creatorId : Principal,
        amount : Nat
    ) : async Result.Result&lt;(), Text&gt; {
        
        // Calculate fee and creator payment
        let platformFee = (amount * PLATFORM_FEE_PERCENT) / 100;
        let creatorPayment = amount - platformFee;
        
        // Add to treasury
        treasuryBalance += platformFee;
        
        // Transfer to creator (simplified for example)
        // In production, use ICRC-1 transfer
        // await transferToCreator(creatorId, creatorPayment);
        
        #ok()
    };
    
    public query func getTreasuryBalance() : async Nat {
        return treasuryBalance;
    };
};</code></pre>
<h4 id="automated-cycle-management">Automated Cycle Management</h4>
<p>Implement a system to automatically convert treasury funds into
cycles:</p>
<pre class="motoko"><code>import Cycles &quot;mo:base/ExperimentalCycles&quot;;
import Timer &quot;mo:base/Timer&quot;;
import Principal &quot;mo:base/Principal&quot;;

actor OpenPatron {
    
    private stable var treasuryBalance : Nat = 0;
    private let CYCLES_REFILL_THRESHOLD : Nat = 2_000_000_000_000; // 2T cycles
    private let CYCLES_TARGET_BALANCE : Nat = 5_000_000_000_000;   // 5T cycles
    
    // Canister management interface for buying cycles
    type ManagementCanister = actor {
        deposit_cycles : shared { canister_id : Principal } -&gt; async ();
    };
    
    // Check balance and refill if needed (called periodically)
    private func checkAndRefill() : async () {
        let balance = Cycles.balance();
        
        if (balance &lt; CYCLES_REFILL_THRESHOLD) {
            Debug.print(&quot;Low cycle balance detected. Initiating refill...&quot;);
            await refillCycles();
        };
    };
    
    // Refill cycles from treasury
    private func refillCycles() : async () {
        let needed = CYCLES_TARGET_BALANCE - Cycles.balance();
        
        // Convert tokens to cycles via exchange
        // This is simplified - in production, use a DEX or cycles minting canister
        let cyclesPurchased = await convertTokensToCycles(treasuryBalance);
        
        Debug.print(&quot;Refilled &quot; # debug_show(cyclesPurchased) # &quot; cycles&quot;);
    };
    
    // Dummy function - in production, integrate with ICP ledger and cycles minting
    private func convertTokensToCycles(tokens : Nat) : async Nat {
        // Implementation would involve:
        // 1. Converting platform tokens to ICP
        // 2. Calling cycles minting canister to convert ICP to cycles
        // 3. Depositing cycles back to this canister
        return 1_000_000_000_000; // Placeholder
    };
    
    // Set up a heartbeat to check cycles periodically
    system func heartbeat() : async () {
        await checkAndRefill();
    };
};</code></pre>
<h4 id="alternative-revenue-streams">Alternative Revenue Streams</h4>
<p>Consider multiple monetization strategies:</p>
<ol type="1">
<li><strong>Subscription Tiers:</strong>
<ul>
<li>Free tier: Basic features with rate limits</li>
<li>Premium tier: Advanced features and higher limits</li>
</ul></li>
<li><strong>Creator Verification Fees:</strong>
<ul>
<li>One-time fee for profile verification</li>
</ul></li>
<li><strong>Premium Placement:</strong>
<ul>
<li>Featured creator slots on the platform</li>
</ul></li>
</ol>
<h3 id="deployment-process-and-best-practices">10.3 Deployment Process
and Best Practices</h3>
<p>Deploying to mainnet is a critical step that requires careful
preparation.</p>
<h4 id="pre-deployment-checklist">Pre-Deployment Checklist</h4>
<p>Before deploying to mainnet, ensure:</p>
<ul>
<li>✅ All tests pass (unit, integration, property-based)</li>
<li>✅ Security audit completed</li>
<li>✅ Cycle management system implemented</li>
<li>✅ Monitoring and logging in place</li>
<li>✅ Upgrade strategy defined</li>
<li>✅ Backup and recovery plan documented</li>
<li>✅ Load testing completed</li>
<li>✅ Documentation finalized</li>
</ul>
<h4 id="deployment-commands">Deployment Commands</h4>
<div class="sourceCode" id="cb153"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. Create cycles wallet (one-time setup)</span></span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> wallet <span class="at">--network</span> ic create <span class="at">--icp</span> <span class="op">&lt;</span>amount<span class="op">&gt;</span></span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. Check cycle balance</span></span>
<span id="cb153-5"><a href="#cb153-5" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> wallet <span class="at">--network</span> ic balance</span>
<span id="cb153-6"><a href="#cb153-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-7"><a href="#cb153-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. Deploy to mainnet</span></span>
<span id="cb153-8"><a href="#cb153-8" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> deploy <span class="at">--network</span> ic openpatron <span class="at">--with-cycles</span> 3000000000000</span>
<span id="cb153-9"><a href="#cb153-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-10"><a href="#cb153-10" aria-hidden="true" tabindex="-1"></a><span class="co"># 4. Verify deployment</span></span>
<span id="cb153-11"><a href="#cb153-11" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> canister <span class="at">--network</span> ic status openpatron</span>
<span id="cb153-12"><a href="#cb153-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-13"><a href="#cb153-13" aria-hidden="true" tabindex="-1"></a><span class="co"># 5. Check canister ID</span></span>
<span id="cb153-14"><a href="#cb153-14" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> canister <span class="at">--network</span> ic id openpatron</span></code></pre></div>
<h4 id="setting-controllers">Setting Controllers</h4>
<p>Carefully manage who can upgrade your canister:</p>
<div class="sourceCode" id="cb154"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Add a controller (e.g., DAO or SNS)</span></span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> canister <span class="at">--network</span> ic update-settings openpatron <span class="dt">\</span></span>
<span id="cb154-3"><a href="#cb154-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">--add-controller</span> <span class="op">&lt;</span>principal-id<span class="op">&gt;</span></span>
<span id="cb154-4"><a href="#cb154-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-5"><a href="#cb154-5" aria-hidden="true" tabindex="-1"></a><span class="co"># List current controllers</span></span>
<span id="cb154-6"><a href="#cb154-6" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> canister <span class="at">--network</span> ic info openpatron</span>
<span id="cb154-7"><a href="#cb154-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-8"><a href="#cb154-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Remove yourself as controller (careful!)</span></span>
<span id="cb154-9"><a href="#cb154-9" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> canister <span class="at">--network</span> ic update-settings openpatron <span class="dt">\</span></span>
<span id="cb154-10"><a href="#cb154-10" aria-hidden="true" tabindex="-1"></a>  <span class="at">--remove-controller</span> <span class="op">&lt;</span>your-principal-id<span class="op">&gt;</span></span></code></pre></div>
<h3 id="the-black-hole-and-immutability">10.4 The Black Hole and
Immutability</h3>
<p>Once deployed, the developer controls the canister by default. To
build trust with users, you may choose to renounce this control—but this
decision is irreversible.</p>
<h4 id="understanding-black-holing">Understanding Black Holing</h4>
<p><strong>Black Holing</strong> means assigning the canister’s
controller to a non-existent address, making the code permanently
immutable:</p>
<div class="sourceCode" id="cb155"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ⚠️ </span><span class="al">WARNING</span><span class="co">: This action is IRREVERSIBLE</span></span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> canister <span class="at">--network</span> ic update-settings openpatron <span class="dt">\</span></span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">--set-controller</span> e3mmv-5qaaa-aaaaa-aaadma-cai</span></code></pre></div>
<p>The address <code>e3mmv-5qaaa-aaaaa-aaadma-cai</code> is a well-known
black hole address on the Internet Computer.</p>
<h4 id="pros-and-cons">Pros and Cons</h4>
<p><strong>Advantages:</strong></p>
<ul>
<li><p>✅ <strong>Trust:</strong> Users know the code cannot be changed
maliciously</p></li>
<li><p>✅ <strong>Censorship Resistance:</strong> No authority can
modify or shut down the canister</p></li>
<li><p>✅ <strong>Truly Decentralized:</strong> Achieves maximum
decentralization</p></li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li><p>❌ <strong>No Bug Fixes:</strong> If a critical bug exists, it
cannot be patched</p></li>
<li><p>❌ <strong>No Feature Updates:</strong> Cannot add new features
or optimizations</p></li>
<li><p>❌ <strong>No Upgrades:</strong> Cannot migrate to new patterns
or standards</p></li>
</ul>
<h4 id="the-middle-path-dao-governance">The Middle Path: DAO
Governance</h4>
<p>Rather than choosing between full control and complete immutability,
consider a third option:</p>
<p><strong>Transfer control to a DAO or SNS (Service Nervous
System):</strong> - Token holders vote on upgrades - Proposals require
community consensus - Maintains upgradeability while distributing power
- We’ll explore this in Chapter 11</p>
<h3 id="monitoring-and-maintenance">10.5 Monitoring and Maintenance</h3>
<p>Successful deployment is just the beginning. Ongoing monitoring is
essential.</p>
<h4 id="key-metrics-to-track">Key Metrics to Track</h4>
<ol type="1">
<li><strong>Cycle Consumption Rate</strong>
<ul>
<li>Daily burn rate</li>
<li>Cost per user/transaction</li>
<li>Storage growth</li>
</ul></li>
<li><strong>Performance Metrics</strong>
<ul>
<li>Response times</li>
<li>Error rates</li>
<li>Concurrent users</li>
</ul></li>
<li><strong>Business Metrics</strong>
<ul>
<li>Active users</li>
<li>Transaction volume</li>
<li>Revenue vs. costs</li>
</ul></li>
</ol>
<h4 id="implementing-canister-logging">Implementing Canister
Logging</h4>
<pre class="motoko"><code>import Time &quot;mo:base/Time&quot;;
import Buffer &quot;mo:base/Buffer&quot;;
import Array &quot;mo:base/Array&quot;;

actor OpenPatron {
    
    type LogEntry = {
        timestamp : Time.Time;
        level : LogLevel;
        message : Text;
    };
    
    type LogLevel = {
        #info;
        #warning;
        #error;
    };
    
    private stable var logs : [LogEntry] = [];
    private let logBuffer = Buffer.Buffer&lt;LogEntry&gt;(100);
    
    // Add log entry
    private func log(level : LogLevel, message : Text) {
        let entry : LogEntry = {
            timestamp = Time.now();
            level = level;
            message = message;
        };
        
        logBuffer.add(entry);
        
        // Keep only last 1000 logs to manage memory
        if (logBuffer.size() &gt; 1000) {
            ignore logBuffer.remove(0);
        };
    };
    
    // Query recent logs
    public query func getLogs(count : Nat) : async [LogEntry] {
        let size = logBuffer.size();
        let start = if (size &gt; count) { size - count } else { 0 };
        
        Array.tabulate&lt;LogEntry&gt;(
            count,
            func(i) {
                if (start + i &lt; size) {
                    logBuffer.get(start + i)
                } else {
                    {
                        timestamp = 0;
                        level = #info;
                        message = &quot;&quot;;
                    }
                }
            }
        )
    };
    
    // Example: Log subscription event
    public shared func createSubscription() : async () {
        log(#info, &quot;New subscription created&quot;);
        // ... subscription logic
    };
};</code></pre>
<h3 id="cost-optimization-strategies">10.6 Cost Optimization
Strategies</h3>
<p>Minimize cycle consumption without sacrificing functionality:</p>
<h4 id="efficient-data-structures">1. Efficient Data Structures</h4>
<p>Use the right data structure for your access patterns:</p>
<pre class="motoko"><code>// ❌ Inefficient: Array for frequent lookups
private stable var users : [User] = [];

// ✅ Efficient: HashMap for O(1) lookups
import HashMap &quot;mo:base/HashMap&quot;;
private var users = HashMap.HashMap&lt;Principal, User&gt;(10, Principal.equal, Principal.hash);</code></pre>
<h4 id="lazy-loading">2. Lazy Loading</h4>
<p>Don’t load data you don’t need:</p>
<pre class="motoko"><code>// Only load necessary fields
public query func getUserProfile(userId : Principal) : async ?UserProfile {
    switch (users.get(userId)) {
        case null { null };
        case (?user) {
            // Return minimal profile, not entire user object
            ?{
                name = user.name;
                avatar = user.avatar;
                // Don&#39;t include large fields like full subscription history
            }
        };
    };
};</code></pre>
<h4 id="query-calls-when-possible">3. Query Calls When Possible</h4>
<p>Query calls don’t consume consensus cycles:</p>
<pre class="motoko"><code>// ✅ Use query for read-only operations
public query func getSubscriptions() : async [Subscription] {
    // No state modification
};

// ❌ Don&#39;t use update calls for reads
public shared func getSubscriptions() : async [Subscription] {
    // Wastes cycles on consensus
};</code></pre>
<h4 id="batch-operations">4. Batch Operations</h4>
<p>Reduce overhead by batching:</p>
<pre class="motoko"><code>// ✅ Process multiple items in one call
public shared func batchSubscribe(creatorIds : [Principal]) : async [Result.Result&lt;(), Text&gt;] {
    Array.map(creatorIds, func(id : Principal) : Result.Result&lt;(), Text&gt; {
        // Process subscription
        #ok()
    })
};</code></pre>
<h3 id="upgrade-strategies">10.7 Upgrade Strategies</h3>
<p>If you retain control of your canister, plan your upgrade strategy
carefully.</p>
<h4 id="stable-variables-and-persistence">Stable Variables and
Persistence</h4>
<p>Use <code>stable</code> keyword to preserve data across upgrades:</p>
<pre class="motoko"><code>actor OpenPatron {
    // ✅ Persists across upgrades
    private stable var subscriptionCount : Nat = 0;
    
    // ❌ Resets to empty on upgrade
    private var cache : HashMap.HashMap&lt;Principal, User&gt; = HashMap.HashMap(10, Principal.equal, Principal.hash);
    
    // Restore non-stable data after upgrade
    system func postupgrade() {
        // Rebuild cache from stable storage
        // cache := rebuildCache();
    };
};</code></pre>
<h4 id="testing-upgrades">Testing Upgrades</h4>
<p>Always test upgrades on a testnet first:</p>
<div class="sourceCode" id="cb162"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. Deploy initial version</span></span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> deploy <span class="at">--network</span> ic openpatron</span>
<span id="cb162-3"><a href="#cb162-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-4"><a href="#cb162-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. Add some test data</span></span>
<span id="cb162-5"><a href="#cb162-5" aria-hidden="true" tabindex="-1"></a><span class="co"># ... interact with canister ...</span></span>
<span id="cb162-6"><a href="#cb162-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-7"><a href="#cb162-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. Make changes to code</span></span>
<span id="cb162-8"><a href="#cb162-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-9"><a href="#cb162-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 4. Upgrade</span></span>
<span id="cb162-10"><a href="#cb162-10" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> deploy <span class="at">--network</span> ic openpatron <span class="at">--mode</span> upgrade</span>
<span id="cb162-11"><a href="#cb162-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-12"><a href="#cb162-12" aria-hidden="true" tabindex="-1"></a><span class="co"># 5. Verify data persisted</span></span>
<span id="cb162-13"><a href="#cb162-13" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> canister <span class="at">--network</span> ic call openpatron getSubscriptionCount</span></code></pre></div>
<h3 id="case-study-openpatron-deployment-costs">10.8 Case Study:
OpenPatron Deployment Costs</h3>
<p>Let’s estimate the real-world costs for OpenPatron at different
scales:</p>
<h4 id="small-scale-1000-users">Small Scale (1,000 users)</h4>
<ul>
<li><strong>Storage:</strong> ~50 MB → 8.4M cycles/day → 252M
cycles/month</li>
<li><strong>Computation:</strong> ~100 transactions/day → 500M
cycles/month</li>
<li><strong>Total:</strong> ~752M cycles/month ≈ $0.98/month</li>
</ul>
<h4 id="medium-scale-50000-users">Medium Scale (50,000 users)</h4>
<ul>
<li><strong>Storage:</strong> ~2.5 GB → 420M cycles/day → 12.6B
cycles/month</li>
<li><strong>Computation:</strong> ~5,000 transactions/day → 25B
cycles/month</li>
<li><strong>Total:</strong> ~37.6B cycles/month ≈ $48.88/month</li>
</ul>
<h4 id="large-scale-1m-users">Large Scale (1M users)</h4>
<ul>
<li><strong>Storage:</strong> ~50 GB → 8.4B cycles/day → 252B
cycles/month</li>
<li><strong>Computation:</strong> ~100K transactions/day → 500B
cycles/month</li>
<li><strong>Total:</strong> ~752B cycles/month ≈ $977.60/month</li>
</ul>
<p><strong>Key Insight:</strong> Even at 1 million users, the platform
costs less than $1,000/month—dramatically cheaper than traditional cloud
infrastructure with comparable features and security.</p>
<h3 id="summary-3">10.9 Summary</h3>
<p>Deploying to the Internet Computer requires understanding:</p>
<ol type="1">
<li><strong>Cycles:</strong> The stable-cost fuel that powers
canisters</li>
<li><strong>Sustainability:</strong> Building revenue models to fund
ongoing operations</li>
<li><strong>Monitoring:</strong> Tracking cycle consumption and
performance</li>
<li><strong>Optimization:</strong> Minimizing costs through efficient
code</li>
<li><strong>Immutability:</strong> The trade-offs of black-holing
vs. upgradability</li>
<li><strong>Governance:</strong> Alternative control models through
DAOs/SNS</li>
</ol>
<p>The reverse gas model is a powerful feature that enables true Web3
UX, but it requires developers to think like product owners and
economists, not just engineers.</p>
<p>In the next chapter, we’ll explore how to hand over control of
OpenPatron to its community through the Service Nervous System (SNS),
creating true decentralized governance.</p>
<hr />
<hr />
<h1 id="chapter-13-the-service-nervous-system-sns">Chapter 13: The
Service Nervous System (SNS)</h1>
<p>The superior alternative to Black Holing is the <strong>Service
Nervous System (SNS)</strong>. This is an algorithmic DAO framework
provided by the Internet Computer protocol itself, offering a
standardized, battle-tested solution for decentralized governance.</p>
<p>By handing control of OpenPatron to an SNS, you transform it from a
centrally-controlled application into a truly decentralized autonomous
organization where the community—not the developer—owns, governs, and
evolves the platform.</p>
<h3 id="the-architecture-of-sns">11.1 The Architecture of SNS</h3>
<p>An SNS is not a single canister, but a sophisticated
<strong>multi-canister system</strong> that provides complete governance
infrastructure:</p>
<h4 id="the-four-core-canisters">The Four Core Canisters</h4>
<ol type="1">
<li><strong>Governance Canister</strong>
<ul>
<li>Stores all proposals and voting records</li>
<li>Manages staked tokens (neurons)</li>
<li>Executes approved proposals automatically</li>
<li>Implements voting power calculations and rewards</li>
</ul></li>
<li><strong>Ledger Canister</strong>
<ul>
<li>Implements ICRC-1 token standard</li>
<li>Tracks token balances and transfers</li>
<li>Handles staking and unstaking operations</li>
<li>Maintains complete transaction history</li>
</ul></li>
<li><strong>Root Canister</strong>
<ul>
<li>Acts as the controller of your dapp canisters</li>
<li>Executes upgrade commands from governance</li>
<li>Manages canister lifecycle operations</li>
<li>Provides a security boundary</li>
</ul></li>
<li><strong>Index Canister</strong>
<ul>
<li>Indexes ledger transactions</li>
<li>Enables fast balance queries</li>
<li>Powers analytics and reporting</li>
<li>Optimizes historical data access</li>
</ul></li>
</ol>
<pre><code>┌─────────────────────────────────────────────────┐
│                  SNS System                     │
├─────────────────────────────────────────────────┤
│                                                 │
│  ┌──────────────┐      ┌──────────────┐       │
│  │  Governance  │◄────►│    Ledger    │       │
│  │   Canister   │      │   Canister   │       │
│  └──────┬───────┘      └──────────────┘       │
│         │                                       │
│         │ Execute Proposals                    │
│         ▼                                       │
│  ┌──────────────┐      ┌──────────────┐       │
│  │     Root     │◄────►│    Index     │       │
│  │   Canister   │      │   Canister   │       │
│  └──────┬───────┘      └──────────────┘       │
│         │                                       │
│         │ Controls                              │
│         ▼                                       │
│  ┌──────────────┐      ┌──────────────┐       │
│  │  OpenPatron  │◄────►│  OpenPatron  │       │
│  │   Frontend   │      │    Backend   │       │
│  └──────────────┘      └──────────────┘       │
│                                                 │
└─────────────────────────────────────────────────┘</code></pre>
<h3 id="neurons-the-foundation-of-governance">11.2 Neurons: The
Foundation of Governance</h3>
<p>In an SNS, token holders don’t vote directly. Instead, they create
<strong>neurons</strong> by staking (locking) their tokens for a
specified period. This design incentivizes long-term thinking and
prevents short-term speculation from dominating governance.</p>
<h4 id="neuron-properties">Neuron Properties</h4>
<p>Each neuron has several key attributes that determine its voting
power:</p>
<pre class="motoko"><code>type Neuron = {
    // Unique identifier
    id : NeuronId;
    
    // Amount of tokens staked
    stake : Nat;
    
    // Time when neuron was created
    createdAt : Time.Time;
    
    // Minimum lock period (6 months to 8 years)
    dissolveDelay : Nat;
    
    // Current state: locked, dissolving, or dissolved
    state : NeuronState;
    
    // Age bonus (max 4 years)
    age : Nat;
    
    // Voting history and participation
    votingPower : Nat;
};

type NeuronState = {
    #Locked;
    #Dissolving;
    #Dissolved;
};</code></pre>
<h4 id="voting-power-calculation">Voting Power Calculation</h4>
<p>Voting power is not simply proportional to stake. It incorporates
multiple factors:</p>
<pre><code>Voting Power = Stake × Dissolve Delay Bonus × Age Bonus</code></pre>
<p><strong>Dissolve Delay Bonus:</strong> - Maximum bonus: 2× (for
8-year lock) - Minimum: 1× (for 6-month lock) - Formula:
<code>1 + (dissolveDelay / maxDissolveDelay)</code></p>
<p><strong>Age Bonus:</strong> - Maximum bonus: 1.25× (after 4 years) -
Grows linearly over time - Resets when tokens are withdrawn</p>
<p><strong>Example Calculation:</strong></p>
<pre class="motoko"><code>// Alice: 1,000 tokens, 2-year lock, 1-year age
Stake: 1,000
Dissolve Bonus: 1 + (2 years / 8 years) = 1.25
Age Bonus: 1 + (1 year / 4 years × 0.25) = 1.0625
Voting Power: 1,000 × 1.25 × 1.0625 = 1,328 votes

// Bob: 500 tokens, 8-year lock, 4-year age
Stake: 500
Dissolve Bonus: 1 + (8 years / 8 years) = 2.0
Age Bonus: 1 + 0.25 = 1.25
Voting Power: 500 × 2.0 × 1.25 = 1,250 votes

// Despite having half the stake, Bob has nearly equal power
// due to long-term commitment</code></pre>
<h3 id="proposal-types-and-governance">11.3 Proposal Types and
Governance</h3>
<p>SNS governance operates through <strong>proposals</strong>. Any
neuron holder can submit a proposal, and all neurons can vote. If a
proposal reaches the required threshold, it executes automatically.</p>
<h4 id="standard-proposal-types">Standard Proposal Types</h4>
<ol type="1">
<li><strong>Motion Proposals</strong>
<ul>
<li>Non-executable governance decisions</li>
<li>Community sentiment polls</li>
<li>Strategic direction discussions</li>
<li>Example: “Should we integrate with protocol X?”</li>
</ul></li>
<li><strong>Upgrade Canister Proposals</strong>
<ul>
<li>Deploy new Wasm code to canisters</li>
<li>Most critical proposal type</li>
<li>Example: “Deploy v2.0 with subscription tiers”</li>
</ul></li>
<li><strong>Transfer SNS Treasury Funds</strong>
<ul>
<li>Move tokens from DAO treasury</li>
<li>Fund development or partnerships</li>
<li>Example: “Allocate 50K tokens to marketing campaign”</li>
</ul></li>
<li><strong>Parameter Change Proposals</strong>
<ul>
<li>Modify governance parameters</li>
<li>Adjust voting thresholds, rewards, etc.</li>
<li>Example: “Increase minimum dissolve delay to 1 year”</li>
</ul></li>
<li><strong>Add/Remove Controlled Canister</strong>
<ul>
<li>Expand or reduce SNS scope</li>
<li>Add new canisters to governance</li>
<li>Example: “Add OpenPatron mobile app canister”</li>
</ul></li>
</ol>
<h4 id="proposal-lifecycle">Proposal Lifecycle</h4>
<pre class="motoko"><code>type ProposalStatus = {
    #Open;      // Currently accepting votes
    #Rejected;  // Failed to reach threshold
    #Executed;  // Approved and executed
    #Failed;    // Execution failed
};

type Proposal = {
    id : ProposalId;
    proposer : NeuronId;
    
    // Proposal content
    title : Text;
    summary : Text;
    url : ?Text;  // Link to detailed discussion
    
    // Execution payload
    action : ProposalAction;
    
    // Voting data
    votesYes : Nat;
    votesNo : Nat;
    status : ProposalStatus;
    
    // Timing
    proposedAt : Time.Time;
    decidedAt : ?Time.Time;
    executedAt : ?Time.Time;
};</code></pre>
<p><strong>Voting Period:</strong> - Typical duration: 4-7 days - Early
adoption: Proposal can pass before deadline if threshold met - Absolute
majority required: &gt;50% of total voting power</p>
<h4 id="example-submitting-an-upgrade-proposal">Example: Submitting an
Upgrade Proposal</h4>
<pre class="motoko"><code>import SNS &quot;mo:sns/Governance&quot;;
import Blob &quot;mo:base/Blob&quot;;

actor OpenPatronGovernance {
    
    let snsGovernance : SNS.Governance = actor(&quot;rrkah-fqaaa-aaaaa-aaaaq-cai&quot;);
    
    // Submit a proposal to upgrade OpenPatron
    public shared({ caller }) func proposeUpgrade(
        wasmModule : Blob,
        title : Text,
        summary : Text
    ) : async Result.Result&lt;ProposalId, Text&gt; {
        
        // Validate caller has a neuron
        let neuronId = switch (await snsGovernance.getNeuronByPrincipal(caller)) {
            case null { return #err(&quot;Must have a neuron to propose&quot;) };
            case (?n) { n.id };
        };
        
        // Create upgrade proposal
        let proposal = {
            title = title;
            summary = summary;
            url = ?&quot;https://github.com/openpatron/proposals/001&quot;;
            action = #UpgradeCanister({
                canisterId = Principal.fromText(&quot;bd3sg-teaaa-aaaaa-qaaba-cai&quot;);
                wasm = wasmModule;
                arg = [];
            });
        };
        
        // Submit to governance
        let result = await snsGovernance.submitProposal(proposal, neuronId);
        
        switch (result) {
            case (#ok(proposalId)) {
                #ok(proposalId)
            };
            case (#err(msg)) {
                #err(&quot;Proposal failed: &quot; # msg)
            };
        };
    };
};</code></pre>
<h3 id="voting-mechanisms">11.4 Voting Mechanisms</h3>
<p>SNS implements multiple voting strategies to ensure efficient
governance while preventing manipulation.</p>
<h4 id="manual-voting">Manual Voting</h4>
<p>Token holders actively vote on each proposal:</p>
<pre class="motoko"><code>// Vote on a proposal
public shared({ caller }) func vote(
    proposalId : ProposalId,
    vote : Vote
) : async Result.Result&lt;(), Text&gt; {
    
    let neuronId = await getUserNeuron(caller);
    
    await snsGovernance.registerVote({
        proposalId = proposalId;
        neuronId = neuronId;
        vote = vote;  // #Yes or #No
    });
};

type Vote = {
    #Yes;
    #No;
};</code></pre>
<h4 id="following-liquid-democracy">Following (Liquid Democracy)</h4>
<p>Neurons can “follow” other neurons, delegating their voting
power:</p>
<pre class="motoko"><code>type Following = {
    followees : [NeuronId];  // List of neurons to follow
    topic : ?ProposalTopic;  // Specific topic or all topics
};

// Set up following relationship
public shared({ caller }) func follow(
    followee : NeuronId,
    topic : ?ProposalTopic
) : async Result.Result&lt;(), Text&gt; {
    
    let myNeuron = await getUserNeuron(caller);
    
    // Delegate voting power to another neuron
    await snsGovernance.setFollowing(
        myNeuron,
        followee,
        topic
    );
};</code></pre>
<p>This creates a “liquid democracy” where: - Technical proposals can be
delegated to expert developers - Business proposals can be delegated to
business-focused members - Voting power flows efficiently to those with
relevant expertise</p>
<h4 id="voting-rewards">Voting Rewards</h4>
<p>To incentivize participation, SNS distributes <strong>voting
rewards</strong>:</p>
<pre class="motoko"><code>type VotingRewards = {
    // Total rewards pool (percentage of supply)
    annualRewardRate : Float;  // e.g., 10% APY
    
    // Distribution
    participationRequired : Float;  // Must vote on &gt;50% of proposals
    
    // Compound into neuron
    autoStake : Bool;
};

// Calculate rewards for a neuron
private func calculateRewards(neuron : Neuron) : Nat {
    let participation = neuron.votesCount / totalProposals;
    
    if (participation &lt; 0.5) {
        return 0;  // Didn&#39;t meet threshold
    };
    
    let yearlyReward = neuron.stake * annualRewardRate;
    let dailyReward = yearlyReward / 365;
    
    return dailyReward;
};</code></pre>
<h3 id="token-economics-and-distribution">11.5 Token Economics and
Distribution</h3>
<p>Launching an SNS requires careful planning of token distribution to
ensure decentralization and fair governance.</p>
<h4 id="the-sns-swap">The SNS Swap</h4>
<p>The standard launch mechanism is a <strong>decentralization
swap</strong>:</p>
<ol type="1">
<li><strong>Developer Contribution:</strong>
<ul>
<li>Developer contributes their dapp canisters to SNS</li>
<li>Receives allocation of governance tokens (typically 10-30%)</li>
<li>Tokens subject to vesting schedule</li>
</ul></li>
<li><strong>Public Fundraise:</strong>
<ul>
<li>Open token sale to community</li>
<li>Participants receive governance tokens</li>
<li>Funds go to DAO treasury</li>
<li>Typically 40-60% of supply</li>
</ul></li>
<li><strong>Developer Team:</strong>
<ul>
<li>Team receives tokens for ongoing development</li>
<li>Long vesting period (2-4 years)</li>
<li>10-20% of supply</li>
</ul></li>
<li><strong>Treasury:</strong>
<ul>
<li>Reserved for future development</li>
<li>Grants and incentives</li>
<li>10-20% of supply</li>
</ul></li>
</ol>
<p><strong>Example Distribution for OpenPatron:</strong></p>
<pre><code>Total Supply: 100,000,000 tokens

Initial Distribution:
- Public Swap:     50,000,000 (50%)  → Community governance
- Developer Fund:  15,000,000 (15%)  → Original builders (2-year vest)
- Treasury:        20,000,000 (20%)  → Future grants and development
- Early Investors: 10,000,000 (10%)  → Seed funding (1-year vest)
- Airdrop:          5,000,000 (5%)   → Early platform users

Vesting Schedules:
- Developer Fund: 6-month cliff, 2-year linear vest
- Early Investors: 3-month cliff, 1-year linear vest
- Treasury: Controlled by governance proposals</code></pre>
<h4 id="swap-configuration">Swap Configuration</h4>
<pre class="motoko"><code>type SwapParameters = {
    // Fundraising goals
    minParticipants : Nat;        // e.g., 100 minimum participants
    minICPPerParticipant : Nat;   // e.g., 1 ICP minimum
    maxICPPerParticipant : Nat;   // e.g., 10,000 ICP maximum
    
    // Total raise
    minICPTarget : Nat;           // e.g., 100,000 ICP
    maxICPTarget : Nat;           // e.g., 1,000,000 ICP
    
    // Token allocation
    tokensForSale : Nat;          // e.g., 50M tokens
    
    // Duration
    swapStartTime : Time.Time;
    swapDuration : Nat;           // e.g., 7 days
    
    // Restrictions
    neuronMinDissolveDelay : Nat; // e.g., 6 months
};</code></pre>
<h3 id="practical-implementation-sns-enabling-openpatron">11.6 Practical
Implementation: SNS-Enabling OpenPatron</h3>
<p>Let’s walk through the process of handing OpenPatron to an SNS.</p>
<h4 id="step-1-prepare-your-canisters">Step 1: Prepare Your
Canisters</h4>
<p>Ensure your canisters are production-ready:</p>
<div class="sourceCode" id="cb174"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Audit checklist</span></span>
<span id="cb174-2"><a href="#cb174-2" aria-hidden="true" tabindex="-1"></a><span class="ex">✓</span> Security audit completed</span>
<span id="cb174-3"><a href="#cb174-3" aria-hidden="true" tabindex="-1"></a><span class="ex">✓</span> All tests passing</span>
<span id="cb174-4"><a href="#cb174-4" aria-hidden="true" tabindex="-1"></a><span class="ex">✓</span> Cycle management implemented</span>
<span id="cb174-5"><a href="#cb174-5" aria-hidden="true" tabindex="-1"></a><span class="ex">✓</span> Monitoring in place</span>
<span id="cb174-6"><a href="#cb174-6" aria-hidden="true" tabindex="-1"></a><span class="ex">✓</span> Documentation complete</span>
<span id="cb174-7"><a href="#cb174-7" aria-hidden="true" tabindex="-1"></a><span class="ex">✓</span> Community ready for governance</span></code></pre></div>
<h4 id="step-2-create-sns-configuration">Step 2: Create SNS
Configuration</h4>
<p>Define your governance parameters in <code>sns.yml</code>:</p>
<div class="sourceCode" id="cb175"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a><span class="co"># OpenPatron SNS Configuration</span></span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Token Information</span></span>
<span id="cb175-4"><a href="#cb175-4" aria-hidden="true" tabindex="-1"></a><span class="fu">token</span><span class="kw">:</span></span>
<span id="cb175-5"><a href="#cb175-5" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">name</span><span class="kw">:</span><span class="at"> </span><span class="st">&quot;OpenPatron Governance Token&quot;</span></span>
<span id="cb175-6"><a href="#cb175-6" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">symbol</span><span class="kw">:</span><span class="at"> </span><span class="st">&quot;OPG&quot;</span></span>
<span id="cb175-7"><a href="#cb175-7" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">total_supply</span><span class="kw">:</span><span class="at"> </span><span class="dv">100_000_000_000_000</span><span class="co">  # 100M tokens (8 decimals)</span></span>
<span id="cb175-8"><a href="#cb175-8" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">transaction_fee</span><span class="kw">:</span><span class="at"> </span><span class="dv">10_000</span><span class="co">             # 0.0001 OPG</span></span>
<span id="cb175-9"><a href="#cb175-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-10"><a href="#cb175-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial Token Distribution</span></span>
<span id="cb175-11"><a href="#cb175-11" aria-hidden="true" tabindex="-1"></a><span class="fu">distribution</span><span class="kw">:</span></span>
<span id="cb175-12"><a href="#cb175-12" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">developers</span><span class="kw">:</span></span>
<span id="cb175-13"><a href="#cb175-13" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">amount</span><span class="kw">:</span><span class="at"> </span><span class="dv">15_000_000_000_000</span></span>
<span id="cb175-14"><a href="#cb175-14" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">vesting_period_months</span><span class="kw">:</span><span class="at"> </span><span class="dv">24</span></span>
<span id="cb175-15"><a href="#cb175-15" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">cliff_months</span><span class="kw">:</span><span class="at"> </span><span class="dv">6</span></span>
<span id="cb175-16"><a href="#cb175-16" aria-hidden="true" tabindex="-1"></a><span class="at">  </span></span>
<span id="cb175-17"><a href="#cb175-17" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">treasury</span><span class="kw">:</span></span>
<span id="cb175-18"><a href="#cb175-18" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">amount</span><span class="kw">:</span><span class="at"> </span><span class="dv">20_000_000_000_000</span></span>
<span id="cb175-19"><a href="#cb175-19" aria-hidden="true" tabindex="-1"></a><span class="at">  </span></span>
<span id="cb175-20"><a href="#cb175-20" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">swap</span><span class="kw">:</span></span>
<span id="cb175-21"><a href="#cb175-21" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">amount</span><span class="kw">:</span><span class="at"> </span><span class="dv">50_000_000_000_000</span></span>
<span id="cb175-22"><a href="#cb175-22" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">min_participants</span><span class="kw">:</span><span class="at"> </span><span class="dv">100</span></span>
<span id="cb175-23"><a href="#cb175-23" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">min_icp</span><span class="kw">:</span><span class="at"> </span><span class="dv">1_000_000_000</span><span class="co">      # 10 ICP</span></span>
<span id="cb175-24"><a href="#cb175-24" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">max_icp</span><span class="kw">:</span><span class="at"> </span><span class="dv">10_000_000_000_000</span><span class="co"> # 100,000 ICP per person</span></span>
<span id="cb175-25"><a href="#cb175-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-26"><a href="#cb175-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Governance Parameters</span></span>
<span id="cb175-27"><a href="#cb175-27" aria-hidden="true" tabindex="-1"></a><span class="fu">governance</span><span class="kw">:</span></span>
<span id="cb175-28"><a href="#cb175-28" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">proposal_submission_deposit</span><span class="kw">:</span><span class="at"> </span><span class="dv">1_000_000_000</span><span class="co">  # 10 OPG</span></span>
<span id="cb175-29"><a href="#cb175-29" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">proposal_rejection_fee</span><span class="kw">:</span><span class="at"> </span><span class="dv">100_000_000</span><span class="co">         # 1 OPG</span></span>
<span id="cb175-30"><a href="#cb175-30" aria-hidden="true" tabindex="-1"></a><span class="at">  </span></span>
<span id="cb175-31"><a href="#cb175-31" aria-hidden="true" tabindex="-1"></a><span class="co">  # Voting</span></span>
<span id="cb175-32"><a href="#cb175-32" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">minimum_yes_proportion</span><span class="kw">:</span><span class="at"> </span><span class="fl">0.03</span><span class="co">  # 3% quorum</span></span>
<span id="cb175-33"><a href="#cb175-33" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">voting_period_seconds</span><span class="kw">:</span><span class="at"> </span><span class="dv">345_600</span><span class="co">  # 4 days</span></span>
<span id="cb175-34"><a href="#cb175-34" aria-hidden="true" tabindex="-1"></a><span class="at">  </span></span>
<span id="cb175-35"><a href="#cb175-35" aria-hidden="true" tabindex="-1"></a><span class="co">  # Neuron parameters</span></span>
<span id="cb175-36"><a href="#cb175-36" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">min_dissolve_delay_seconds</span><span class="kw">:</span><span class="at"> </span><span class="dv">15_552_000</span><span class="co">  # 6 months</span></span>
<span id="cb175-37"><a href="#cb175-37" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">max_dissolve_delay_seconds</span><span class="kw">:</span><span class="at"> </span><span class="dv">252_460_800</span><span class="co"> # 8 years</span></span>
<span id="cb175-38"><a href="#cb175-38" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">max_age_bonus</span><span class="kw">:</span><span class="at"> </span><span class="fl">0.25</span><span class="co">  # 25% bonus after 4 years</span></span>
<span id="cb175-39"><a href="#cb175-39" aria-hidden="true" tabindex="-1"></a><span class="at">  </span></span>
<span id="cb175-40"><a href="#cb175-40" aria-hidden="true" tabindex="-1"></a><span class="co">  # Rewards</span></span>
<span id="cb175-41"><a href="#cb175-41" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">voting_reward_rate</span><span class="kw">:</span><span class="at"> </span><span class="fl">0.10</span><span class="co">  # 10% APY</span></span>
<span id="cb175-42"><a href="#cb175-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-43"><a href="#cb175-43" aria-hidden="true" tabindex="-1"></a><span class="co"># Controlled Canisters</span></span>
<span id="cb175-44"><a href="#cb175-44" aria-hidden="true" tabindex="-1"></a><span class="fu">dapp_canisters</span><span class="kw">:</span></span>
<span id="cb175-45"><a href="#cb175-45" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> bd3sg-teaaa-aaaaa-qaaba-cai</span><span class="co">  # OpenPatron Backend</span></span>
<span id="cb175-46"><a href="#cb175-46" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> bkyz2-fmaaa-aaaaa-qaaaq-cai</span><span class="co">  # OpenPatron Frontend</span></span></code></pre></div>
<h4 id="step-3-deploy-sns">Step 3: Deploy SNS</h4>
<p>Use the SNS CLI tooling:</p>
<div class="sourceCode" id="cb176"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Install SNS tools</span></span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> extension install sns</span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-4"><a href="#cb176-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize SNS configuration</span></span>
<span id="cb176-5"><a href="#cb176-5" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> sns init</span>
<span id="cb176-6"><a href="#cb176-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-7"><a href="#cb176-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Validate configuration</span></span>
<span id="cb176-8"><a href="#cb176-8" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> sns validate</span>
<span id="cb176-9"><a href="#cb176-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-10"><a href="#cb176-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Deploy to testnet first</span></span>
<span id="cb176-11"><a href="#cb176-11" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> sns deploy <span class="at">--network</span> ic <span class="at">--testnet</span></span>
<span id="cb176-12"><a href="#cb176-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-13"><a href="#cb176-13" aria-hidden="true" tabindex="-1"></a><span class="co"># After testing, deploy to mainnet</span></span>
<span id="cb176-14"><a href="#cb176-14" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> sns deploy <span class="at">--network</span> ic</span></code></pre></div>
<h4 id="step-4-launch-decentralization-swap">Step 4: Launch
Decentralization Swap</h4>
<div class="sourceCode" id="cb177"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Initiate the token swap</span></span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> sns swap start <span class="dt">\</span></span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">--network</span> ic <span class="dt">\</span></span>
<span id="cb177-4"><a href="#cb177-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">--sns-governance-canister-id</span> rrkah-fqaaa-aaaaa-aaaaq-cai</span>
<span id="cb177-5"><a href="#cb177-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-6"><a href="#cb177-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Monitor swap progress</span></span>
<span id="cb177-7"><a href="#cb177-7" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> sns swap status <span class="at">--network</span> ic</span>
<span id="cb177-8"><a href="#cb177-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-9"><a href="#cb177-9" aria-hidden="true" tabindex="-1"></a><span class="co"># After successful swap, finalize</span></span>
<span id="cb177-10"><a href="#cb177-10" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> sns swap finalize <span class="at">--network</span> ic</span></code></pre></div>
<h4 id="step-5-transfer-control">Step 5: Transfer Control</h4>
<p>Once the swap completes successfully, control automatically
transfers:</p>
<div class="sourceCode" id="cb178"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Verify SNS is now the controller</span></span>
<span id="cb178-2"><a href="#cb178-2" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> canister <span class="at">--network</span> ic info bd3sg-teaaa-aaaaa-qaaba-cai</span>
<span id="cb178-3"><a href="#cb178-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-4"><a href="#cb178-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Output shows:</span></span>
<span id="cb178-5"><a href="#cb178-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Controllers: rrkah-fqaaa-aaaaa-aaaaq-cai (SNS Root Canister)</span></span>
<span id="cb178-6"><a href="#cb178-6" aria-hidden="true" tabindex="-1"></a><span class="co">#              [Your principal removed]</span></span></code></pre></div>
<p><strong>You no longer control OpenPatron. The DAO does.</strong></p>
<h3 id="integrating-sns-governance-into-your-dapp">11.7 Integrating SNS
Governance into Your Dapp</h3>
<p>Once governed by an SNS, your canisters should expose
governance-friendly interfaces.</p>
<h4 id="admin-functions-behind-governance">Admin Functions Behind
Governance</h4>
<pre class="motoko"><code>import Principal &quot;mo:base/Principal&quot;;

actor OpenPatron {
    
    // The SNS Root canister that controls this canister
    private let SNS_ROOT : Principal = 
        Principal.fromText(&quot;rrkah-fqaaa-aaaaa-aaaaq-cai&quot;);
    
    // Only SNS governance can call this
    private func assertGovernance(caller : Principal) {
        if (caller != SNS_ROOT) {
            Debug.trap(&quot;Only SNS governance can call this function&quot;);
        };
    };
    
    // Configuration changes require proposal
    private stable var platformFeePercent : Nat = 1;
    
    public shared({ caller }) func setPlatformFee(
        newFee : Nat
    ) : async () {
        assertGovernance(caller);
        
        if (newFee &gt; 10) {
            Debug.trap(&quot;Fee cannot exceed 10%&quot;);
        };
        
        platformFeePercent := newFee;
    };
    
    // Upgrade hooks for migration
    system func preupgrade() {
        // Save state before upgrade
    };
    
    system func postupgrade() {
        // Restore state after upgrade
        // Perform any necessary migrations
    };
};</code></pre>
<h4 id="exposing-governance-metrics">Exposing Governance Metrics</h4>
<p>Help token holders make informed decisions:</p>
<pre class="motoko"><code>// Provide metrics for governance proposals
public query func getGovernanceMetrics() : async GovernanceMetrics {
    {
        totalUsers = users.size();
        totalCreators = creators.size();
        totalSubscriptions = subscriptions.size();
        
        monthlyRevenue = calculateMonthlyRevenue();
        treasuryBalance = treasuryBalance;
        
        cycleBalance = Cycles.balance();
        estimatedMonthsOfRuntime = Cycles.balance() / averageMonthlyCost;
        
        platformFee = platformFeePercent;
        averageSubscriptionPrice = calculateAveragePrice();
    }
};

type GovernanceMetrics = {
    // Usage
    totalUsers : Nat;
    totalCreators : Nat;
    totalSubscriptions : Nat;
    
    // Economics
    monthlyRevenue : Nat;
    treasuryBalance : Nat;
    
    // Health
    cycleBalance : Nat;
    estimatedMonthsOfRuntime : Nat;
    
    // Configuration
    platformFee : Nat;
    averageSubscriptionPrice : Nat;
};</code></pre>
<h3 id="benefits-and-trade-offs">11.8 Benefits and Trade-offs</h3>
<h4 id="advantages-of-sns-governance">Advantages of SNS Governance</h4>
<ol type="1">
<li><strong>True Decentralization</strong>
<ul>
<li>No single point of control</li>
<li>Community-owned and operated</li>
<li>Censorship-resistant</li>
</ul></li>
<li><strong>Legitimacy</strong>
<ul>
<li>Token holders have skin in the game</li>
<li>Aligned incentives between users and governors</li>
<li>Transparent decision-making</li>
</ul></li>
<li><strong>Flexibility</strong>
<ul>
<li>Can upgrade and evolve unlike black-holed canisters</li>
<li>Adapt to changing market conditions</li>
<li>Fix bugs and add features</li>
</ul></li>
<li><strong>Economic Alignment</strong>
<ul>
<li>Token value tied to platform success</li>
<li>Governance tokens can be traded</li>
<li>Creates stakeholder ecosystem</li>
</ul></li>
<li><strong>Ecosystem Integration</strong>
<ul>
<li>Standard interface recognized across ICP</li>
<li>Composability with other SNS DAOs</li>
<li>Access to shared governance tools</li>
</ul></li>
</ol>
<h4 id="challenges-and-considerations">Challenges and
Considerations</h4>
<ol type="1">
<li><strong>Complexity</strong>
<ul>
<li>More complicated than simple deployment</li>
<li>Requires governance expertise</li>
<li>Learning curve for community</li>
</ul></li>
<li><strong>Voter Apathy</strong>
<ul>
<li>Low participation can centralize power</li>
<li>Requires active community engagement</li>
<li>Need to incentivize voting</li>
</ul></li>
<li><strong>Governance Attacks</strong>
<ul>
<li>Whale domination if tokens concentrated</li>
<li>Proposal spam</li>
<li>Coordination problems</li>
</ul></li>
<li><strong>Launch Risk</strong>
<ul>
<li>Swap may fail if insufficient interest</li>
<li>Initial distribution critical for decentralization</li>
<li>Legal and regulatory considerations</li>
</ul></li>
</ol>
<h3 id="best-practices-for-sns-launch">11.9 Best Practices for SNS
Launch</h3>
<p>Based on successful SNS launches in the ICP ecosystem:</p>
<h4 id="pre-launch">Pre-Launch</h4>
<ol type="1">
<li><strong>Build a Community</strong>
<ul>
<li>Engage users before SNS launch</li>
<li>Create Discord/forum for governance discussions</li>
<li>Educate about voting and proposals</li>
</ul></li>
<li><strong>Transparent Tokenomics</strong>
<ul>
<li>Publish distribution plan early</li>
<li>Explain vesting schedules</li>
<li>Show clear utility for token</li>
</ul></li>
<li><strong>Demo Governance</strong>
<ul>
<li>Run mock votes before SNS</li>
<li>Gather community feedback</li>
<li>Iterate on parameters</li>
</ul></li>
</ol>
<h4 id="during-swap">During Swap</h4>
<ol type="1">
<li><strong>Clear Communication</strong>
<ul>
<li>Multi-channel announcements</li>
<li>Step-by-step participation guides</li>
<li>FAQ and support channels</li>
</ul></li>
<li><strong>Fair Access</strong>
<ul>
<li>No pre-sales or insider deals</li>
<li>Reasonable caps per participant</li>
<li>Adequate swap duration</li>
</ul></li>
<li><strong>Security</strong>
<ul>
<li>Third-party audit of SNS config</li>
<li>Emergency contacts published</li>
<li>Monitoring throughout swap</li>
</ul></li>
</ol>
<h4 id="post-launch">Post-Launch</h4>
<ol type="1">
<li><strong>Active Governance</strong>
<ul>
<li>Regular proposal cadence</li>
<li>Transparent development roadmap</li>
<li>Community calls and updates</li>
</ul></li>
<li><strong>Voting Incentives</strong>
<ul>
<li>Rewards for participation</li>
<li>Gamification of governance</li>
<li>Recognition for active voters</li>
</ul></li>
<li><strong>Continuous Improvement</strong>
<ul>
<li>Gather governance feedback</li>
<li>Adjust parameters via proposals</li>
<li>Learn from other SNS DAOs</li>
</ul></li>
</ol>
<h3 id="case-study-openpatron-sns-journey">11.10 Case Study: OpenPatron
SNS Journey</h3>
<p>Let’s envision OpenPatron’s path to SNS governance:</p>
<p><strong>Month 0-3: Pre-Launch</strong> - Deploy MVP to mainnet with
developer control - Build user base to 10K users - Form governance
working group</p>
<p><strong>Month 4-6: Community Building</strong> - Launch governance
forum - Publish SNS proposal and tokenomics - Run governance
simulations</p>
<p><strong>Month 7: Decentralization Swap</strong> - 7-day swap period -
Goal: 500+ participants, 250K ICP raised - Result: 650 participants,
380K ICP raised ✓</p>
<p><strong>Month 8: First Proposals</strong> - Proposal #1: Adjust
platform fee from 1% to 0.5% - Result: Passed (92% yes) - Proposal #2:
Add creator verification features - Result: Passed (87% yes)</p>
<p><strong>Month 12: Maturity</strong> - 25 proposals submitted - 80%
average participation rate - Token trading on DEXs - 3 major platform
upgrades via governance</p>
<p><strong>Result:</strong> OpenPatron is now truly owned by its
community, with a treasury of 380K ICP + 20M governance tokens for
future development.</p>
<h3 id="the-future-of-sns">11.11 The Future of SNS</h3>
<p>The SNS framework continues to evolve with new features:</p>
<p><strong>On the Roadmap:</strong> - <strong>Multi-sig
proposals:</strong> Require multiple neurons to co-sponsor -
<strong>Delegation markets:</strong> Trade voting power temporarily -
<strong>Cross-SNS governance:</strong> DAOs governing other DAOs -
<strong>Advanced voting:</strong> Quadratic voting, conviction voting -
<strong>Specialized neurons:</strong> Role-based governance tokens</p>
<h3 id="summary-4">11.12 Summary</h3>
<p>The Service Nervous System represents the pinnacle of decentralized
governance on the Internet Computer:</p>
<ol type="1">
<li><strong>Architecture:</strong> Multi-canister system providing
complete DAO infrastructure</li>
<li><strong>Neurons:</strong> Time-locked tokens with bonuses for
long-term commitment</li>
<li><strong>Proposals:</strong> Executable governance decisions with
automatic enforcement</li>
<li><strong>Voting:</strong> Liquid democracy with following and
rewards</li>
<li><strong>Launch:</strong> Decentralization swap for fair token
distribution</li>
<li><strong>Integration:</strong> Governance-aware canister design</li>
<li><strong>Benefits:</strong> True decentralization while maintaining
upgradeability</li>
</ol>
<p>By launching OpenPatron through an SNS, you’ve completed the journey
from concept to community-owned platform. The code you wrote now belongs
to its users, who will guide its evolution through transparent, on-chain
governance.</p>
<p>This is the promise of Web3: <strong>software as a public good,
governed by those who use it.</strong></p>
<hr />
<hr />
<h1 id="chapter-14-troubleshooting-and-best-practices">Chapter 14:
Troubleshooting and Best Practices</h1>
<p>Even experienced developers encounter specific Motoko quirks. This
comprehensive chapter outlines common compiler errors, debugging
strategies, performance optimization techniques, and security best
practices to help you build robust and efficient Internet Computer
applications.</p>
<h3 id="common-compiler-errors">12.1 Common Compiler Errors</h3>
<p>Understanding compiler errors is crucial for productive Motoko
development. Here’s an extensive guide to the most common issues you’ll
encounter.</p>
<p><strong>Table 3: Comprehensive Troubleshooting Guide</strong></p>
<table>
<colgroup>
<col style="width: 32%" />
<col style="width: 38%" />
<col style="width: 29%" />
</colgroup>
<thead>
<tr>
<th>Error Code</th>
<th>Description</th>
<th>Solution</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>M0096</strong></td>
<td>Expression cannot produce expected type.</td>
<td>Check for trailing semicolons in blocks returning values. Remove
<code>;</code> from the last expression.</td>
</tr>
<tr>
<td><strong>M0031</strong></td>
<td>Type mismatch in <code>async</code> return.</td>
<td>Ensure shared functions return <code>async T</code>. All public
functions must be async.</td>
</tr>
<tr>
<td><strong>M0019</strong></td>
<td>Unbound identifier <code>null</code>.</td>
<td>Use <code>?T</code> (Option type) if a value can be null. Import
<code>Option</code> from base library.</td>
</tr>
<tr>
<td><strong>M0050</strong></td>
<td>Literal out of range for type.</td>
<td>Value exceeds type bounds. Use larger type (e.g., <code>Int</code>
instead of <code>Int8</code>).</td>
</tr>
<tr>
<td><strong>M0057</strong></td>
<td>Unbound type.</td>
<td>Import the type or define it. Check spelling and module
imports.</td>
</tr>
<tr>
<td><strong>M0070</strong></td>
<td>Shared function has non-shared parameter type.</td>
<td>Ensure all parameters are shareable (no functions, objects with
methods).</td>
</tr>
<tr>
<td><strong>M0095</strong></td>
<td>Canister has no public shared functions.</td>
<td>Add at least one <code>public shared</code> function for the
canister to be callable.</td>
</tr>
<tr>
<td><strong>M0138</strong></td>
<td>Variant case mismatch.</td>
<td>Check variant constructor names match exactly (case-sensitive).</td>
</tr>
<tr>
<td><strong>M0155</strong></td>
<td>Cycle balance depleted.</td>
<td>Top up canister cycles or optimize cycle consumption.</td>
</tr>
<tr>
<td><strong>Canister Trapped</strong></td>
<td>Runtime failure (e.g., integer underflow, out of bounds).</td>
<td>Use <code>Nat</code> carefully. Ensure arrays are not accessed out
of bounds. Add bounds checks.</td>
</tr>
</tbody>
</table>
<h4 id="trailing-semicolon-issues">12.1.1 Trailing Semicolon Issues</h4>
<p>One of the most common mistakes in Motoko is adding a semicolon after
the final expression in a block:</p>
<pre class="motoko"><code>// ❌ Wrong - semicolon makes function return ()
public func getValue() : async Nat {
    let result = 42;
    result;  // This returns the value correctly
};

// ❌ Wrong - semicolon discards the value
public func getValueWrong() : async Nat {
    let result = 42;
    result;  // ERROR: semicolon makes this return ()
};

// ✅ Correct
public func getValueCorrect() : async Nat {
    let result = 42;
    result   // No semicolon on last expression
};</code></pre>
<h4 id="asyncawait-mismatches">12.1.2 Async/Await Mismatches</h4>
<pre class="motoko"><code>// ❌ Wrong - missing async
public shared func updateBalance(amount: Nat) : Nat {
    balance += amount;
    balance
};

// ✅ Correct
public shared func updateBalance(amount: Nat) : async Nat {
    balance += amount;
    balance
};

// ❌ Wrong - forgot await on async call
public shared func callOther() : async Text {
    let result = otherCanister.getValue();  // Missing await
    result
};

// ✅ Correct
public shared func callOther() : async Text {
    let result = await otherCanister.getValue();
    result
};</code></pre>
<h4 id="type-inference-limitations">12.1.3 Type Inference
Limitations</h4>
<p>Sometimes the compiler needs explicit type annotations:</p>
<pre class="motoko"><code>// ❌ May fail type inference
let items = [];
items.add(1);

// ✅ Better - explicit type
let items : Buffer.Buffer&lt;Nat&gt; = Buffer.Buffer&lt;Nat&gt;(0);
items.add(1);

// ✅ Or infer from initialization
let items = Buffer.Buffer&lt;Nat&gt;(0);
items.add(1);</code></pre>
<h3 id="debugging-techniques-1">12.2 Debugging Techniques</h3>
<p>Since canisters run on a remote blockchain, traditional debugging
approaches need adaptation. Here are comprehensive strategies for
effective Motoko debugging.</p>
<h4 id="debug.print-for-local-development">12.2.1 Debug.print() for
Local Development</h4>
<p><code>Debug.print()</code> is your primary debugging tool during
local development:</p>
<pre class="motoko"><code>import Debug &quot;mo:base/Debug&quot;;
import Int &quot;mo:base/Int&quot;;
import Array &quot;mo:base/Array&quot;;

actor {
    public func processData(values: [Nat]) : async Nat {
        Debug.print(&quot;Processing &quot; # debug_show(values.size()) # &quot; values&quot;);
        
        var sum = 0;
        for (v in values.vals()) {
            Debug.print(&quot;Processing value: &quot; # debug_show(v));
            sum += v;
        };
        
        Debug.print(&quot;Final sum: &quot; # debug_show(sum));
        sum
    };
};</code></pre>
<p><strong>Important Notes:</strong> - <code>Debug.print()</code> only
works on local replicas and testnets - Output appears in dfx console,
not in canister responses - Use <code>debug_show()</code> to convert any
value to text representation - On mainnet, Debug.print calls are no-ops
(they don’t execute)</p>
<h4 id="structured-logging-pattern">12.2.2 Structured Logging
Pattern</h4>
<p>Create a logging system that can work both locally and in
production:</p>
<pre class="motoko"><code>import Array &quot;mo:base/Array&quot;;
import Time &quot;mo:base/Time&quot;;
import Text &quot;mo:base/Text&quot;;
import Buffer &quot;mo:base/Buffer&quot;;
import Debug &quot;mo:base/Debug&quot;;

actor Logger {
    type LogLevel = {
        #INFO;
        #WARN;
        #ERROR;
        #DEBUG;
    };
    
    type LogEntry = {
        timestamp: Time.Time;
        level: LogLevel;
        message: Text;
    };
    
    stable var logs : [LogEntry] = [];
    let logBuffer = Buffer.Buffer&lt;LogEntry&gt;(100);
    
    // Maximum logs to keep in memory
    let MAX_LOGS = 1000;
    
    private func log(level: LogLevel, message: Text) {
        let entry : LogEntry = {
            timestamp = Time.now();
            level = level;
            message = message;
        };
        
        logBuffer.add(entry);
        
        // Also print locally
        Debug.print(&quot;[&quot; # debug_show(level) # &quot;] &quot; # message);
        
        // Keep buffer size manageable
        if (logBuffer.size() &gt; MAX_LOGS) {
            ignore logBuffer.remove(0);
        };
    };
    
    public func info(message: Text) : async () {
        log(#INFO, message);
    };
    
    public func warn(message: Text) : async () {
        log(#WARN, message);
    };
    
    public func error(message: Text) : async () {
        log(#ERROR, message);
    };
    
    public query func getLogs(count: Nat) : async [LogEntry] {
        let size = logBuffer.size();
        let start = if (size &gt; count) { size - count } else { 0 };
        Buffer.toArray(Buffer.subBuffer(logBuffer, start, size - start))
    };
    
    system func preupgrade() {
        logs := Buffer.toArray(logBuffer);
    };
    
    system func postupgrade() {
        for (entry in logs.vals()) {
            logBuffer.add(entry);
        };
    };
};</code></pre>
<h4 id="trap-analysis-and-error-handling">12.2.3 Trap Analysis and Error
Handling</h4>
<p>When a canister traps, it’s crucial to understand why. Implement
comprehensive error handling:</p>
<pre class="motoko"><code>import Result &quot;mo:base/Result&quot;;
import Error &quot;mo:base/Error&quot;;
import Debug &quot;mo:base/Debug&quot;;

actor {
    type DatabaseError = {
        #NotFound;
        #InvalidInput: Text;
        #InternalError: Text;
    };
    
    var storage = HashMap.HashMap&lt;Text, Nat&gt;(10, Text.equal, Text.hash);
    
    // ❌ Bad - will trap on errors
    public func getValueUnsafe(key: Text) : async Nat {
        switch (storage.get(key)) {
            case null { assert false; 0 }; // Traps!
            case (?v) v;
        };
    };
    
    // ✅ Good - returns Result type
    public func getValue(key: Text) : async Result.Result&lt;Nat, DatabaseError&gt; {
        switch (storage.get(key)) {
            case null { #err(#NotFound) };
            case (?v) { #ok(v) };
        };
    };
    
    // ✅ Better - with logging
    public func getValueWithLogging(key: Text) : async Result.Result&lt;Nat, DatabaseError&gt; {
        Debug.print(&quot;Getting value for key: &quot; # key);
        switch (storage.get(key)) {
            case null {
                Debug.print(&quot;Key not found: &quot; # key);
                #err(#NotFound)
            };
            case (?v) {
                Debug.print(&quot;Found value: &quot; # debug_show(v));
                #ok(v)
            };
        };
    };
    
    // Handle arithmetic safely
    public func safeDivide(a: Int, b: Int) : async Result.Result&lt;Int, Text&gt; {
        if (b == 0) {
            #err(&quot;Division by zero&quot;)
        } else {
            #ok(a / b)
        };
    };
};</code></pre>
<h4 id="state-inspection-and-query-functions">12.2.4 State Inspection
and Query Functions</h4>
<p>Create query functions to inspect canister state during
debugging:</p>
<pre class="motoko"><code>actor {
    stable var userCount : Nat = 0;
    var cache = HashMap.HashMap&lt;Text, Text&gt;(10, Text.equal, Text.hash);
    
    // Debug query functions
    public query func debug_getUserCount() : async Nat {
        userCount
    };
    
    public query func debug_getCacheSize() : async Nat {
        cache.size()
    };
    
    public query func debug_getCacheKeys() : async [Text] {
        Iter.toArray(cache.keys())
    };
    
    public query func debug_getState() : async {
        userCount: Nat;
        cacheSize: Nat;
        memorySize: Nat;
    } {
        {
            userCount = userCount;
            cacheSize = cache.size();
            memorySize = Prim.rts_memory_size();
        }
    };
};</code></pre>
<h3 id="best-practices-2">12.3 Best Practices</h3>
<p>Following established best practices will help you write
maintainable, secure, and efficient Motoko code.</p>
<h4 id="code-organization">12.3.1 Code Organization</h4>
<p><strong>Modularization:</strong></p>
<pre class="motoko"><code>// types.mo - Centralize type definitions
module Types {
    public type User = {
        id: Principal;
        name: Text;
        email: Text;
        createdAt: Int;
    };
    
    public type Post = {
        id: Nat;
        author: Principal;
        content: Text;
        timestamp: Int;
    };
};

// utils.mo - Reusable utility functions
module Utils {
    import Text &quot;mo:base/Text&quot;;
    
    public func validateEmail(email: Text) : Bool {
        Text.contains(email, #text &quot;@&quot;) and Text.size(email) &gt; 3
    };
    
    public func sanitizeInput(input: Text) : Text {
        // Remove potentially dangerous characters
        Text.trim(input, #text &quot; \n\t\r&quot;)
    };
};

// main.mo - Main actor
import Types &quot;types&quot;;
import Utils &quot;utils&quot;;

actor Main {
    stable var users : [Types.User] = [];
    
    public shared(msg) func registerUser(name: Text, email: Text) : async Result.Result&lt;(), Text&gt; {
        if (not Utils.validateEmail(email)) {
            return #err(&quot;Invalid email format&quot;);
        };
        
        let newUser : Types.User = {
            id = msg.caller;
            name = Utils.sanitizeInput(name);
            email = email;
            createdAt = Time.now();
        };
        
        // Add user logic...
        #ok(())
    };
};</code></pre>
<h4 id="stable-memory-management">12.3.2 Stable Memory Management</h4>
<pre class="motoko"><code>import HashMap &quot;mo:base/HashMap&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Array &quot;mo:base/Array&quot;;

actor {
    // ❌ Bad - will lose data on upgrade
    var users = HashMap.HashMap&lt;Principal, User&gt;(10, Principal.equal, Principal.hash);
    
    // ✅ Good - stable storage with upgrade hooks
    stable var stableUsers : [(Principal, User)] = [];
    var users = HashMap.HashMap&lt;Principal, User&gt;(10, Principal.equal, Principal.hash);
    
    system func preupgrade() {
        stableUsers := Iter.toArray(users.entries());
    };
    
    system func postupgrade() {
        users := HashMap.fromIter&lt;Principal, User&gt;(
            stableUsers.vals(),
            10,
            Principal.equal,
            Principal.hash
        );
        stableUsers := [];  // Free memory
    };
};</code></pre>
<h4 id="cycle-management">12.3.3 Cycle Management</h4>
<p>Always monitor and manage cycles proactively:</p>
<pre class="motoko"><code>import Cycles &quot;mo:base/ExperimentalCycles&quot;;
import Error &quot;mo:base/Error&quot;;

actor {
    private let MINIMUM_CYCLES : Nat = 1_000_000_000_000; // 1T cycles
    private let CYCLE_THRESHOLD : Nat = 5_000_000_000_000; // 5T cycles
    
    public shared func checkCycleBalance() : async Nat {
        Cycles.balance()
    };
    
    public shared func acceptCycles() : async Nat {
        let available = Cycles.available();
        let accepted = Cycles.accept(available);
        accepted
    };
    
    // Check cycles before expensive operations
    private func ensureSufficientCycles() : Bool {
        Cycles.balance() &gt;= MINIMUM_CYCLES
    };
    
    public shared func expensiveOperation() : async Result.Result&lt;(), Text&gt; {
        if (not ensureSufficientCycles()) {
            return #err(&quot;Insufficient cycles&quot;);
        };
        
        // Perform operation...
        #ok(())
    };
    
    // Monitor and alert on low cycles
    public query func needsCycleTopup() : async Bool {
        Cycles.balance() &lt; CYCLE_THRESHOLD
    };
};</code></pre>
<h4 id="security-best-practices">12.3.4 Security Best Practices</h4>
<p><strong>Authentication and Authorization:</strong></p>
<pre class="motoko"><code>import Principal &quot;mo:base/Principal&quot;;
import HashMap &quot;mo:base/HashMap&quot;;
import Result &quot;mo:base/Result&quot;;

actor SecureCanister {
    stable var owner : Principal = Principal.fromText(&quot;aaaaa-aa&quot;);
    stable var admins : [Principal] = [];
    
    // Role-based access control
    type Role = {
        #Owner;
        #Admin;
        #User;
    };
    
    private func getRole(caller: Principal) : Role {
        if (caller == owner) {
            return #Owner;
        };
        if (Array.find&lt;Principal&gt;(admins, func(p) { p == caller }) != null) {
            return #Admin;
        };
        #User
    };
    
    private func requireRole(caller: Principal, required: Role) : Result.Result&lt;(), Text&gt; {
        let role = getRole(caller);
        switch (role, required) {
            case (#Owner, _) { #ok(()) };  // Owner can do anything
            case (#Admin, #Admin) { #ok(()) };
            case (#Admin, #User) { #ok(()) };
            case (#User, #User) { #ok(()) };
            case (_, _) { #err(&quot;Insufficient permissions&quot;) };
        };
    };
    
    // Always validate caller identity
    public shared(msg) func adminOnlyFunction() : async Result.Result&lt;(), Text&gt; {
        switch (requireRole(msg.caller, #Admin)) {
            case (#ok(_)) {
                // Perform admin operation
                #ok(())
            };
            case (#err(e)) { #err(e) };
        };
    };
    
    // Prevent unauthorized access
    public shared(msg) func sensitiveOperation(amount: Nat) : async Result.Result&lt;(), Text&gt; {
        // Validate caller
        if (Principal.isAnonymous(msg.caller)) {
            return #err(&quot;Anonymous callers not allowed&quot;);
        };
        
        // Validate input
        if (amount == 0 or amount &gt; 1_000_000) {
            return #err(&quot;Invalid amount&quot;);
        };
        
        // Perform operation...
        #ok(())
    };
};</code></pre>
<p><strong>Input Validation:</strong></p>
<pre class="motoko"><code>module Validation {
    import Text &quot;mo:base/Text&quot;;
    import Nat &quot;mo:base/Nat&quot;;
    import Array &quot;mo:base/Array&quot;;
    
    public func validateText(input: Text, minLen: Nat, maxLen: Nat) : Bool {
        let len = Text.size(input);
        len &gt;= minLen and len &lt;= maxLen
    };
    
    public func validateNat(input: Nat, min: Nat, max: Nat) : Bool {
        input &gt;= min and input &lt;= max
    };
    
    public func sanitizeText(input: Text) : Text {
        // Remove null bytes and control characters
        Text.translate(input, func(c: Char) : Text {
            if (c == &#39;\0&#39; or c &lt; &#39; &#39;) { &quot;&quot; } else { Text.fromChar(c) }
        })
    };
    
    public func isValidPrincipal(p: Principal) : Bool {
        not Principal.isAnonymous(p)
    };
};</code></pre>
<h3 id="performance-optimization">12.4 Performance Optimization</h3>
<h4 id="data-structure-selection">12.4.1 Data Structure Selection</h4>
<p>Choose the right data structure for your use case:</p>
<pre class="motoko"><code>import HashMap &quot;mo:base/HashMap&quot;;
import RBTree &quot;mo:base/RBTree&quot;;
import Buffer &quot;mo:base/Buffer&quot;;
import Array &quot;mo:base/Array&quot;;

actor {
    // Use HashMap for fast lookups by key (O(1) average)
    var userCache = HashMap.HashMap&lt;Principal, User&gt;(100, Principal.equal, Principal.hash);
    
    // Use RBTree for sorted data and range queries (O(log n))
    var sortedScores = RBTree.RBTree&lt;Nat, User&gt;(Nat.compare);
    
    // Use Buffer for dynamic arrays with frequent additions (O(1) amortized)
    var eventLog = Buffer.Buffer&lt;Event&gt;(1000);
    
    // Use Array for immutable, fixed-size collections
    stable var constants : [Text] = [&quot;value1&quot;, &quot;value2&quot;, &quot;value3&quot;];
};</code></pre>
<h4 id="minimize-state-access">12.4.2 Minimize State Access</h4>
<pre class="motoko"><code>actor {
    stable var largeState : [User] = [];
    
    // ❌ Bad - multiple iterations over stable state
    public query func getActiveUsersCount() : async Nat {
        var count = 0;
        for (user in largeState.vals()) {
            if (user.active) { count += 1 };
        };
        count
    };
    
    // ✅ Better - maintain derived state
    stable var activeUserCount : Nat = 0;
    
    public func addUser(user: User) : async () {
        largeState := Array.append(largeState, [user]);
        if (user.active) {
            activeUserCount += 1;
        };
    };
    
    public query func getActiveUsersCountOptimized() : async Nat {
        activeUserCount  // O(1) instead of O(n)
    };
};</code></pre>
<h4 id="batch-operations-1">12.4.3 Batch Operations</h4>
<pre class="motoko"><code>actor {
    // ❌ Bad - multiple separate calls
    public shared func addUser(user: User) : async () {
        // Process one user
    };
    
    // ✅ Good - batch processing
    public shared func addUsers(users: [User]) : async [Result.Result&lt;(), Text&gt;] {
        Array.map&lt;User, Result.Result&lt;(), Text&gt;&gt;(
            users,
            func(user) {
                // Validate and process each user
                // Return result
                #ok(())
            }
        )
    };
};</code></pre>
<h4 id="query-vs-update-calls">12.4.4 Query vs Update Calls</h4>
<pre class="motoko"><code>actor {
    stable var counter : Nat = 0;
    var cache : Text = &quot;&quot;;
    
    // Use query for read-only operations (faster, no consensus)
    public query func getCounter() : async Nat {
        counter
    };
    
    public query func getCache() : async Text {
        cache
    };
    
    // Use update calls only when modifying state
    public shared func incrementCounter() : async Nat {
        counter += 1;
        counter
    };
    
    // Use composite queries for efficient multi-canister reads
    public composite query func getMultipleValues() : async {
        local: Nat;
        remote: Nat;
    } {
        let remoteValue = await otherCanister.getValue();  // Query call
        {
            local = counter;
            remote = remoteValue;
        }
    };
};</code></pre>
<h3 id="testing-strategies-1">12.5 Testing Strategies</h3>
<h4 id="unit-testing-with-motoko-test">12.5.1 Unit Testing with Motoko
Test</h4>
<pre class="motoko"><code>// test/utils.test.mo
import Debug &quot;mo:base/Debug&quot;;
import { test; suite } &quot;mo:test&quot;;
import Utils &quot;../src/utils&quot;;

suite(&quot;Utils Tests&quot;, func() {
    test(&quot;validateEmail with valid email&quot;, func() {
        let result = Utils.validateEmail(&quot;user@example.com&quot;);
        assert result == true;
    });
    
    test(&quot;validateEmail with invalid email&quot;, func() {
        let result = Utils.validateEmail(&quot;invalid&quot;);
        assert result == false;
    });
    
    test(&quot;sanitizeInput removes whitespace&quot;, func() {
        let result = Utils.sanitizeInput(&quot;  test  &quot;);
        assert result == &quot;test&quot;;
    });
});</code></pre>
<h4 id="integration-testing">12.5.2 Integration Testing</h4>
<div class="sourceCode" id="cb198"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/bin/bash</span></span>
<span id="cb198-2"><a href="#cb198-2" aria-hidden="true" tabindex="-1"></a><span class="co"># test/integration.sh</span></span>
<span id="cb198-3"><a href="#cb198-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-4"><a href="#cb198-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Start local replica</span></span>
<span id="cb198-5"><a href="#cb198-5" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> start <span class="at">--background</span> <span class="at">--clean</span></span>
<span id="cb198-6"><a href="#cb198-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-7"><a href="#cb198-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Deploy canisters</span></span>
<span id="cb198-8"><a href="#cb198-8" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> deploy</span>
<span id="cb198-9"><a href="#cb198-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-10"><a href="#cb198-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Run test scenarios</span></span>
<span id="cb198-11"><a href="#cb198-11" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> canister call my_canister addUser <span class="st">&#39;(record { name = &quot;Alice&quot;; email = &quot;alice@example.com&quot; })&#39;</span></span>
<span id="cb198-12"><a href="#cb198-12" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> canister call my_canister getUser <span class="st">&#39;(principal &quot;aaaaa-aa&quot;)&#39;</span></span>
<span id="cb198-13"><a href="#cb198-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-14"><a href="#cb198-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Verify results</span></span>
<span id="cb198-15"><a href="#cb198-15" aria-hidden="true" tabindex="-1"></a><span class="va">RESULT</span><span class="op">=</span><span class="va">$(</span><span class="ex">dfx</span> canister call my_canister getUserCount<span class="va">)</span></span>
<span id="cb198-16"><a href="#cb198-16" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">[</span> <span class="st">&quot;</span><span class="va">$RESULT</span><span class="st">&quot;</span> <span class="ot">!=</span> <span class="st">&quot;(1 : nat)&quot;</span> <span class="bu">]</span><span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb198-17"><a href="#cb198-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">echo</span> <span class="st">&quot;Test failed: Expected user count 1&quot;</span></span>
<span id="cb198-18"><a href="#cb198-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">exit</span> 1</span>
<span id="cb198-19"><a href="#cb198-19" aria-hidden="true" tabindex="-1"></a><span class="cf">fi</span></span>
<span id="cb198-20"><a href="#cb198-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-21"><a href="#cb198-21" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">&quot;All integration tests passed&quot;</span></span>
<span id="cb198-22"><a href="#cb198-22" aria-hidden="true" tabindex="-1"></a><span class="ex">dfx</span> stop</span></code></pre></div>
<h3 id="common-pitfalls-and-solutions">12.6 Common Pitfalls and
Solutions</h3>
<h4 id="integer-overflowunderflow">12.6.1 Integer
Overflow/Underflow</h4>
<pre class="motoko"><code>import Nat &quot;mo:base/Nat&quot;;
import Int &quot;mo:base/Int&quot;;

actor {
    // ❌ Bad - can trap on underflow
    public func unsafeSubtract(a: Nat, b: Nat) : async Nat {
        a - b  // Traps if b &gt; a
    };
    
    // ✅ Good - safe subtraction
    public func safeSubtract(a: Nat, b: Nat) : async Result.Result&lt;Nat, Text&gt; {
        if (b &gt; a) {
            #err(&quot;Underflow: b &gt; a&quot;)
        } else {
            #ok(a - b)
        };
    };
    
    // ✅ Use Int for values that can be negative
    public func safeDifference(a: Nat, b: Nat) : async Int {
        Int.abs(a) - Int.abs(b)
    };
};</code></pre>
<h4 id="memory-leaks">12.6.2 Memory Leaks</h4>
<pre class="motoko"><code>actor {
    // ❌ Bad - unbounded growth
    var logs : [Text] = [];
    
    public func addLog(message: Text) : async () {
        logs := Array.append(logs, [message]);  // Grows forever
    };
    
    // ✅ Good - bounded with rotation
    stable var logs : [Text] = [];
    let MAX_LOGS = 1000;
    
    public func addLogBounded(message: Text) : async () {
        logs := Array.append(logs, [message]);
        if (logs.size() &gt; MAX_LOGS) {
            logs := Array.subArray(logs, logs.size() - MAX_LOGS, MAX_LOGS);
        };
    };
};</code></pre>
<h4 id="upgrade-compatibility">12.6.3 Upgrade Compatibility</h4>
<pre class="motoko"><code>actor {
    // Version 1
    stable var users_v1 : [(Principal, Text)] = [];
    
    // Version 2 - Adding fields
    type UserV2 = {
        name: Text;
        email: Text;
        createdAt: Int;
    };
    
    stable var users_v2 : [(Principal, UserV2)] = [];
    
    system func postupgrade() {
        // Migrate from v1 to v2
        if (users_v1.size() &gt; 0 and users_v2.size() == 0) {
            users_v2 := Array.map&lt;(Principal, Text), (Principal, UserV2)&gt;(
                users_v1,
                func((id, name)) {
                    (id, {
                        name = name;
                        email = &quot;&quot;;  // Default value
                        createdAt = Time.now();
                    })
                }
            );
            users_v1 := [];  // Clear old data
        };
    };
};</code></pre>
<h3 id="monitoring-and-maintenance-1">12.7 Monitoring and
Maintenance</h3>
<h4 id="health-checks">12.7.1 Health Checks</h4>
<pre class="motoko"><code>actor HealthMonitor {
    stable var lastHealthCheck : Int = 0;
    stable var healthStatus : Text = &quot;OK&quot;;
    
    public query func health() : async {
        status: Text;
        timestamp: Int;
        cycles: Nat;
        memorySize: Nat;
    } {
        {
            status = healthStatus;
            timestamp = Time.now();
            cycles = Cycles.balance();
            memorySize = Prim.rts_memory_size();
        }
    };
    
    public shared func performHealthCheck() : async Bool {
        lastHealthCheck := Time.now();
        
        // Check cycles
        if (Cycles.balance() &lt; 1_000_000_000_000) {
            healthStatus := &quot;WARN: Low cycles&quot;;
            return false;
        };
        
        // Check memory
        if (Prim.rts_memory_size() &gt; 3_000_000_000) {
            healthStatus := &quot;WARN: High memory usage&quot;;
            return false;
        };
        
        healthStatus := &quot;OK&quot;;
        true
    };
};</code></pre>
<h4 id="metrics-collection">12.7.2 Metrics Collection</h4>
<pre class="motoko"><code>actor Metrics {
    stable var requestCount : Nat = 0;
    stable var errorCount : Nat = 0;
    stable var totalLatency : Nat = 0;
    
    public shared func incrementRequests() : async () {
        requestCount += 1;
    };
    
    public shared func recordError() : async () {
        errorCount += 1;
    };
    
    public shared func recordLatency(latency: Nat) : async () {
        totalLatency += latency;
    };
    
    public query func getMetrics() : async {
        requests: Nat;
        errors: Nat;
        avgLatency: Float;
        errorRate: Float;
    } {
        let avgLatency = if (requestCount &gt; 0) {
            Float.fromInt(totalLatency) / Float.fromInt(requestCount)
        } else {
            0.0
        };
        
        let errorRate = if (requestCount &gt; 0) {
            Float.fromInt(errorCount) / Float.fromInt(requestCount)
        } else {
            0.0
        };
        
        {
            requests = requestCount;
            errors = errorCount;
            avgLatency = avgLatency;
            errorRate = errorRate;
        }
    };
};</code></pre>
<h3 id="summary-5">12.8 Summary</h3>
<p>Effective troubleshooting and following best practices are essential
for building production-ready Internet Computer applications. Key
takeaways:</p>
<ol type="1">
<li><strong>Understand Common Errors</strong>: Familiarize yourself with
compiler error codes and their solutions.</li>
<li><strong>Debug Effectively</strong>: Use structured logging and query
functions to inspect state.</li>
<li><strong>Handle Errors Gracefully</strong>: Always use Result types
for operations that can fail.</li>
<li><strong>Secure Your Code</strong>: Implement proper authentication,
authorization, and input validation.</li>
<li><strong>Optimize Performance</strong>: Choose appropriate data
structures and minimize state access.</li>
<li><strong>Test Thoroughly</strong>: Write unit and integration tests
for critical functionality.</li>
<li><strong>Monitor in Production</strong>: Implement health checks and
metrics collection.</li>
<li><strong>Plan for Upgrades</strong>: Design stable variables and
migration strategies from the start.</li>
</ol>
<p>By following these practices, you’ll write more robust, maintainable,
and efficient Motoko applications.</p>
<hr />
<hr />
<h1 id="resources">Resources</h1>
<p>This chapter provides a curated list of essential resources for
Motoko and Internet Computer development. Whether you’re just starting
out or looking for advanced references, these links will help you deepen
your knowledge and stay current with the ecosystem.</p>
<h2 id="official-documentation">Official Documentation</h2>
<h3 id="motoko-language">Motoko Language</h3>
<ul>
<li><p><strong>Motoko Programming Language Guide</strong><br />
<a
href="https://internetcomputer.org/docs/motoko/home">https://internetcomputer.org/docs/motoko/home</a><br />
The official guide to Motoko programming, covering syntax, features, and
best practices.</p></li>
<li><p><strong>Motoko Base Library</strong><br />
<a
href="https://internetcomputer.org/docs/motoko/base/">https://internetcomputer.org/docs/motoko/base/</a><br />
Complete reference for Motoko’s standard library modules.</p></li>
<li><p><strong>Motoko Language Reference</strong><br />
<a
href="https://internetcomputer.org/docs/motoko/language-manual">https://internetcomputer.org/docs/motoko/language-manual</a><br />
Comprehensive language specification and reference manual.</p></li>
</ul>
<h3 id="internet-computer-protocol">Internet Computer Protocol</h3>
<ul>
<li><p><strong>Internet Computer Developer Documentation</strong><br />
<a
href="https://internetcomputer.org/docs/home">https://internetcomputer.org/docs/home</a><br />
Main developer portal for Internet Computer documentation.</p></li>
<li><p><strong>Internet Computer Specification</strong><br />
<a
href="https://internetcomputer.org/docs/references/ic-interface-spec">https://internetcomputer.org/docs/references/ic-interface-spec</a><br />
Technical specification of the Internet Computer Protocol.</p></li>
<li><p><strong>ICP Developer Journey</strong><br />
<a
href="https://internetcomputer.org/docs/tutorials/developer-liftoff/">https://internetcomputer.org/docs/tutorials/developer-liftoff/</a><br />
Step-by-step tutorials for building on the Internet Computer.</p></li>
</ul>
<h2 id="service-nervous-system-sns">Service Nervous System (SNS)</h2>
<ul>
<li><p><strong>SNS Documentation</strong><br />
<a
href="https://internetcomputer.org/docs/building-apps/governing-apps/">https://internetcomputer.org/docs/building-apps/governing-apps/</a><br />
Complete guide to creating and managing decentralized autonomous
organizations.</p></li>
<li><p><strong>SNS Launch Guide</strong><br />
<a
href="https://internetcomputer.org/docs/building-apps/governing-apps/launching/">https://internetcomputer.org/docs/building-apps/governing-apps/launching/</a><br />
Step-by-step process for launching an SNS.</p></li>
</ul>
<h2 id="community-and-learning-resources">Community and Learning
Resources</h2>
<h3 id="official-community-channels">Official Community Channels</h3>
<ul>
<li><p><strong>DFINITY Forum</strong><br />
<a
href="https://forum.dfinity.org/">https://forum.dfinity.org/</a><br />
Official community forum for discussions, questions, and
announcements.</p></li>
<li><p><strong>Internet Computer Developer Discord</strong><br />
<a
href="https://discord.internetcomputer.org/">https://discord.internetcomputer.org/</a><br />
Real-time chat with the developer community.</p></li>
<li><p><strong>DFINITY GitHub</strong><br />
<a
href="https://github.com/dfinity">https://github.com/dfinity</a><br />
Official repositories including IC SDK, examples, and tools.</p></li>
</ul>
<h3 id="learning-platforms">Learning Platforms</h3>
<ul>
<li><p><strong>ICP Ninja</strong><br />
<a href="https://icp.ninja/">https://icp.ninja/</a><br />
Interactive in-browser environment for writing and testing Motoko
code.</p></li>
<li><p><strong>Motoko Bootcamp</strong><br />
<a
href="https://www.motokobootcamp.com/">https://www.motokobootcamp.com/</a><br />
Community-driven educational program for learning Motoko.</p></li>
<li><p><strong>Internet Computer Developer YouTube
Channel</strong><br />
<a href="https://www.youtube.com/@DFINITY">https://www.youtube.com/<span
class="citation" data-cites="DFINITY">@DFINITY</span></a><br />
Official video tutorials, talks, and demonstrations.</p></li>
</ul>
<h3 id="example-projects">Example Projects</h3>
<ul>
<li><p><strong>Motoko Examples</strong><br />
<a
href="https://github.com/dfinity/examples/tree/master/motoko">https://github.com/dfinity/examples/tree/master/motoko</a><br />
Official collection of Motoko code examples.</p></li>
<li><p><strong>Awesome Internet Computer</strong><br />
<a
href="https://github.com/dfinity/awesome-internet-computer">https://github.com/dfinity/awesome-internet-computer</a><br />
Curated list of resources, tools, and projects.</p></li>
</ul>
<h2 id="development-tools">Development Tools</h2>
<h3 id="ides-and-extensions">IDEs and Extensions</h3>
<ul>
<li><strong>Motoko VS Code Extension</strong><br />
<a
href="https://marketplace.visualstudio.com/items?itemName=dfinity-foundation.vscode-motoko">https://marketplace.visualstudio.com/items?itemName=dfinity-foundation.vscode-motoko</a><br />
Official Visual Studio Code extension with syntax highlighting and
language support.</li>
</ul>
<h2 id="staying-updated">Staying Updated</h2>
<ul>
<li><p><strong>DFINITY Blog</strong><br />
<a
href="https://medium.com/dfinity">https://medium.com/dfinity</a><br />
Official blog with updates, tutorials, and announcements.</p></li>
<li><p><strong>Internet Computer Twitter</strong><br />
<a
href="https://twitter.com/dfinity">https://twitter.com/dfinity</a><br />
Latest news and community highlights.</p></li>
<li><p><strong>Developer Release Notes</strong><br />
<a
href="https://github.com/dfinity/sdk/releases">https://github.com/dfinity/sdk/releases</a><br />
SDK release notes and changelogs.</p></li>
</ul>
<hr />
<h2 id="contributing-to-this-resource-list">Contributing to This
Resource List</h2>
<p>This resource list is maintained as part of the “Mastering Motoko”
book. If you discover broken links, new valuable resources, or have
suggestions for additions, please contribute through the book’s
repository:</p>
<p><strong>Repository</strong>: <a
href="https://github.com/niklabh/motokobook">https://github.com/niklabh/motokobook</a></p>
<hr />
<p><em>Last Updated: November 2025</em></p>
<p><em>Note: URLs and resources may change over time. Please check the
official Internet Computer documentation portal for the most current
links.</em></p>
<hr />
<h2 id="about-this-book">About This Book</h2>
<p>This book was created to provide a comprehensive guide to motoko!
smart contract development on ICP. It covers everything from basic
concepts to advanced production patterns.</p>
<h3 id="technical-specifications">Technical Specifications</h3>
<ul>
<li><strong>dfx! Version</strong>: 0.29.2</li>
<li><strong>Target Environment</strong>: WebAssembly (WASM)</li>
<li><strong>Blockchain Framework</strong>: Internet Computer Protocol
(ICP)</li>
</ul>
<h3 id="contributing">Contributing</h3>
<p>This book is designed to be a living resource for the motoko!
community. For updates, corrections, or contributions, please refer to
the project repository: https://github.com/niklabh/motokobook.</p>
<h3 id="license">License</h3>
<p>This work is intended for educational purposes and represents best
practices as of the publication date. Smart contract development
involves financial risks, and readers should conduct thorough testing
and security audits before deploying contracts in production
environments.</p>
<hr />
<p><em>End of Book</em></p>
</body>
</html>
